{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.compareTopologyVersion = exports.parseServerType = exports.ServerDescription = void 0;\nvar bson_1 = require(\"../bson\");\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nvar common_1 = require(\"./common\");\nvar WRITABLE_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.Standalone, common_1.ServerType.Mongos, common_1.ServerType.LoadBalancer]);\nvar DATA_BEARING_SERVER_TYPES = new Set([common_1.ServerType.RSPrimary, common_1.ServerType.RSSecondary, common_1.ServerType.Mongos, common_1.ServerType.Standalone, common_1.ServerType.LoadBalancer]);\n/**\n * The client's view of a single server, based on the most recent hello outcome.\n *\n * Internal type, not meant to be directly instantiated\n * @public\n */\nvar ServerDescription = /*#__PURE__*/function () {\n  /**\n   * Create a ServerDescription\n   * @internal\n   *\n   * @param address - The address of the server\n   * @param hello - An optional hello response for this server\n   */\n  function ServerDescription(address, hello) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, ServerDescription);\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z;\n    if (address == null || address === '') {\n      throw new error_1.MongoRuntimeError('ServerDescription must be provided with a non-empty address');\n    }\n    this.address = typeof address === 'string' ? utils_1.HostAddress.fromString(address).toString(false) // Use HostAddress to normalize\n    : address.toString(false);\n    this.type = parseServerType(hello, options);\n    this.hosts = (_b = (_a = hello === null || hello === void 0 ? void 0 : hello.hosts) === null || _a === void 0 ? void 0 : _a.map(function (host) {\n      return host.toLowerCase();\n    })) !== null && _b !== void 0 ? _b : [];\n    this.passives = (_d = (_c = hello === null || hello === void 0 ? void 0 : hello.passives) === null || _c === void 0 ? void 0 : _c.map(function (host) {\n      return host.toLowerCase();\n    })) !== null && _d !== void 0 ? _d : [];\n    this.arbiters = (_f = (_e = hello === null || hello === void 0 ? void 0 : hello.arbiters) === null || _e === void 0 ? void 0 : _e.map(function (host) {\n      return host.toLowerCase();\n    })) !== null && _f !== void 0 ? _f : [];\n    this.tags = (_g = hello === null || hello === void 0 ? void 0 : hello.tags) !== null && _g !== void 0 ? _g : {};\n    this.minWireVersion = (_h = hello === null || hello === void 0 ? void 0 : hello.minWireVersion) !== null && _h !== void 0 ? _h : 0;\n    this.maxWireVersion = (_j = hello === null || hello === void 0 ? void 0 : hello.maxWireVersion) !== null && _j !== void 0 ? _j : 0;\n    this.roundTripTime = (_k = options === null || options === void 0 ? void 0 : options.roundTripTime) !== null && _k !== void 0 ? _k : -1;\n    this.lastUpdateTime = (0, utils_1.now)();\n    this.lastWriteDate = (_m = (_l = hello === null || hello === void 0 ? void 0 : hello.lastWrite) === null || _l === void 0 ? void 0 : _l.lastWriteDate) !== null && _m !== void 0 ? _m : 0;\n    this.error = (_o = options.error) !== null && _o !== void 0 ? _o : null;\n    // TODO(NODE-2674): Preserve int64 sent from MongoDB\n    this.topologyVersion = (_r = (_q = (_p = this.error) === null || _p === void 0 ? void 0 : _p.topologyVersion) !== null && _q !== void 0 ? _q : hello === null || hello === void 0 ? void 0 : hello.topologyVersion) !== null && _r !== void 0 ? _r : null;\n    this.setName = (_s = hello === null || hello === void 0 ? void 0 : hello.setName) !== null && _s !== void 0 ? _s : null;\n    this.setVersion = (_t = hello === null || hello === void 0 ? void 0 : hello.setVersion) !== null && _t !== void 0 ? _t : null;\n    this.electionId = (_u = hello === null || hello === void 0 ? void 0 : hello.electionId) !== null && _u !== void 0 ? _u : null;\n    this.logicalSessionTimeoutMinutes = (_v = hello === null || hello === void 0 ? void 0 : hello.logicalSessionTimeoutMinutes) !== null && _v !== void 0 ? _v : null;\n    this.primary = (_w = hello === null || hello === void 0 ? void 0 : hello.primary) !== null && _w !== void 0 ? _w : null;\n    this.me = (_y = (_x = hello === null || hello === void 0 ? void 0 : hello.me) === null || _x === void 0 ? void 0 : _x.toLowerCase()) !== null && _y !== void 0 ? _y : null;\n    this.$clusterTime = (_z = hello === null || hello === void 0 ? void 0 : hello.$clusterTime) !== null && _z !== void 0 ? _z : null;\n  }\n  _createClass(ServerDescription, [{\n    key: \"equals\",\n    /**\n     * Determines if another `ServerDescription` is equal to this one per the rules defined\n     * in the {@link https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#serverdescription|SDAM spec}\n     */\n    value: function equals(other) {\n      // Despite using the comparator that would determine a nullish topologyVersion as greater than\n      // for equality we should only always perform direct equality comparison\n      var topologyVersionsEqual = this.topologyVersion === (other === null || other === void 0 ? void 0 : other.topologyVersion) || compareTopologyVersion(this.topologyVersion, other === null || other === void 0 ? void 0 : other.topologyVersion) === 0;\n      var electionIdsEqual = this.electionId != null && (other === null || other === void 0 ? void 0 : other.electionId) != null ? (0, utils_1.compareObjectId)(this.electionId, other.electionId) === 0 : this.electionId === (other === null || other === void 0 ? void 0 : other.electionId);\n      return other != null && (0, utils_1.errorStrictEqual)(this.error, other.error) && this.type === other.type && this.minWireVersion === other.minWireVersion && (0, utils_1.arrayStrictEqual)(this.hosts, other.hosts) && tagsStrictEqual(this.tags, other.tags) && this.setName === other.setName && this.setVersion === other.setVersion && electionIdsEqual && this.primary === other.primary && this.logicalSessionTimeoutMinutes === other.logicalSessionTimeoutMinutes && topologyVersionsEqual;\n    }\n  }, {\n    key: \"hostAddress\",\n    get: function get() {\n      return utils_1.HostAddress.fromString(this.address);\n    }\n  }, {\n    key: \"allHosts\",\n    get: function get() {\n      return this.hosts.concat(this.arbiters).concat(this.passives);\n    } /** Is this server available for reads*/\n  }, {\n    key: \"isReadable\",\n    get: function get() {\n      return this.type === common_1.ServerType.RSSecondary || this.isWritable;\n    } /** Is this server data bearing */\n  }, {\n    key: \"isDataBearing\",\n    get: function get() {\n      return DATA_BEARING_SERVER_TYPES.has(this.type);\n    } /** Is this server available for writes */\n  }, {\n    key: \"isWritable\",\n    get: function get() {\n      return WRITABLE_SERVER_TYPES.has(this.type);\n    }\n  }, {\n    key: \"host\",\n    get: function get() {\n      var chopLength = \":\".concat(this.port).length;\n      return this.address.slice(0, -chopLength);\n    }\n  }, {\n    key: \"port\",\n    get: function get() {\n      var port = this.address.split(':').pop();\n      return port ? Number.parseInt(port, 10) : 27017;\n    }\n  }]);\n  return ServerDescription;\n}();\nexports.ServerDescription = ServerDescription;\n// Parses a `hello` message and determines the server type\nfunction parseServerType(hello, options) {\n  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {\n    return common_1.ServerType.LoadBalancer;\n  }\n  if (!hello || !hello.ok) {\n    return common_1.ServerType.Unknown;\n  }\n  if (hello.isreplicaset) {\n    return common_1.ServerType.RSGhost;\n  }\n  if (hello.msg && hello.msg === 'isdbgrid') {\n    return common_1.ServerType.Mongos;\n  }\n  if (hello.setName) {\n    if (hello.hidden) {\n      return common_1.ServerType.RSOther;\n    } else if (hello.isWritablePrimary) {\n      return common_1.ServerType.RSPrimary;\n    } else if (hello.secondary) {\n      return common_1.ServerType.RSSecondary;\n    } else if (hello.arbiterOnly) {\n      return common_1.ServerType.RSArbiter;\n    } else {\n      return common_1.ServerType.RSOther;\n    }\n  }\n  return common_1.ServerType.Standalone;\n}\nexports.parseServerType = parseServerType;\nfunction tagsStrictEqual(tags, tags2) {\n  var tagsKeys = Object.keys(tags);\n  var tags2Keys = Object.keys(tags2);\n  return tagsKeys.length === tags2Keys.length && tagsKeys.every(function (key) {\n    return tags2[key] === tags[key];\n  });\n}\n/**\n * Compares two topology versions.\n *\n * 1. If the response topologyVersion is unset or the ServerDescription's\n *    topologyVersion is null, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is not equal to the\n *    ServerDescription's, the client MUST assume the response is more recent.\n * 1. If the response's topologyVersion.processId is equal to the\n *    ServerDescription's, the client MUST use the counter field to determine\n *    which topologyVersion is more recent.\n *\n * ```ts\n * currentTv <   newTv === -1\n * currentTv === newTv === 0\n * currentTv >   newTv === 1\n * ```\n */\nfunction compareTopologyVersion(currentTv, newTv) {\n  if (currentTv == null || newTv == null) {\n    return -1;\n  }\n  if (!currentTv.processId.equals(newTv.processId)) {\n    return -1;\n  }\n  // TODO(NODE-2674): Preserve int64 sent from MongoDB\n  var currentCounter = bson_1.Long.isLong(currentTv.counter) ? currentTv.counter : bson_1.Long.fromNumber(currentTv.counter);\n  var newCounter = bson_1.Long.isLong(newTv.counter) ? newTv.counter : bson_1.Long.fromNumber(newTv.counter);\n  return currentCounter.compare(newCounter);\n}\nexports.compareTopologyVersion = compareTopologyVersion;","map":null,"metadata":{},"sourceType":"script"}