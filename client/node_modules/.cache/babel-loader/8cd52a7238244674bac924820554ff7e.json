{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InsertManyOperation = exports.InsertOneOperation = exports.InsertOperation = void 0;\nvar error_1 = require(\"../error\");\nvar write_concern_1 = require(\"../write_concern\");\nvar bulk_write_1 = require(\"./bulk_write\");\nvar command_1 = require(\"./command\");\nvar common_functions_1 = require(\"./common_functions\");\nvar operation_1 = require(\"./operation\");\n/** @internal */\nvar InsertOperation = /*#__PURE__*/function (_command_1$CommandOpe) {\n  _inherits(InsertOperation, _command_1$CommandOpe);\n  function InsertOperation(ns, documents, options) {\n    var _this;\n    _classCallCheck(this, InsertOperation);\n    var _a;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(InsertOperation).call(this, undefined, options));\n    _this.options = _objectSpread({}, options, {\n      checkKeys: (_a = options.checkKeys) !== null && _a !== void 0 ? _a : false\n    });\n    _this.ns = ns;\n    _this.documents = documents;\n    return _this;\n  }\n  _createClass(InsertOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _a;\n      var options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n      var command = {\n        insert: this.ns.collection,\n        documents: this.documents,\n        ordered: ordered\n      };\n      if (typeof options.bypassDocumentValidation === 'boolean') {\n        command.bypassDocumentValidation = options.bypassDocumentValidation;\n      }\n      // we check for undefined specifically here to allow falsy values\n      // eslint-disable-next-line no-restricted-syntax\n      if (options.comment !== undefined) {\n        command.comment = options.comment;\n      }\n      _get(_getPrototypeOf(InsertOperation.prototype), \"executeCommand\", this).call(this, server, session, command, callback);\n    }\n  }]);\n  return InsertOperation;\n}(command_1.CommandOperation);\nexports.InsertOperation = InsertOperation;\nvar InsertOneOperation = /*#__PURE__*/function (_InsertOperation) {\n  _inherits(InsertOneOperation, _InsertOperation);\n  function InsertOneOperation(collection, doc, options) {\n    _classCallCheck(this, InsertOneOperation);\n    return _possibleConstructorReturn(this, _getPrototypeOf(InsertOneOperation).call(this, collection.s.namespace, (0, common_functions_1.prepareDocs)(collection, [doc], options), options));\n  }\n  _createClass(InsertOneOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this2 = this;\n      _get(_getPrototypeOf(InsertOneOperation.prototype), \"execute\", this).call(this, server, session, function (err, res) {\n        var _a, _b;\n        if (err || res == null) return callback(err);\n        if (res.code) return callback(new error_1.MongoServerError(res));\n        if (res.writeErrors) {\n          // This should be a WriteError but we can't change it now because of error hierarchy\n          return callback(new error_1.MongoServerError(res.writeErrors[0]));\n        }\n        callback(undefined, {\n          acknowledged: (_b = ((_a = _this2.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n          insertedId: _this2.documents[0]._id\n        });\n      });\n    }\n  }]);\n  return InsertOneOperation;\n}(InsertOperation);\nexports.InsertOneOperation = InsertOneOperation;\n/** @internal */\nvar InsertManyOperation = /*#__PURE__*/function (_operation_1$Abstract) {\n  _inherits(InsertManyOperation, _operation_1$Abstract);\n  function InsertManyOperation(collection, docs, options) {\n    var _this3;\n    _classCallCheck(this, InsertManyOperation);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(InsertManyOperation).call(this, options));\n    if (!Array.isArray(docs)) {\n      throw new error_1.MongoInvalidArgumentError('Argument \"docs\" must be an array of documents');\n    }\n    _this3.options = options;\n    _this3.collection = collection;\n    _this3.docs = docs;\n    return _this3;\n  }\n  _createClass(InsertManyOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var coll = this.collection;\n      var options = _objectSpread({}, this.options, this.bsonOptions, {\n        readPreference: this.readPreference\n      });\n      var writeConcern = write_concern_1.WriteConcern.fromOptions(options);\n      var bulkWriteOperation = new bulk_write_1.BulkWriteOperation(coll, (0, common_functions_1.prepareDocs)(coll, this.docs, options).map(function (document) {\n        return {\n          insertOne: {\n            document: document\n          }\n        };\n      }), options);\n      bulkWriteOperation.execute(server, session, function (err, res) {\n        var _a;\n        if (err || res == null) {\n          if (err && err.message === 'Operation must be an object with an operation key') {\n            err = new error_1.MongoInvalidArgumentError('Collection.insertMany() cannot be called with an array that has null/undefined values');\n          }\n          return callback(err);\n        }\n        callback(undefined, {\n          acknowledged: (_a = (writeConcern === null || writeConcern === void 0 ? void 0 : writeConcern.w) !== 0) !== null && _a !== void 0 ? _a : true,\n          insertedCount: res.insertedCount,\n          insertedIds: res.insertedIds\n        });\n      });\n    }\n  }]);\n  return InsertManyOperation;\n}(operation_1.AbstractOperation);\nexports.InsertManyOperation = InsertManyOperation;\n(0, operation_1.defineAspects)(InsertOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(InsertManyOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":null,"metadata":{},"sourceType":"script"}