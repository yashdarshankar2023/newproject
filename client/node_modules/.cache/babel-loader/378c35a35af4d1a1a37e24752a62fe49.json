{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _get = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\nvar timers_1 = require(\"timers\");\nvar constants_1 = require(\"../constants\");\nvar error_1 = require(\"../error\");\nvar mongo_types_1 = require(\"../mongo_types\");\nvar sessions_1 = require(\"../sessions\");\nvar utils_1 = require(\"../utils\");\nvar command_monitoring_events_1 = require(\"./command_monitoring_events\");\nvar commands_1 = require(\"./commands\");\nvar message_stream_1 = require(\"./message_stream\");\nvar stream_description_1 = require(\"./stream_description\");\nvar shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nvar kStream = Symbol('stream');\n/** @internal */\nvar kQueue = Symbol('queue');\n/** @internal */\nvar kMessageStream = Symbol('messageStream');\n/** @internal */\nvar kGeneration = Symbol('generation');\n/** @internal */\nvar kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nvar kClusterTime = Symbol('clusterTime');\n/** @internal */\nvar kDescription = Symbol('description');\n/** @internal */\nvar kHello = Symbol('hello');\n/** @internal */\nvar kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nvar kDelayedTimeoutId = Symbol('delayedTimeoutId');\n/** @internal */\nvar Connection = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(Connection, _mongo_types_1$TypedE);\n  function Connection(stream, options) {\n    var _this;\n    _classCallCheck(this, Connection);\n    var _a, _b;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connection).call(this));\n    _this.id = options.id;\n    _this.address = streamIdentifier(stream, options);\n    _this.socketTimeoutMS = (_a = options.socketTimeoutMS) !== null && _a !== void 0 ? _a : 0;\n    _this.monitorCommands = options.monitorCommands;\n    _this.serverApi = options.serverApi;\n    _this.closed = false;\n    _this.destroyed = false;\n    _this[kHello] = null;\n    _this[kClusterTime] = null;\n    _this[kDescription] = new stream_description_1.StreamDescription(_this.address, options);\n    _this[kGeneration] = options.generation;\n    _this[kLastUseTime] = (0, utils_1.now)();\n    // setup parser stream and message handling\n    _this[kQueue] = new Map();\n    _this[kMessageStream] = new message_stream_1.MessageStream(_objectSpread({}, options, {\n      maxBsonMessageSize: (_b = _this.hello) === null || _b === void 0 ? void 0 : _b.maxBsonMessageSize\n    }));\n    _this[kStream] = stream;\n    _this[kDelayedTimeoutId] = null;\n    _this[kMessageStream].on('message', function (message) {\n      return _this.onMessage(message);\n    });\n    _this[kMessageStream].on('error', function (error) {\n      return _this.onError(error);\n    });\n    _this[kStream].on('close', function () {\n      return _this.onClose();\n    });\n    _this[kStream].on('timeout', function () {\n      return _this.onTimeout();\n    });\n    _this[kStream].on('error', function () {\n      /* ignore errors, listen to `close` instead */\n    });\n    // hook the message stream up to the passed in stream\n    _this[kStream].pipe(_this[kMessageStream]);\n    _this[kMessageStream].pipe(_this[kStream]);\n    return _this;\n  }\n  _createClass(Connection, [{\n    key: \"markAvailable\",\n    value: function markAvailable() {\n      this[kLastUseTime] = (0, utils_1.now)();\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      if (this.closed) {\n        return;\n      }\n      this[kStream].destroy(error);\n      this.closed = true;\n      var _iterator = _createForOfIteratorHelper(this[kQueue].values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var op = _step.value;\n          op.cb(error);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      if (this.closed) {\n        return;\n      }\n      this.closed = true;\n      var message = \"connection \".concat(this.id, \" to \").concat(this.address, \" closed\");\n      var _iterator2 = _createForOfIteratorHelper(this[kQueue].values()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var op = _step2.value;\n          op.cb(new error_1.MongoNetworkError(message));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    }\n  }, {\n    key: \"onTimeout\",\n    value: function onTimeout() {\n      var _this2 = this;\n      if (this.closed) {\n        return;\n      }\n      this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(function () {\n        _this2[kStream].destroy();\n        _this2.closed = true;\n        var message = \"connection \".concat(_this2.id, \" to \").concat(_this2.address, \" timed out\");\n        var beforeHandshake = _this2.hello == null;\n        var _iterator3 = _createForOfIteratorHelper(_this2[kQueue].values()),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var op = _step3.value;\n            op.cb(new error_1.MongoNetworkTimeoutError(message, {\n              beforeHandshake: beforeHandshake\n            }));\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n        _this2[kQueue].clear();\n        _this2.emit(Connection.CLOSE);\n      }, 1).unref(); // No need for this timer to hold the event loop open\n    }\n  }, {\n    key: \"onMessage\",\n    value: function onMessage(message) {\n      var delayedTimeoutId = this[kDelayedTimeoutId];\n      if (delayedTimeoutId != null) {\n        (0, timers_1.clearTimeout)(delayedTimeoutId);\n        this[kDelayedTimeoutId] = null;\n      }\n      // always emit the message, in case we are streaming\n      this.emit('message', message);\n      var operationDescription = this[kQueue].get(message.responseTo);\n      if (!operationDescription) {\n        return;\n      }\n      var callback = operationDescription.cb;\n      // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n      // track response, however the server currently synthetically produces remote requests\n      // making the `responseTo` change on each response\n      this[kQueue].delete(message.responseTo);\n      if ('moreToCome' in message && message.moreToCome) {\n        // requeue the callback for next synthetic request\n        this[kQueue].set(message.requestId, operationDescription);\n      } else if (operationDescription.socketTimeoutOverride) {\n        this[kStream].setTimeout(this.socketTimeoutMS);\n      }\n      try {\n        // Pass in the entire description because it has BSON parsing options\n        message.parse(operationDescription);\n      } catch (err) {\n        // If this error is generated by our own code, it will already have the correct class applied\n        // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n        // in either case, it should not be wrapped\n        callback(err);\n        return;\n      }\n      if (message.documents[0]) {\n        var document = message.documents[0];\n        var session = operationDescription.session;\n        if (session) {\n          (0, sessions_1.updateSessionFromResponse)(session, document);\n        }\n        if (document.$clusterTime) {\n          this[kClusterTime] = document.$clusterTime;\n          this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n        }\n        if (operationDescription.command) {\n          if (document.writeConcernError) {\n            callback(new error_1.MongoWriteConcernError(document.writeConcernError, document));\n            return;\n          }\n          if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n            callback(new error_1.MongoServerError(document));\n            return;\n          }\n        } else {\n          // Pre 3.2 support\n          if (document.ok === 0 || document.$err || document.errmsg) {\n            callback(new error_1.MongoServerError(document));\n            return;\n          }\n        }\n      }\n      callback(undefined, message.documents[0]);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(options, callback) {\n      var _this3 = this;\n      if (typeof options === 'function') {\n        callback = options;\n        options = {\n          force: false\n        };\n      }\n      this.removeAllListeners(Connection.PINNED);\n      this.removeAllListeners(Connection.UNPINNED);\n      options = Object.assign({\n        force: false\n      }, options);\n      if (this[kStream] == null || this.destroyed) {\n        this.destroyed = true;\n        if (typeof callback === 'function') {\n          callback();\n        }\n        return;\n      }\n      if (options.force) {\n        this[kStream].destroy();\n        this.destroyed = true;\n        if (typeof callback === 'function') {\n          callback();\n        }\n        return;\n      }\n      this[kStream].end(function () {\n        _this3.destroyed = true;\n        if (typeof callback === 'function') {\n          callback();\n        }\n      });\n    }\n  }, {\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      var readPreference = (0, shared_1.getReadPreference)(cmd, options);\n      var shouldUseOpMsg = supportsOpMsg(this);\n      var session = options === null || options === void 0 ? void 0 : options.session;\n      var clusterTime = this.clusterTime;\n      var finalCmd = Object.assign({}, cmd);\n      if (this.serverApi) {\n        var _this$serverApi = this.serverApi,\n          version = _this$serverApi.version,\n          strict = _this$serverApi.strict,\n          deprecationErrors = _this$serverApi.deprecationErrors;\n        finalCmd.apiVersion = version;\n        if (strict != null) finalCmd.apiStrict = strict;\n        if (deprecationErrors != null) finalCmd.apiDeprecationErrors = deprecationErrors;\n      }\n      if (hasSessionSupport(this) && session) {\n        if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n          clusterTime = session.clusterTime;\n        }\n        var err = (0, sessions_1.applySession)(session, finalCmd, options);\n        if (err) {\n          return callback(err);\n        }\n      }\n      // if we have a known cluster time, gossip it\n      if (clusterTime) {\n        finalCmd.$clusterTime = clusterTime;\n      }\n      if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n        finalCmd = {\n          $query: finalCmd,\n          $readPreference: readPreference.toJSON()\n        };\n      }\n      var commandOptions = Object.assign({\n        command: true,\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      }, options);\n      var cmdNs = \"\".concat(ns.db, \".$cmd\");\n      var message = shouldUseOpMsg ? new commands_1.Msg(cmdNs, finalCmd, commandOptions) : new commands_1.Query(cmdNs, finalCmd, commandOptions);\n      try {\n        write(this, message, commandOptions, callback);\n      } catch (err) {\n        callback(err);\n      }\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this[kDescription];\n    }\n  }, {\n    key: \"hello\",\n    get: function get() {\n      return this[kHello];\n    } // the `connect` method stores the result of the handshake hello on the connection\n    ,\n    set: function set(response) {\n      this[kDescription].receiveResponse(response);\n      this[kDescription] = Object.freeze(this[kDescription]);\n      // TODO: remove this, and only use the `StreamDescription` in the future\n      this[kHello] = response;\n    } // Set the whether the message stream is for a monitoring connection.\n  }, {\n    key: \"isMonitoringConnection\",\n    set: function set(value) {\n      this[kMessageStream].isMonitoringConnection = value;\n    },\n    get: function get() {\n      return this[kMessageStream].isMonitoringConnection;\n    }\n  }, {\n    key: \"serviceId\",\n    get: function get() {\n      var _a;\n      return (_a = this.hello) === null || _a === void 0 ? void 0 : _a.serviceId;\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.description.loadBalanced;\n    }\n  }, {\n    key: \"generation\",\n    get: function get() {\n      return this[kGeneration] || 0;\n    },\n    set: function set(generation) {\n      this[kGeneration] = generation;\n    }\n  }, {\n    key: \"idleTime\",\n    get: function get() {\n      return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this[kClusterTime];\n    }\n  }, {\n    key: \"stream\",\n    get: function get() {\n      return this[kStream];\n    }\n  }]);\n  return Connection;\n}(mongo_types_1.TypedEventEmitter);\nexports.Connection = Connection;\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\n/** @internal */\nvar CryptoConnection = /*#__PURE__*/function (_Connection) {\n  _inherits(CryptoConnection, _Connection);\n  function CryptoConnection(stream, options) {\n    var _this4;\n    _classCallCheck(this, CryptoConnection);\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(CryptoConnection).call(this, stream, options));\n    _this4[kAutoEncrypter] = options.autoEncrypter;\n    return _this4;\n  }\n  /** @internal @override */\n  _createClass(CryptoConnection, [{\n    key: \"command\",\n    value: function command(ns, cmd, options, callback) {\n      var _this5 = this;\n      var autoEncrypter = this[kAutoEncrypter];\n      if (!autoEncrypter) {\n        return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n      }\n      var serverWireVersion = (0, utils_1.maxWireVersion)(this);\n      if (serverWireVersion === 0) {\n        // This means the initial handshake hasn't happened yet\n        return _get(_getPrototypeOf(CryptoConnection.prototype), \"command\", this).call(this, ns, cmd, options, callback);\n      }\n      if (serverWireVersion < 8) {\n        callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n        return;\n      }\n      // Save sort or indexKeys based on the command being run\n      // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n      // and then deserializes the encrypted result, the protocol level components\n      // of the command (ex. sort) are then converted to JS objects potentially losing\n      // import key order information. These fields are never encrypted so we can save the values\n      // from before the encryption and replace them after encryption has been performed\n      var sort = cmd.find || cmd.findAndModify ? cmd.sort : null;\n      var indexKeys = cmd.createIndexes ? cmd.indexes.map(function (index) {\n        return index.key;\n      }) : null;\n      autoEncrypter.encrypt(ns.toString(), cmd, options, function (err, encrypted) {\n        if (err || encrypted == null) {\n          callback(err, null);\n          return;\n        }\n        // Replace the saved values\n        if (sort != null && (cmd.find || cmd.findAndModify)) {\n          encrypted.sort = sort;\n        }\n        if (indexKeys != null && cmd.createIndexes) {\n          var _iterator4 = _createForOfIteratorHelper(indexKeys.entries()),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _step4$value = _slicedToArray(_step4.value, 2),\n                offset = _step4$value[0],\n                index = _step4$value[1];\n              encrypted.indexes[offset].key = index;\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n        _get(_getPrototypeOf(CryptoConnection.prototype), \"command\", _this5).call(_this5, ns, encrypted, options, function (err, response) {\n          if (err || response == null) {\n            callback(err, response);\n            return;\n          }\n          autoEncrypter.decrypt(response, options, callback);\n        });\n      });\n    }\n  }]);\n  return CryptoConnection;\n}(Connection);\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n  var description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null || !!description.loadBalanced;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n  var description = conn.description;\n  if (description == null) {\n    return false;\n  }\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n  if (typeof stream.address === 'function') {\n    return \"\".concat(stream.remoteAddress, \":\").concat(stream.remotePort);\n  }\n  return (0, utils_1.uuidV4)().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n  options = options !== null && options !== void 0 ? options : {};\n  var operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    command: !!options.command,\n    // for BSON parsing\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n  if (typeof options.socketTimeoutMS === 'number') {\n    operationDescription.socketTimeoutOverride = true;\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  }\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n    operationDescription.cb = function (err, reply) {\n      if (err) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n      if (typeof callback === 'function') {\n        callback(err, reply);\n      }\n    };\n  }\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}