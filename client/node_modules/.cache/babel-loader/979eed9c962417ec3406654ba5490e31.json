{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatSort = void 0;\nvar error_1 = require(\"./error\");\n/** @internal */\nfunction prepareDirection() {\n  var direction = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  var value = \"\".concat(direction).toLowerCase();\n  if (isMeta(direction)) return direction;\n  switch (value) {\n    case 'ascending':\n    case 'asc':\n    case '1':\n      return 1;\n    case 'descending':\n    case 'desc':\n    case '-1':\n      return -1;\n    default:\n      throw new error_1.MongoInvalidArgumentError(\"Invalid sort direction: \".concat(JSON.stringify(direction)));\n  }\n}\n/** @internal */\nfunction isMeta(t) {\n  return typeof t === 'object' && t != null && '$meta' in t && typeof t.$meta === 'string';\n}\n/** @internal */\nfunction isPair(t) {\n  if (Array.isArray(t) && t.length === 2) {\n    try {\n      prepareDirection(t[1]);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\nfunction isDeep(t) {\n  return Array.isArray(t) && Array.isArray(t[0]);\n}\nfunction isMap(t) {\n  return t instanceof Map && t.size > 0;\n}\n/** @internal */\nfunction pairToMap(v) {\n  return new Map([[\"\".concat(v[0]), prepareDirection([v[1]])]]);\n}\n/** @internal */\nfunction deepToMap(t) {\n  var sortEntries = t.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n      k = _ref2[0],\n      v = _ref2[1];\n    return [\"\".concat(k), prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\nfunction stringsToMap(t) {\n  var sortEntries = t.map(function (key) {\n    return [\"\".concat(key), 1];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\nfunction objectToMap(t) {\n  var sortEntries = Object.entries(t).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      k = _ref4[0],\n      v = _ref4[1];\n    return [\"\".concat(k), prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** @internal */\nfunction mapToMap(t) {\n  var sortEntries = Array.from(t).map(function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 2),\n      k = _ref6[0],\n      v = _ref6[1];\n    return [\"\".concat(k), prepareDirection(v)];\n  });\n  return new Map(sortEntries);\n}\n/** converts a Sort type into a type that is valid for the server (SortForCmd) */\nfunction formatSort(sort, direction) {\n  if (sort == null) return undefined;\n  if (typeof sort === 'string') return new Map([[sort, prepareDirection(direction)]]);\n  if (typeof sort !== 'object') {\n    throw new error_1.MongoInvalidArgumentError(\"Invalid sort format: \".concat(JSON.stringify(sort), \" Sort must be a valid object\"));\n  }\n  if (!Array.isArray(sort)) {\n    return isMap(sort) ? mapToMap(sort) : Object.keys(sort).length ? objectToMap(sort) : undefined;\n  }\n  if (!sort.length) return undefined;\n  if (isDeep(sort)) return deepToMap(sort);\n  if (isPair(sort)) return pairToMap(sort);\n  return stringsToMap(sort);\n}\nexports.formatSort = formatSort;","map":null,"metadata":{},"sourceType":"script"}