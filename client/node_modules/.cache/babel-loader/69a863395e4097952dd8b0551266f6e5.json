{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ScramSHA256 = exports.ScramSHA1 = void 0;\nvar crypto = require(\"crypto\");\nvar bson_1 = require(\"../../bson\");\nvar deps_1 = require(\"../../deps\");\nvar error_1 = require(\"../../error\");\nvar utils_1 = require(\"../../utils\");\nvar auth_provider_1 = require(\"./auth_provider\");\nvar providers_1 = require(\"./providers\");\nvar ScramSHA = /*#__PURE__*/function (_auth_provider_1$Auth) {\n  _inherits(ScramSHA, _auth_provider_1$Auth);\n  function ScramSHA(cryptoMethod) {\n    var _this;\n    _classCallCheck(this, ScramSHA);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA).call(this));\n    _this.cryptoMethod = cryptoMethod || 'sha1';\n    return _this;\n  }\n  _createClass(ScramSHA, [{\n    key: \"prepare\",\n    value: function prepare(handshakeDoc, authContext, callback) {\n      var cryptoMethod = this.cryptoMethod;\n      var credentials = authContext.credentials;\n      if (!credentials) {\n        return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n      }\n      if (cryptoMethod === 'sha256' && deps_1.saslprep == null) {\n        (0, utils_1.emitWarning)('Warning: no saslprep library specified. Passwords will not be sanitized');\n      }\n      crypto.randomBytes(24, function (err, nonce) {\n        if (err) {\n          return callback(err);\n        }\n        // store the nonce for later use\n        Object.assign(authContext, {\n          nonce: nonce\n        });\n        var request = Object.assign({}, handshakeDoc, {\n          speculativeAuthenticate: Object.assign(makeFirstMessage(cryptoMethod, credentials, nonce), {\n            db: credentials.source\n          })\n        });\n        callback(undefined, request);\n      });\n    }\n  }, {\n    key: \"auth\",\n    value: function auth(authContext, callback) {\n      var response = authContext.response;\n      if (response && response.speculativeAuthenticate) {\n        continueScramConversation(this.cryptoMethod, response.speculativeAuthenticate, authContext, callback);\n        return;\n      }\n      executeScram(this.cryptoMethod, authContext, callback);\n    }\n  }]);\n  return ScramSHA;\n}(auth_provider_1.AuthProvider);\nfunction cleanUsername(username) {\n  return username.replace('=', '=3D').replace(',', '=2C');\n}\nfunction clientFirstMessageBare(username, nonce) {\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return Buffer.concat([Buffer.from('n=', 'utf8'), Buffer.from(username, 'utf8'), Buffer.from(',r=', 'utf8'), Buffer.from(nonce.toString('base64'), 'utf8')]);\n}\nfunction makeFirstMessage(cryptoMethod, credentials, nonce) {\n  var username = cleanUsername(credentials.username);\n  var mechanism = cryptoMethod === 'sha1' ? providers_1.AuthMechanism.MONGODB_SCRAM_SHA1 : providers_1.AuthMechanism.MONGODB_SCRAM_SHA256;\n  // NOTE: This is done b/c Javascript uses UTF-16, but the server is hashing in UTF-8.\n  // Since the username is not sasl-prep-d, we need to do this here.\n  return {\n    saslStart: 1,\n    mechanism: mechanism,\n    payload: new bson_1.Binary(Buffer.concat([Buffer.from('n,,', 'utf8'), clientFirstMessageBare(username, nonce)])),\n    autoAuthorize: 1,\n    options: {\n      skipEmptyExchange: true\n    }\n  };\n}\nfunction executeScram(cryptoMethod, authContext, callback) {\n  var connection = authContext.connection,\n    credentials = authContext.credentials;\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('AuthContext must contain a valid nonce property'));\n  }\n  var nonce = authContext.nonce;\n  var db = credentials.source;\n  var saslStartCmd = makeFirstMessage(cryptoMethod, credentials, nonce);\n  connection.command((0, utils_1.ns)(\"\".concat(db, \".$cmd\")), saslStartCmd, undefined, function (_err, result) {\n    var err = resolveError(_err, result);\n    if (err) {\n      return callback(err);\n    }\n    continueScramConversation(cryptoMethod, result, authContext, callback);\n  });\n}\nfunction continueScramConversation(cryptoMethod, response, authContext, callback) {\n  var connection = authContext.connection;\n  var credentials = authContext.credentials;\n  if (!credentials) {\n    return callback(new error_1.MongoMissingCredentialsError('AuthContext must provide credentials.'));\n  }\n  if (!authContext.nonce) {\n    return callback(new error_1.MongoInvalidArgumentError('Unable to continue SCRAM without valid nonce'));\n  }\n  var nonce = authContext.nonce;\n  var db = credentials.source;\n  var username = cleanUsername(credentials.username);\n  var password = credentials.password;\n  var processedPassword;\n  if (cryptoMethod === 'sha256') {\n    processedPassword = 'kModuleError' in deps_1.saslprep ? password : (0, deps_1.saslprep)(password);\n  } else {\n    try {\n      processedPassword = passwordDigest(username, password);\n    } catch (e) {\n      return callback(e);\n    }\n  }\n  var payload = Buffer.isBuffer(response.payload) ? new bson_1.Binary(response.payload) : response.payload;\n  var dict = parsePayload(payload.value());\n  var iterations = parseInt(dict.i, 10);\n  if (iterations && iterations < 4096) {\n    callback(\n    // TODO(NODE-3483)\n    new error_1.MongoRuntimeError(\"Server returned an invalid iteration count \".concat(iterations)), false);\n    return;\n  }\n  var salt = dict.s;\n  var rnonce = dict.r;\n  if (rnonce.startsWith('nonce')) {\n    // TODO(NODE-3483)\n    callback(new error_1.MongoRuntimeError(\"Server returned an invalid nonce: \".concat(rnonce)), false);\n    return;\n  }\n  // Set up start of proof\n  var withoutProof = \"c=biws,r=\".concat(rnonce);\n  var saltedPassword = HI(processedPassword, Buffer.from(salt, 'base64'), iterations, cryptoMethod);\n  var clientKey = HMAC(cryptoMethod, saltedPassword, 'Client Key');\n  var serverKey = HMAC(cryptoMethod, saltedPassword, 'Server Key');\n  var storedKey = H(cryptoMethod, clientKey);\n  var authMessage = [clientFirstMessageBare(username, nonce), payload.value(), withoutProof].join(',');\n  var clientSignature = HMAC(cryptoMethod, storedKey, authMessage);\n  var clientProof = \"p=\".concat(xor(clientKey, clientSignature));\n  var clientFinal = [withoutProof, clientProof].join(',');\n  var serverSignature = HMAC(cryptoMethod, serverKey, authMessage);\n  var saslContinueCmd = {\n    saslContinue: 1,\n    conversationId: response.conversationId,\n    payload: new bson_1.Binary(Buffer.from(clientFinal))\n  };\n  connection.command((0, utils_1.ns)(\"\".concat(db, \".$cmd\")), saslContinueCmd, undefined, function (_err, r) {\n    var err = resolveError(_err, r);\n    if (err) {\n      return callback(err);\n    }\n    var parsedResponse = parsePayload(r.payload.value());\n    if (!compareDigest(Buffer.from(parsedResponse.v, 'base64'), serverSignature)) {\n      callback(new error_1.MongoRuntimeError('Server returned an invalid signature'));\n      return;\n    }\n    if (!r || r.done !== false) {\n      return callback(err, r);\n    }\n    var retrySaslContinueCmd = {\n      saslContinue: 1,\n      conversationId: r.conversationId,\n      payload: Buffer.alloc(0)\n    };\n    connection.command((0, utils_1.ns)(\"\".concat(db, \".$cmd\")), retrySaslContinueCmd, undefined, callback);\n  });\n}\nfunction parsePayload(payload) {\n  var dict = {};\n  var parts = payload.split(',');\n  for (var i = 0; i < parts.length; i++) {\n    var valueParts = parts[i].split('=');\n    dict[valueParts[0]] = valueParts[1];\n  }\n  return dict;\n}\nfunction passwordDigest(username, password) {\n  if (typeof username !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Username must be a string');\n  }\n  if (typeof password !== 'string') {\n    throw new error_1.MongoInvalidArgumentError('Password must be a string');\n  }\n  if (password.length === 0) {\n    throw new error_1.MongoInvalidArgumentError('Password cannot be empty');\n  }\n  var md5;\n  try {\n    md5 = crypto.createHash('md5');\n  } catch (err) {\n    if (crypto.getFips()) {\n      // This error is (slightly) more helpful than what comes from OpenSSL directly, e.g.\n      // 'Error: error:060800C8:digital envelope routines:EVP_DigestInit_ex:disabled for FIPS'\n      throw new Error('Auth mechanism SCRAM-SHA-1 is not supported in FIPS mode');\n    }\n    throw err;\n  }\n  md5.update(\"\".concat(username, \":mongo:\").concat(password), 'utf8');\n  return md5.digest('hex');\n}\n// XOR two buffers\nfunction xor(a, b) {\n  if (!Buffer.isBuffer(a)) {\n    a = Buffer.from(a);\n  }\n  if (!Buffer.isBuffer(b)) {\n    b = Buffer.from(b);\n  }\n  var length = Math.max(a.length, b.length);\n  var res = [];\n  for (var i = 0; i < length; i += 1) {\n    res.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(res).toString('base64');\n}\nfunction H(method, text) {\n  return crypto.createHash(method).update(text).digest();\n}\nfunction HMAC(method, key, text) {\n  return crypto.createHmac(method, key).update(text).digest();\n}\nvar _hiCache = {};\nvar _hiCacheCount = 0;\nfunction _hiCachePurge() {\n  _hiCache = {};\n  _hiCacheCount = 0;\n}\nvar hiLengthMap = {\n  sha256: 32,\n  sha1: 20\n};\nfunction HI(data, salt, iterations, cryptoMethod) {\n  // omit the work if already generated\n  var key = [data, salt.toString('base64'), iterations].join('_');\n  if (_hiCache[key] != null) {\n    return _hiCache[key];\n  }\n  // generate the salt\n  var saltedData = crypto.pbkdf2Sync(data, salt, iterations, hiLengthMap[cryptoMethod], cryptoMethod);\n  // cache a copy to speed up the next lookup, but prevent unbounded cache growth\n  if (_hiCacheCount >= 200) {\n    _hiCachePurge();\n  }\n  _hiCache[key] = saltedData;\n  _hiCacheCount += 1;\n  return saltedData;\n}\nfunction compareDigest(lhs, rhs) {\n  if (lhs.length !== rhs.length) {\n    return false;\n  }\n  if (typeof crypto.timingSafeEqual === 'function') {\n    return crypto.timingSafeEqual(lhs, rhs);\n  }\n  var result = 0;\n  for (var i = 0; i < lhs.length; i++) {\n    result |= lhs[i] ^ rhs[i];\n  }\n  return result === 0;\n}\nfunction resolveError(err, result) {\n  if (err) return err;\n  if (result) {\n    if (result.$err || result.errmsg) return new error_1.MongoServerError(result);\n  }\n  return;\n}\nvar ScramSHA1 = /*#__PURE__*/function (_ScramSHA) {\n  _inherits(ScramSHA1, _ScramSHA);\n  function ScramSHA1() {\n    _classCallCheck(this, ScramSHA1);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA1).call(this, 'sha1'));\n  }\n  return ScramSHA1;\n}(ScramSHA);\nexports.ScramSHA1 = ScramSHA1;\nvar ScramSHA256 = /*#__PURE__*/function (_ScramSHA2) {\n  _inherits(ScramSHA256, _ScramSHA2);\n  function ScramSHA256() {\n    _classCallCheck(this, ScramSHA256);\n    return _possibleConstructorReturn(this, _getPrototypeOf(ScramSHA256).call(this, 'sha256'));\n  }\n  return ScramSHA256;\n}(ScramSHA);\nexports.ScramSHA256 = ScramSHA256;","map":null,"metadata":{},"sourceType":"script"}