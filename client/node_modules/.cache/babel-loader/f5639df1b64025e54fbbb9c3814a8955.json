{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decompress = exports.compress = exports.uncompressibleCommands = exports.Compressor = void 0;\nvar zlib = require(\"zlib\");\nvar constants_1 = require(\"../../constants\");\nvar deps_1 = require(\"../../deps\");\nvar error_1 = require(\"../../error\");\n/** @public */\nexports.Compressor = Object.freeze({\n  none: 0,\n  snappy: 1,\n  zlib: 2,\n  zstd: 3\n});\nexports.uncompressibleCommands = new Set([constants_1.LEGACY_HELLO_COMMAND, 'saslStart', 'saslContinue', 'getnonce', 'authenticate', 'createUser', 'updateUser', 'copydbSaslStart', 'copydbgetnonce', 'copydb']);\nvar MAX_COMPRESSOR_ID = 3;\nvar ZSTD_COMPRESSION_LEVEL = 3;\n// Facilitate compressing a message using an agreed compressor\nfunction compress(self, dataToBeCompressed, callback) {\n  var zlibOptions = {};\n  switch (self.options.agreedCompressor) {\n    case 'snappy':\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.compress(dataToBeCompressed, callback);\n        } else {\n          deps_1.Snappy.compress(dataToBeCompressed).then(function (buffer) {\n            return callback(undefined, buffer);\n          }, function (error) {\n            return callback(error);\n          });\n        }\n        break;\n      }\n    case 'zlib':\n      // Determine zlibCompressionLevel\n      if (self.options.zlibCompressionLevel) {\n        zlibOptions.level = self.options.zlibCompressionLevel;\n      }\n      zlib.deflate(dataToBeCompressed, zlibOptions, callback);\n      break;\n    case 'zstd':\n      if ('kModuleError' in deps_1.ZStandard) {\n        return callback(deps_1.ZStandard['kModuleError']);\n      }\n      deps_1.ZStandard.compress(dataToBeCompressed, ZSTD_COMPRESSION_LEVEL).then(function (buffer) {\n        return callback(undefined, buffer);\n      }, function (error) {\n        return callback(error);\n      });\n      break;\n    default:\n      throw new error_1.MongoInvalidArgumentError(\"Unknown compressor \".concat(self.options.agreedCompressor, \" failed to compress\"));\n  }\n}\nexports.compress = compress;\n// Decompress a message using the given compressor\nfunction decompress(compressorID, compressedData, callback) {\n  if (compressorID < 0 || compressorID > MAX_COMPRESSOR_ID) {\n    throw new error_1.MongoDecompressionError(\"Server sent message compressed using an unsupported compressor. (Received compressor ID \".concat(compressorID, \")\"));\n  }\n  switch (compressorID) {\n    case exports.Compressor.snappy:\n      {\n        if ('kModuleError' in deps_1.Snappy) {\n          return callback(deps_1.Snappy['kModuleError']);\n        }\n        if (deps_1.Snappy[deps_1.PKG_VERSION].major <= 6) {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }, callback);\n        } else {\n          deps_1.Snappy.uncompress(compressedData, {\n            asBuffer: true\n          }).then(function (buffer) {\n            return callback(undefined, buffer);\n          }, function (error) {\n            return callback(error);\n          });\n        }\n        break;\n      }\n    case exports.Compressor.zstd:\n      {\n        if ('kModuleError' in deps_1.ZStandard) {\n          return callback(deps_1.ZStandard['kModuleError']);\n        }\n        deps_1.ZStandard.decompress(compressedData).then(function (buffer) {\n          return callback(undefined, buffer);\n        }, function (error) {\n          return callback(error);\n        });\n        break;\n      }\n    case exports.Compressor.zlib:\n      zlib.inflate(compressedData, callback);\n      break;\n    default:\n      callback(undefined, compressedData);\n  }\n}\nexports.decompress = decompress;","map":null,"metadata":{},"sourceType":"script"}