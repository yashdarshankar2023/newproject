{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AggregationCursor = void 0;\nvar aggregate_1 = require(\"../operations/aggregate\");\nvar execute_operation_1 = require(\"../operations/execute_operation\");\nvar utils_1 = require(\"../utils\");\nvar abstract_cursor_1 = require(\"./abstract_cursor\");\n/** @internal */\nvar kPipeline = Symbol('pipeline');\n/** @internal */\nvar kOptions = Symbol('options');\n/**\n * The **AggregationCursor** class is an internal class that embodies an aggregation cursor on MongoDB\n * allowing for iteration over the results returned from the underlying query. It supports\n * one by one document iteration, conversion to an array or can be iterated as a Node 4.X\n * or higher stream\n * @public\n */\nvar AggregationCursor = /*#__PURE__*/function (_abstract_cursor_1$Ab) {\n  _inherits(AggregationCursor, _abstract_cursor_1$Ab);\n  /** @internal */\n  function AggregationCursor(client, namespace) {\n    var _this;\n    var pipeline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    _classCallCheck(this, AggregationCursor);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AggregationCursor).call(this, client, namespace, options));\n    _this[kPipeline] = pipeline;\n    _this[kOptions] = options;\n    return _this;\n  }\n  _createClass(AggregationCursor, [{\n    key: \"clone\",\n    value: function clone() {\n      var clonedOptions = (0, utils_1.mergeOptions)({}, this[kOptions]);\n      delete clonedOptions.session;\n      return new AggregationCursor(this.client, this.namespace, this[kPipeline], _objectSpread({}, clonedOptions));\n    }\n  }, {\n    key: \"map\",\n    value: function map(transform) {\n      return _get(_getPrototypeOf(AggregationCursor.prototype), \"map\", this).call(this, transform);\n    } /** @internal */\n  }, {\n    key: \"_initialize\",\n    value: function _initialize(session, callback) {\n      var aggregateOperation = new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], _objectSpread({}, this[kOptions], this.cursorOptions, {\n        session: session\n      }));\n      (0, execute_operation_1.executeOperation)(this.client, aggregateOperation, function (err, response) {\n        if (err || response == null) return callback(err);\n        // TODO: NODE-2882\n        callback(undefined, {\n          server: aggregateOperation.server,\n          session: session,\n          response: response\n        });\n      });\n    }\n  }, {\n    key: \"explain\",\n    value: function explain(verbosity, callback) {\n      if (typeof verbosity === 'function') callback = verbosity, verbosity = true;\n      if (verbosity == null) verbosity = true;\n      return (0, execute_operation_1.executeOperation)(this.client, new aggregate_1.AggregateOperation(this.namespace, this[kPipeline], _objectSpread({}, this[kOptions], this.cursorOptions, {\n        explain: verbosity\n      })), callback);\n    }\n  }, {\n    key: \"group\",\n    value: function group($group) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $group: $group\n      });\n      return this;\n    } /** Add a limit stage to the aggregation pipeline */\n  }, {\n    key: \"limit\",\n    value: function limit($limit) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $limit: $limit\n      });\n      return this;\n    } /** Add a match stage to the aggregation pipeline */\n  }, {\n    key: \"match\",\n    value: function match($match) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $match: $match\n      });\n      return this;\n    } /** Add an out stage to the aggregation pipeline */\n  }, {\n    key: \"out\",\n    value: function out($out) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $out: $out\n      });\n      return this;\n    }\n    /**\n     * Add a project stage to the aggregation pipeline\n     *\n     * @remarks\n     * In order to strictly type this function you must provide an interface\n     * that represents the effect of your projection on the result documents.\n     *\n     * By default chaining a projection to your cursor changes the returned type to the generic {@link Document} type.\n     * You should specify a parameterized type to have assertions on your final results.\n     *\n     * @example\n     * ```typescript\n     * // Best way\n     * const docs: AggregationCursor<{ a: number }> = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * // Flexible way\n     * const docs: AggregationCursor<Document> = cursor.project({ _id: 0, a: true });\n     * ```\n     *\n     * @remarks\n     * In order to strictly type this function you must provide an interface\n     * that represents the effect of your projection on the result documents.\n     *\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling project,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: AggregationCursor<{ a: number; b: string }> = coll.aggregate([]);\n     * const projectCursor = cursor.project<{ a: number }>({ _id: 0, a: true });\n     * const aPropOnlyArray: {a: number}[] = await projectCursor.toArray();\n     *\n     * // or always use chaining and save the final cursor\n     *\n     * const cursor = coll.aggregate().project<{ a: string }>({\n     *   _id: 0,\n     *   a: { $convert: { input: '$a', to: 'string' }\n     * }});\n     * ```\n     */\n  }, {\n    key: \"project\",\n    value: function project($project) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $project: $project\n      });\n      return this;\n    } /** Add a lookup stage to the aggregation pipeline */\n  }, {\n    key: \"lookup\",\n    value: function lookup($lookup) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $lookup: $lookup\n      });\n      return this;\n    } /** Add a redact stage to the aggregation pipeline */\n  }, {\n    key: \"redact\",\n    value: function redact($redact) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $redact: $redact\n      });\n      return this;\n    } /** Add a skip stage to the aggregation pipeline */\n  }, {\n    key: \"skip\",\n    value: function skip($skip) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $skip: $skip\n      });\n      return this;\n    } /** Add a sort stage to the aggregation pipeline */\n  }, {\n    key: \"sort\",\n    value: function sort($sort) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $sort: $sort\n      });\n      return this;\n    } /** Add a unwind stage to the aggregation pipeline */\n  }, {\n    key: \"unwind\",\n    value: function unwind($unwind) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $unwind: $unwind\n      });\n      return this;\n    } // deprecated methods\n    /** @deprecated Add a geoNear stage to the aggregation pipeline */\n  }, {\n    key: \"geoNear\",\n    value: function geoNear($geoNear) {\n      (0, abstract_cursor_1.assertUninitialized)(this);\n      this[kPipeline].push({\n        $geoNear: $geoNear\n      });\n      return this;\n    }\n  }, {\n    key: \"pipeline\",\n    get: function get() {\n      return this[kPipeline];\n    }\n  }]);\n  return AggregationCursor;\n}(abstract_cursor_1.AbstractCursor);\nexports.AggregationCursor = AggregationCursor;","map":null,"metadata":{},"sourceType":"script"}