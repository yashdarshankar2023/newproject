{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeUpdateStatement = exports.ReplaceOneOperation = exports.UpdateManyOperation = exports.UpdateOneOperation = exports.UpdateOperation = void 0;\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nvar command_1 = require(\"./command\");\nvar operation_1 = require(\"./operation\");\n/** @internal */\nvar UpdateOperation = /*#__PURE__*/function (_command_1$CommandOpe) {\n  _inherits(UpdateOperation, _command_1$CommandOpe);\n  function UpdateOperation(ns, statements, options) {\n    var _this;\n    _classCallCheck(this, UpdateOperation);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(UpdateOperation).call(this, undefined, options));\n    _this.options = options;\n    _this.ns = ns;\n    _this.statements = statements;\n    return _this;\n  }\n  _createClass(UpdateOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _a;\n      var options = (_a = this.options) !== null && _a !== void 0 ? _a : {};\n      var ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n      var command = {\n        update: this.ns.collection,\n        updates: this.statements,\n        ordered: ordered\n      };\n      if (typeof options.bypassDocumentValidation === 'boolean') {\n        command.bypassDocumentValidation = options.bypassDocumentValidation;\n      }\n      if (options.let) {\n        command.let = options.let;\n      }\n      // we check for undefined specifically here to allow falsy values\n      // eslint-disable-next-line no-restricted-syntax\n      if (options.comment !== undefined) {\n        command.comment = options.comment;\n      }\n      var statementWithCollation = this.statements.find(function (statement) {\n        return !!statement.collation;\n      });\n      if ((0, utils_1.collationNotSupported)(server, options) || statementWithCollation && (0, utils_1.collationNotSupported)(server, statementWithCollation)) {\n        callback(new error_1.MongoCompatibilityError(\"Server \".concat(server.name, \" does not support collation\")));\n        return;\n      }\n      var unacknowledgedWrite = this.writeConcern && this.writeConcern.w === 0;\n      if (unacknowledgedWrite || (0, utils_1.maxWireVersion)(server) < 5) {\n        if (this.statements.find(function (o) {\n          return o.hint;\n        })) {\n          callback(new error_1.MongoCompatibilityError(\"Servers < 3.4 do not support hint on update\"));\n          return;\n        }\n      }\n      if (this.explain && (0, utils_1.maxWireVersion)(server) < 3) {\n        callback(new error_1.MongoCompatibilityError(\"Server \".concat(server.name, \" does not support explain on update\")));\n        return;\n      }\n      if (this.statements.some(function (statement) {\n        return !!statement.arrayFilters;\n      }) && (0, utils_1.maxWireVersion)(server) < 6) {\n        callback(new error_1.MongoCompatibilityError('Option \"arrayFilters\" is only supported on MongoDB 3.6+'));\n        return;\n      }\n      _get(_getPrototypeOf(UpdateOperation.prototype), \"executeCommand\", this).call(this, server, session, command, callback);\n    }\n  }, {\n    key: \"canRetryWrite\",\n    get: function get() {\n      if (_get(_getPrototypeOf(UpdateOperation.prototype), \"canRetryWrite\", this) === false) {\n        return false;\n      }\n      return this.statements.every(function (op) {\n        return op.multi == null || op.multi === false;\n      });\n    }\n  }]);\n  return UpdateOperation;\n}(command_1.CommandOperation);\nexports.UpdateOperation = UpdateOperation;\n/** @internal */\nvar UpdateOneOperation = /*#__PURE__*/function (_UpdateOperation) {\n  _inherits(UpdateOneOperation, _UpdateOperation);\n  function UpdateOneOperation(collection, filter, update, options) {\n    var _this2;\n    _classCallCheck(this, UpdateOneOperation);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(UpdateOneOperation).call(this, collection.s.namespace, [makeUpdateStatement(filter, update, _objectSpread({}, options, {\n      multi: false\n    }))], options));\n    if (!(0, utils_1.hasAtomicOperators)(update)) {\n      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n    return _this2;\n  }\n  _createClass(UpdateOneOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this3 = this;\n      _get(_getPrototypeOf(UpdateOneOperation.prototype), \"execute\", this).call(this, server, session, function (err, res) {\n        var _a, _b;\n        if (err || !res) return callback(err);\n        if (_this3.explain != null) return callback(undefined, res);\n        if (res.code) return callback(new error_1.MongoServerError(res));\n        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));\n        callback(undefined, {\n          acknowledged: (_b = ((_a = _this3.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n          modifiedCount: res.nModified != null ? res.nModified : res.n,\n          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,\n          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,\n          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n\n        });\n      });\n    }\n  }]);\n  return UpdateOneOperation;\n}(UpdateOperation);\nexports.UpdateOneOperation = UpdateOneOperation;\n/** @internal */\nvar UpdateManyOperation = /*#__PURE__*/function (_UpdateOperation2) {\n  _inherits(UpdateManyOperation, _UpdateOperation2);\n  function UpdateManyOperation(collection, filter, update, options) {\n    var _this4;\n    _classCallCheck(this, UpdateManyOperation);\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(UpdateManyOperation).call(this, collection.s.namespace, [makeUpdateStatement(filter, update, _objectSpread({}, options, {\n      multi: true\n    }))], options));\n    if (!(0, utils_1.hasAtomicOperators)(update)) {\n      throw new error_1.MongoInvalidArgumentError('Update document requires atomic operators');\n    }\n    return _this4;\n  }\n  _createClass(UpdateManyOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this5 = this;\n      _get(_getPrototypeOf(UpdateManyOperation.prototype), \"execute\", this).call(this, server, session, function (err, res) {\n        var _a, _b;\n        if (err || !res) return callback(err);\n        if (_this5.explain != null) return callback(undefined, res);\n        if (res.code) return callback(new error_1.MongoServerError(res));\n        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));\n        callback(undefined, {\n          acknowledged: (_b = ((_a = _this5.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n          modifiedCount: res.nModified != null ? res.nModified : res.n,\n          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,\n          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,\n          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n\n        });\n      });\n    }\n  }]);\n  return UpdateManyOperation;\n}(UpdateOperation);\nexports.UpdateManyOperation = UpdateManyOperation;\n/** @internal */\nvar ReplaceOneOperation = /*#__PURE__*/function (_UpdateOperation3) {\n  _inherits(ReplaceOneOperation, _UpdateOperation3);\n  function ReplaceOneOperation(collection, filter, replacement, options) {\n    var _this6;\n    _classCallCheck(this, ReplaceOneOperation);\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(ReplaceOneOperation).call(this, collection.s.namespace, [makeUpdateStatement(filter, replacement, _objectSpread({}, options, {\n      multi: false\n    }))], options));\n    if ((0, utils_1.hasAtomicOperators)(replacement)) {\n      throw new error_1.MongoInvalidArgumentError('Replacement document must not contain atomic operators');\n    }\n    return _this6;\n  }\n  _createClass(ReplaceOneOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this7 = this;\n      _get(_getPrototypeOf(ReplaceOneOperation.prototype), \"execute\", this).call(this, server, session, function (err, res) {\n        var _a, _b;\n        if (err || !res) return callback(err);\n        if (_this7.explain != null) return callback(undefined, res);\n        if (res.code) return callback(new error_1.MongoServerError(res));\n        if (res.writeErrors) return callback(new error_1.MongoServerError(res.writeErrors[0]));\n        callback(undefined, {\n          acknowledged: (_b = ((_a = _this7.writeConcern) === null || _a === void 0 ? void 0 : _a.w) !== 0) !== null && _b !== void 0 ? _b : true,\n          modifiedCount: res.nModified != null ? res.nModified : res.n,\n          upsertedId: Array.isArray(res.upserted) && res.upserted.length > 0 ? res.upserted[0]._id : null,\n          upsertedCount: Array.isArray(res.upserted) && res.upserted.length ? res.upserted.length : 0,\n          matchedCount: Array.isArray(res.upserted) && res.upserted.length > 0 ? 0 : res.n\n        });\n      });\n    }\n  }]);\n  return ReplaceOneOperation;\n}(UpdateOperation);\nexports.ReplaceOneOperation = ReplaceOneOperation;\nfunction makeUpdateStatement(filter, update, options) {\n  if (filter == null || typeof filter !== 'object') {\n    throw new error_1.MongoInvalidArgumentError('Selector must be a valid JavaScript object');\n  }\n  if (update == null || typeof update !== 'object') {\n    throw new error_1.MongoInvalidArgumentError('Document must be a valid JavaScript object');\n  }\n  var op = {\n    q: filter,\n    u: update\n  };\n  if (typeof options.upsert === 'boolean') {\n    op.upsert = options.upsert;\n  }\n  if (options.multi) {\n    op.multi = options.multi;\n  }\n  if (options.hint) {\n    op.hint = options.hint;\n  }\n  if (options.arrayFilters) {\n    op.arrayFilters = options.arrayFilters;\n  }\n  if (options.collation) {\n    op.collation = options.collation;\n  }\n  return op;\n}\nexports.makeUpdateStatement = makeUpdateStatement;\n(0, operation_1.defineAspects)(UpdateOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);\n(0, operation_1.defineAspects)(UpdateOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);\n(0, operation_1.defineAspects)(UpdateManyOperation, [operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.EXPLAINABLE, operation_1.Aspect.SKIP_COLLATION]);\n(0, operation_1.defineAspects)(ReplaceOneOperation, [operation_1.Aspect.RETRYABLE, operation_1.Aspect.WRITE_OPERATION, operation_1.Aspect.SKIP_COLLATION]);","map":null,"metadata":{},"sourceType":"script"}