{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.assertUninitialized = exports.next = exports.AbstractCursor = exports.CURSOR_FLAGS = void 0;\nvar stream_1 = require(\"stream\");\nvar bson_1 = require(\"../bson\");\nvar error_1 = require(\"../error\");\nvar mongo_types_1 = require(\"../mongo_types\");\nvar execute_operation_1 = require(\"../operations/execute_operation\");\nvar get_more_1 = require(\"../operations/get_more\");\nvar kill_cursors_1 = require(\"../operations/kill_cursors\");\nvar read_concern_1 = require(\"../read_concern\");\nvar read_preference_1 = require(\"../read_preference\");\nvar sessions_1 = require(\"../sessions\");\nvar utils_1 = require(\"../utils\");\n/** @internal */\nvar kId = Symbol('id');\n/** @internal */\nvar kDocuments = Symbol('documents');\n/** @internal */\nvar kServer = Symbol('server');\n/** @internal */\nvar kNamespace = Symbol('namespace');\n/** @internal */\nvar kClient = Symbol('client');\n/** @internal */\nvar kSession = Symbol('session');\n/** @internal */\nvar kOptions = Symbol('options');\n/** @internal */\nvar kTransform = Symbol('transform');\n/** @internal */\nvar kInitialized = Symbol('initialized');\n/** @internal */\nvar kClosed = Symbol('closed');\n/** @internal */\nvar kKilled = Symbol('killed');\n/** @internal */\nvar kInit = Symbol('kInit');\n/** @public */\nexports.CURSOR_FLAGS = ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'exhaust', 'partial'];\n/** @public */\nvar AbstractCursor = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(AbstractCursor, _mongo_types_1$TypedE);\n  /** @internal */\n  function AbstractCursor(client, namespace) {\n    var _this;\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, AbstractCursor);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(AbstractCursor).call(this));\n    if (!client.s.isMongoClient) {\n      throw new error_1.MongoRuntimeError('Cursor must be constructed with MongoClient');\n    }\n    _this[kClient] = client;\n    _this[kNamespace] = namespace;\n    _this[kDocuments] = [];\n    _this[kInitialized] = false;\n    _this[kClosed] = false;\n    _this[kKilled] = false;\n    _this[kOptions] = _objectSpread({\n      readPreference: options.readPreference && options.readPreference instanceof read_preference_1.ReadPreference ? options.readPreference : read_preference_1.ReadPreference.primary\n    }, (0, bson_1.pluckBSONSerializeOptions)(options));\n    var readConcern = read_concern_1.ReadConcern.fromOptions(options);\n    if (readConcern) {\n      _this[kOptions].readConcern = readConcern;\n    }\n    if (typeof options.batchSize === 'number') {\n      _this[kOptions].batchSize = options.batchSize;\n    }\n    // we check for undefined specifically here to allow falsy values\n    // eslint-disable-next-line no-restricted-syntax\n    if (options.comment !== undefined) {\n      _this[kOptions].comment = options.comment;\n    }\n    if (typeof options.maxTimeMS === 'number') {\n      _this[kOptions].maxTimeMS = options.maxTimeMS;\n    }\n    if (typeof options.maxAwaitTimeMS === 'number') {\n      _this[kOptions].maxAwaitTimeMS = options.maxAwaitTimeMS;\n    }\n    if (options.session instanceof sessions_1.ClientSession) {\n      _this[kSession] = options.session;\n    } else {\n      _this[kSession] = _this[kClient].startSession({\n        owner: _assertThisInitialized(_assertThisInitialized(_this)),\n        explicit: false\n      });\n    }\n    return _this;\n  }\n  _createClass(AbstractCursor, [{\n    key: \"bufferedCount\",\n    /** Returns current buffered documents length */value: function bufferedCount() {\n      return this[kDocuments].length;\n    } /** Returns current buffered documents */\n  }, {\n    key: \"readBufferedDocuments\",\n    value: function readBufferedDocuments(number) {\n      return this[kDocuments].splice(0, number !== null && number !== void 0 ? number : this[kDocuments].length);\n    }\n  }, {\n    key: Symbol.asyncIterator,\n    value: function value() {\n      var _this2 = this;\n      return {\n        next: function next() {\n          return _this2.next().then(function (value) {\n            return value != null ? {\n              value: value,\n              done: false\n            } : {\n              value: undefined,\n              done: true\n            };\n          });\n        }\n      };\n    }\n  }, {\n    key: \"stream\",\n    value: function stream(options) {\n      if (options === null || options === void 0 ? void 0 : options.transform) {\n        var _transform = options.transform;\n        var readable = new ReadableCursorStream(this);\n        return readable.pipe(new stream_1.Transform({\n          objectMode: true,\n          highWaterMark: 1,\n          transform: function transform(chunk, _, callback) {\n            try {\n              var transformed = _transform(chunk);\n              callback(undefined, transformed);\n            } catch (err) {\n              callback(err);\n            }\n          }\n        }));\n      }\n      return new ReadableCursorStream(this);\n    }\n  }, {\n    key: \"hasNext\",\n    value: function hasNext(callback) {\n      var _this3 = this;\n      return (0, utils_1.maybePromise)(callback, function (done) {\n        if (_this3[kId] === bson_1.Long.ZERO) {\n          return done(undefined, false);\n        }\n        if (_this3[kDocuments].length) {\n          return done(undefined, true);\n        }\n        _next(_this3, true, function (err, doc) {\n          if (err) return done(err);\n          if (doc) {\n            _this3[kDocuments].unshift(doc);\n            done(undefined, true);\n            return;\n          }\n          done(undefined, false);\n        });\n      });\n    }\n  }, {\n    key: \"next\",\n    value: function next(callback) {\n      var _this4 = this;\n      return (0, utils_1.maybePromise)(callback, function (done) {\n        if (_this4[kId] === bson_1.Long.ZERO) {\n          return done(new error_1.MongoCursorExhaustedError());\n        }\n        _next(_this4, true, done);\n      });\n    }\n  }, {\n    key: \"tryNext\",\n    value: function tryNext(callback) {\n      var _this5 = this;\n      return (0, utils_1.maybePromise)(callback, function (done) {\n        if (_this5[kId] === bson_1.Long.ZERO) {\n          return done(new error_1.MongoCursorExhaustedError());\n        }\n        _next(_this5, false, done);\n      });\n    }\n  }, {\n    key: \"forEach\",\n    value: function forEach(iterator, callback) {\n      var _this6 = this;\n      if (typeof iterator !== 'function') {\n        throw new error_1.MongoInvalidArgumentError('Argument \"iterator\" must be a function');\n      }\n      return (0, utils_1.maybePromise)(callback, function (done) {\n        var transform = _this6[kTransform];\n        var fetchDocs = function fetchDocs() {\n          _next(_this6, true, function (err, doc) {\n            if (err || doc == null) return done(err);\n            var result;\n            // NOTE: no need to transform because `next` will do this automatically\n            try {\n              result = iterator(doc); // TODO(NODE-3283): Improve transform typing\n            } catch (error) {\n              return done(error);\n            }\n            if (result === false) return done();\n            // these do need to be transformed since they are copying the rest of the batch\n            var internalDocs = _this6[kDocuments].splice(0, _this6[kDocuments].length);\n            for (var i = 0; i < internalDocs.length; ++i) {\n              try {\n                result = iterator(transform ? transform(internalDocs[i]) : internalDocs[i] // TODO(NODE-3283): Improve transform typing\n                );\n              } catch (error) {\n                return done(error);\n              }\n              if (result === false) return done();\n            }\n            fetchDocs();\n          });\n        };\n        fetchDocs();\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(options, callback) {\n      var _this7 = this;\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n      var needsToEmitClosed = !this[kClosed];\n      this[kClosed] = true;\n      return (0, utils_1.maybePromise)(callback, function (done) {\n        return cleanupCursor(_this7, {\n          needsToEmitClosed: needsToEmitClosed\n        }, done);\n      });\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray(callback) {\n      var _this8 = this;\n      return (0, utils_1.maybePromise)(callback, function (done) {\n        var docs = [];\n        var transform = _this8[kTransform];\n        var fetchDocs = function fetchDocs() {\n          // NOTE: if we add a `nextBatch` then we should use it here\n          _next(_this8, true, function (err, doc) {\n            if (err) return done(err);\n            if (doc == null) return done(undefined, docs);\n            // NOTE: no need to transform because `next` will do this automatically\n            docs.push(doc);\n            // these do need to be transformed since they are copying the rest of the batch\n            var internalDocs = transform ? _this8[kDocuments].splice(0, _this8[kDocuments].length).map(transform) : _this8[kDocuments].splice(0, _this8[kDocuments].length); // TODO(NODE-3283): Improve transform typing\n            if (internalDocs) {\n              docs.push.apply(docs, _toConsumableArray(internalDocs));\n            }\n            fetchDocs();\n          });\n        };\n        fetchDocs();\n      });\n    }\n    /**\n     * Add a cursor flag to the cursor\n     *\n     * @param flag - The flag to set, must be one of following ['tailable', 'oplogReplay', 'noCursorTimeout', 'awaitData', 'partial' -.\n     * @param value - The flag boolean value.\n     */\n  }, {\n    key: \"addCursorFlag\",\n    value: function addCursorFlag(flag, value) {\n      assertUninitialized(this);\n      if (!exports.CURSOR_FLAGS.includes(flag)) {\n        throw new error_1.MongoInvalidArgumentError(\"Flag \".concat(flag, \" is not one of \").concat(exports.CURSOR_FLAGS));\n      }\n      if (typeof value !== 'boolean') {\n        throw new error_1.MongoInvalidArgumentError(\"Flag \".concat(flag, \" must be a boolean value\"));\n      }\n      this[kOptions][flag] = value;\n      return this;\n    }\n    /**\n     * Map all documents using the provided function\n     * If there is a transform set on the cursor, that will be called first and the result passed to\n     * this function's transform.\n     *\n     * @remarks\n     * **Note for Typescript Users:** adding a transform changes the return type of the iteration of this cursor,\n     * it **does not** return a new instance of a cursor. This means when calling map,\n     * you should always assign the result to a new variable in order to get a correctly typed cursor variable.\n     * Take note of the following example:\n     *\n     * @example\n     * ```typescript\n     * const cursor: FindCursor<Document> = coll.find();\n     * const mappedCursor: FindCursor<number> = cursor.map(doc => Object.keys(doc).length);\n     * const keyCounts: number[] = await mappedCursor.toArray(); // cursor.toArray() still returns Document[]\n     * ```\n     * @param transform - The mapping transformation method.\n     */\n  }, {\n    key: \"map\",\n    value: function map(transform) {\n      assertUninitialized(this);\n      var oldTransform = this[kTransform]; // TODO(NODE-3283): Improve transform typing\n      if (oldTransform) {\n        this[kTransform] = function (doc) {\n          return transform(oldTransform(doc));\n        };\n      } else {\n        this[kTransform] = transform;\n      }\n      return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n  }, {\n    key: \"withReadPreference\",\n    value: function withReadPreference(readPreference) {\n      assertUninitialized(this);\n      if (readPreference instanceof read_preference_1.ReadPreference) {\n        this[kOptions].readPreference = readPreference;\n      } else if (typeof readPreference === 'string') {\n        this[kOptions].readPreference = read_preference_1.ReadPreference.fromString(readPreference);\n      } else {\n        throw new error_1.MongoInvalidArgumentError(\"Invalid read preference: \".concat(readPreference));\n      }\n      return this;\n    }\n    /**\n     * Set the ReadPreference for the cursor.\n     *\n     * @param readPreference - The new read preference for the cursor.\n     */\n  }, {\n    key: \"withReadConcern\",\n    value: function withReadConcern(readConcern) {\n      assertUninitialized(this);\n      var resolvedReadConcern = read_concern_1.ReadConcern.fromOptions({\n        readConcern: readConcern\n      });\n      if (resolvedReadConcern) {\n        this[kOptions].readConcern = resolvedReadConcern;\n      }\n      return this;\n    }\n    /**\n     * Set a maxTimeMS on the cursor query, allowing for hard timeout limits on queries (Only supported on MongoDB 2.6 or higher)\n     *\n     * @param value - Number of milliseconds to wait before aborting the query.\n     */\n  }, {\n    key: \"maxTimeMS\",\n    value: function maxTimeMS(value) {\n      assertUninitialized(this);\n      if (typeof value !== 'number') {\n        throw new error_1.MongoInvalidArgumentError('Argument for maxTimeMS must be a number');\n      }\n      this[kOptions].maxTimeMS = value;\n      return this;\n    }\n    /**\n     * Set the batch size for the cursor.\n     *\n     * @param value - The number of documents to return per batch. See {@link https://docs.mongodb.com/manual/reference/command/find/|find command documentation}.\n     */\n  }, {\n    key: \"batchSize\",\n    value: function batchSize(value) {\n      assertUninitialized(this);\n      if (this[kOptions].tailable) {\n        throw new error_1.MongoTailableCursorError('Tailable cursor does not support batchSize');\n      }\n      if (typeof value !== 'number') {\n        throw new error_1.MongoInvalidArgumentError('Operation \"batchSize\" requires an integer');\n      }\n      this[kOptions].batchSize = value;\n      return this;\n    }\n    /**\n     * Rewind this cursor to its uninitialized state. Any options that are present on the cursor will\n     * remain in effect. Iterating this cursor will cause new queries to be sent to the server, even\n     * if the resultant data has already been retrieved by this cursor.\n     */\n  }, {\n    key: \"rewind\",\n    value: function rewind() {\n      if (!this[kInitialized]) {\n        return;\n      }\n      this[kId] = undefined;\n      this[kDocuments] = [];\n      this[kClosed] = false;\n      this[kKilled] = false;\n      this[kInitialized] = false;\n      var session = this[kSession];\n      if (session) {\n        // We only want to end this session if we created it, and it hasn't ended yet\n        if (session.explicit === false) {\n          if (!session.hasEnded) {\n            session.endSession().catch(function () {\n              return null;\n            });\n          }\n          this[kSession] = this.client.startSession({\n            owner: this,\n            explicit: false\n          });\n        }\n      }\n    } /** @internal */\n  }, {\n    key: \"_getMore\",\n    value: function _getMore(batchSize, callback) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      var getMoreOperation = new get_more_1.GetMoreOperation(this[kNamespace], this[kId], this[kServer], _objectSpread({}, this[kOptions], {\n        session: this[kSession],\n        batchSize: batchSize\n      }));\n      (0, execute_operation_1.executeOperation)(this[kClient], getMoreOperation, callback);\n    }\n    /**\n     * @internal\n     *\n     * This function is exposed for the unified test runner's createChangeStream\n     * operation.  We cannot refactor to use the abstract _initialize method without\n     * a significant refactor.\n     */\n  }, {\n    key: kInit,\n    value: function value(callback) {\n      var _this9 = this;\n      this._initialize(this[kSession], function (err, state) {\n        if (state) {\n          var response = state.response;\n          _this9[kServer] = state.server;\n          if (response.cursor) {\n            // TODO(NODE-2674): Preserve int64 sent from MongoDB\n            _this9[kId] = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n            if (response.cursor.ns) {\n              _this9[kNamespace] = (0, utils_1.ns)(response.cursor.ns);\n            }\n            _this9[kDocuments] = response.cursor.firstBatch;\n          }\n          // When server responses return without a cursor document, we close this cursor\n          // and return the raw server response. This is often the case for explain commands\n          // for example\n          if (_this9[kId] == null) {\n            _this9[kId] = bson_1.Long.ZERO;\n            // TODO(NODE-3286): ExecutionResult needs to accept a generic parameter\n            _this9[kDocuments] = [state.response];\n          }\n        }\n        // the cursor is now initialized, even if an error occurred or it is dead\n        _this9[kInitialized] = true;\n        if (err || cursorIsDead(_this9)) {\n          return cleanupCursor(_this9, {\n            error: err\n          }, function () {\n            return callback(err, nextDocument(_this9));\n          });\n        }\n        callback();\n      });\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this[kId];\n    } /** @internal */\n  }, {\n    key: \"client\",\n    get: function get() {\n      return this[kClient];\n    } /** @internal */\n  }, {\n    key: \"server\",\n    get: function get() {\n      return this[kServer];\n    }\n  }, {\n    key: \"namespace\",\n    get: function get() {\n      return this[kNamespace];\n    }\n  }, {\n    key: \"readPreference\",\n    get: function get() {\n      return this[kOptions].readPreference;\n    }\n  }, {\n    key: \"readConcern\",\n    get: function get() {\n      return this[kOptions].readConcern;\n    } /** @internal */\n  }, {\n    key: \"session\",\n    get: function get() {\n      return this[kSession];\n    },\n    set: function set(clientSession) {\n      this[kSession] = clientSession;\n    } /** @internal */\n  }, {\n    key: \"cursorOptions\",\n    get: function get() {\n      return this[kOptions];\n    }\n  }, {\n    key: \"closed\",\n    get: function get() {\n      return this[kClosed];\n    }\n  }, {\n    key: \"killed\",\n    get: function get() {\n      return this[kKilled];\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      var _a;\n      return !!((_a = this[kClient].topology) === null || _a === void 0 ? void 0 : _a.loadBalanced);\n    }\n  }]);\n  return AbstractCursor;\n}(mongo_types_1.TypedEventEmitter);\nexports.AbstractCursor = AbstractCursor;\n/** @event */\nAbstractCursor.CLOSE = 'close';\nfunction nextDocument(cursor) {\n  if (cursor[kDocuments] == null || !cursor[kDocuments].length) {\n    return null;\n  }\n  var doc = cursor[kDocuments].shift();\n  if (doc) {\n    var transform = cursor[kTransform];\n    if (transform) {\n      return transform(doc);\n    }\n    return doc;\n  }\n  return null;\n}\n/**\n * @param cursor - the cursor on which to call `next`\n * @param blocking - a boolean indicating whether or not the cursor should `block` until data\n *     is available.  Generally, this flag is set to `false` because if the getMore returns no documents,\n *     the cursor has been exhausted.  In certain scenarios (ChangeStreams, tailable await cursors and\n *     `tryNext`, for example) blocking is necessary because a getMore returning no documents does\n *     not indicate the end of the cursor.\n * @param callback - callback to return the result to the caller\n * @returns\n */\nfunction _next(cursor, blocking, callback) {\n  var cursorId = cursor[kId];\n  if (cursor.closed) {\n    return callback(undefined, null);\n  }\n  if (cursor[kDocuments] && cursor[kDocuments].length) {\n    callback(undefined, nextDocument(cursor));\n    return;\n  }\n  if (cursorId == null) {\n    // All cursors must operate within a session, one must be made implicitly if not explicitly provided\n    cursor[kInit](function (err, value) {\n      if (err) return callback(err);\n      if (value) {\n        return callback(undefined, value);\n      }\n      return _next(cursor, blocking, callback);\n    });\n    return;\n  }\n  if (cursorIsDead(cursor)) {\n    return cleanupCursor(cursor, undefined, function () {\n      return callback(undefined, null);\n    });\n  }\n  // otherwise need to call getMore\n  var batchSize = cursor[kOptions].batchSize || 1000;\n  cursor._getMore(batchSize, function (err, response) {\n    if (response) {\n      var _cursorId = typeof response.cursor.id === 'number' ? bson_1.Long.fromNumber(response.cursor.id) : response.cursor.id;\n      cursor[kDocuments] = response.cursor.nextBatch;\n      cursor[kId] = _cursorId;\n    }\n    if (err || cursorIsDead(cursor)) {\n      return cleanupCursor(cursor, {\n        error: err\n      }, function () {\n        return callback(err, nextDocument(cursor));\n      });\n    }\n    if (cursor[kDocuments].length === 0 && blocking === false) {\n      return callback(undefined, null);\n    }\n    _next(cursor, blocking, callback);\n  });\n}\nexports.next = _next;\nfunction cursorIsDead(cursor) {\n  var cursorId = cursor[kId];\n  return !!cursorId && cursorId.isZero();\n}\nfunction cleanupCursor(cursor, options, callback) {\n  var _a;\n  var cursorId = cursor[kId];\n  var cursorNs = cursor[kNamespace];\n  var server = cursor[kServer];\n  var session = cursor[kSession];\n  var error = options === null || options === void 0 ? void 0 : options.error;\n  var needsToEmitClosed = (_a = options === null || options === void 0 ? void 0 : options.needsToEmitClosed) !== null && _a !== void 0 ? _a : cursor[kDocuments].length === 0;\n  if (error) {\n    if (cursor.loadBalanced && error instanceof error_1.MongoNetworkError) {\n      return completeCleanup();\n    }\n  }\n  if (cursorId == null || server == null || cursorId.isZero() || cursorNs == null) {\n    if (needsToEmitClosed) {\n      cursor[kClosed] = true;\n      cursor[kId] = bson_1.Long.ZERO;\n      cursor.emit(AbstractCursor.CLOSE);\n    }\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error: error\n        }, callback);\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error: error\n        });\n      }\n    }\n    return callback();\n  }\n  function completeCleanup() {\n    if (session) {\n      if (session.owner === cursor) {\n        return session.endSession({\n          error: error\n        }, function () {\n          cursor.emit(AbstractCursor.CLOSE);\n          callback();\n        });\n      }\n      if (!session.inTransaction()) {\n        (0, sessions_1.maybeClearPinnedConnection)(session, {\n          error: error\n        });\n      }\n    }\n    cursor.emit(AbstractCursor.CLOSE);\n    return callback();\n  }\n  cursor[kKilled] = true;\n  return (0, execute_operation_1.executeOperation)(cursor[kClient], new kill_cursors_1.KillCursorsOperation(cursorId, cursorNs, server, {\n    session: session\n  }), completeCleanup);\n}\n/** @internal */\nfunction assertUninitialized(cursor) {\n  if (cursor[kInitialized]) {\n    throw new error_1.MongoCursorInUseError();\n  }\n}\nexports.assertUninitialized = assertUninitialized;\nvar ReadableCursorStream = /*#__PURE__*/function (_stream_1$Readable) {\n  _inherits(ReadableCursorStream, _stream_1$Readable);\n  function ReadableCursorStream(cursor) {\n    var _this10;\n    _classCallCheck(this, ReadableCursorStream);\n    _this10 = _possibleConstructorReturn(this, _getPrototypeOf(ReadableCursorStream).call(this, {\n      objectMode: true,\n      autoDestroy: false,\n      highWaterMark: 1\n    }));\n    _this10._readInProgress = false;\n    _this10._cursor = cursor;\n    return _this10;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _createClass(ReadableCursorStream, [{\n    key: \"_read\",\n    value: function _read(size) {\n      if (!this._readInProgress) {\n        this._readInProgress = true;\n        this._readNext();\n      }\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy(error, callback) {\n      this._cursor.close(function (err) {\n        return process.nextTick(callback, err || error);\n      });\n    }\n  }, {\n    key: \"_readNext\",\n    value: function _readNext() {\n      var _this11 = this;\n      _next(this._cursor, true, function (err, result) {\n        if (err) {\n          // NOTE: This is questionable, but we have a test backing the behavior. It seems the\n          //       desired behavior is that a stream ends cleanly when a user explicitly closes\n          //       a client during iteration. Alternatively, we could do the \"right\" thing and\n          //       propagate the error message by removing this special case.\n          if (err.message.match(/server is closed/)) {\n            _this11._cursor.close().catch(function () {\n              return null;\n            });\n            return _this11.push(null);\n          }\n          // NOTE: This is also perhaps questionable. The rationale here is that these errors tend\n          //       to be \"operation interrupted\", where a cursor has been closed but there is an\n          //       active getMore in-flight. This used to check if the cursor was killed but once\n          //       that changed to happen in cleanup legitimate errors would not destroy the\n          //       stream. There are change streams test specifically test these cases.\n          if (err.message.match(/interrupted/)) {\n            return _this11.push(null);\n          }\n          return _this11.destroy(err);\n        }\n        if (result == null) {\n          _this11.push(null);\n        } else if (_this11.destroyed) {\n          _this11._cursor.close().catch(function () {\n            return null;\n          });\n        } else {\n          if (_this11.push(result)) {\n            return _this11._readNext();\n          }\n          _this11._readInProgress = false;\n        }\n      });\n    }\n  }]);\n  return ReadableCursorStream;\n}(stream_1.Readable);","map":null,"metadata":{},"sourceType":"script"}