{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Db = void 0;\nvar admin_1 = require(\"./admin\");\nvar bson_1 = require(\"./bson\");\nvar change_stream_1 = require(\"./change_stream\");\nvar collection_1 = require(\"./collection\");\nvar CONSTANTS = require(\"./constants\");\nvar aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nvar list_collections_cursor_1 = require(\"./cursor/list_collections_cursor\");\nvar error_1 = require(\"./error\");\nvar logger_1 = require(\"./logger\");\nvar add_user_1 = require(\"./operations/add_user\");\nvar collections_1 = require(\"./operations/collections\");\nvar create_collection_1 = require(\"./operations/create_collection\");\nvar drop_1 = require(\"./operations/drop\");\nvar execute_operation_1 = require(\"./operations/execute_operation\");\nvar indexes_1 = require(\"./operations/indexes\");\nvar profiling_level_1 = require(\"./operations/profiling_level\");\nvar remove_user_1 = require(\"./operations/remove_user\");\nvar rename_1 = require(\"./operations/rename\");\nvar run_command_1 = require(\"./operations/run_command\");\nvar set_profiling_level_1 = require(\"./operations/set_profiling_level\");\nvar stats_1 = require(\"./operations/stats\");\nvar read_concern_1 = require(\"./read_concern\");\nvar read_preference_1 = require(\"./read_preference\");\nvar utils_1 = require(\"./utils\");\nvar write_concern_1 = require(\"./write_concern\");\n// Allowed parameters\nvar DB_OPTIONS_ALLOW_LIST = ['writeConcern', 'readPreference', 'readPreferenceTags', 'native_parser', 'forceServerObjectId', 'pkFactory', 'serializeFunctions', 'raw', 'authSource', 'ignoreUndefined', 'readConcern', 'retryMiliSeconds', 'numberOfRetries', 'loggerLevel', 'logger', 'promoteBuffers', 'promoteLongs', 'bsonRegExp', 'enableUtf8Validation', 'promoteValues', 'compression', 'retryWrites'];\n/**\n * The **Db** class is a class that represents a MongoDB Database.\n * @public\n *\n * @example\n * ```js\n * const { MongoClient } = require('mongodb');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Select the database by name\n *   const testDb = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\nvar Db = /*#__PURE__*/function () {\n  /**\n   * Creates a new Db instance\n   *\n   * @param client - The MongoClient for the database.\n   * @param databaseName - The name of the database this instance represents.\n   * @param options - Optional settings for Db construction\n   */\n  function Db(client, databaseName, options) {\n    _classCallCheck(this, Db);\n    var _a;\n    options = options !== null && options !== void 0 ? options : {};\n    // Filter the options\n    options = (0, utils_1.filterOptions)(options, DB_OPTIONS_ALLOW_LIST);\n    // Ensure we have a valid db name\n    validateDatabaseName(databaseName);\n    // Internal state of the db object\n    this.s = {\n      // Client\n      client: client,\n      // Options\n      options: options,\n      // Logger instance\n      logger: new logger_1.Logger('Db', options),\n      // Unpack read preference\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      // Merge bson options\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, client),\n      // Set up the primary key factory or fallback to ObjectId\n      pkFactory: (_a = options === null || options === void 0 ? void 0 : options.pkFactory) !== null && _a !== void 0 ? _a : utils_1.DEFAULT_PK_FACTORY,\n      // ReadConcern\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options),\n      // Namespace\n      namespace: new utils_1.MongoDBNamespace(databaseName)\n    };\n  }\n  _createClass(Db, [{\n    key: \"createCollection\",\n    value: function createCollection(name, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new create_collection_1.CreateCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"command\",\n    value: function command(_command, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      // Intentionally, we do not inherit options from parent for this operation.\n      return (0, execute_operation_1.executeOperation)(this.s.client, new run_command_1.RunCommandOperation(this, _command, options !== null && options !== void 0 ? options : {}), callback);\n    }\n    /**\n     * Execute an aggregation framework pipeline against the database, needs MongoDB \\>= 3.6\n     *\n     * @param pipeline - An array of aggregation stages to be executed\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"aggregate\",\n    value: function aggregate() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      if (arguments.length > 2) {\n        throw new error_1.MongoInvalidArgumentError('Method \"db.aggregate()\" accepts at most two arguments');\n      }\n      if (typeof pipeline === 'function') {\n        throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must not be function');\n      }\n      if (typeof options === 'function') {\n        throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n      }\n      return new aggregation_cursor_1.AggregationCursor(this.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n    } /** Return the Admin db instance */\n  }, {\n    key: \"admin\",\n    value: function admin() {\n      return new admin_1.Admin(this);\n    }\n    /**\n     * Returns a reference to a MongoDB Collection. If it does not exist it will be created implicitly.\n     *\n     * @param name - the collection name we wish to access.\n     * @returns return the new Collection instance\n     */\n  }, {\n    key: \"collection\",\n    value: function collection(name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (typeof options === 'function') {\n        throw new error_1.MongoInvalidArgumentError('The callback form of this helper has been removed.');\n      }\n      var finalOptions = (0, utils_1.resolveOptions)(this, options);\n      return new collection_1.Collection(this, name, finalOptions);\n    }\n  }, {\n    key: \"stats\",\n    value: function stats(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new stats_1.DbStatsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"listCollections\",\n    value: function listCollections() {\n      var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new list_collections_cursor_1.ListCollectionsCursor(this, filter, (0, utils_1.resolveOptions)(this, options));\n    }\n  }, {\n    key: \"renameCollection\",\n    value: function renameCollection(fromCollection, toCollection, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      // Intentionally, we do not inherit options from parent for this operation.\n      options = _objectSpread({}, options, {\n        readPreference: read_preference_1.ReadPreference.PRIMARY\n      });\n      // Add return new collection\n      options.new_collection = true;\n      return (0, execute_operation_1.executeOperation)(this.s.client, new rename_1.RenameOperation(this.collection(fromCollection), toCollection, options), callback);\n    }\n  }, {\n    key: \"dropCollection\",\n    value: function dropCollection(name, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new drop_1.DropCollectionOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"dropDatabase\",\n    value: function dropDatabase(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new drop_1.DropDatabaseOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"collections\",\n    value: function collections(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new collections_1.CollectionsOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"createIndex\",\n    value: function createIndex(name, indexSpec, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new indexes_1.CreateIndexOperation(this, name, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"addUser\",\n    value: function addUser(username, password, options, callback) {\n      if (typeof password === 'function') {\n        callback = password, password = undefined, options = {};\n      } else if (typeof password !== 'string') {\n        if (typeof options === 'function') {\n          callback = options, options = password, password = undefined;\n        } else {\n          options = password, callback = undefined, password = undefined;\n        }\n      } else {\n        if (typeof options === 'function') callback = options, options = {};\n      }\n      return (0, execute_operation_1.executeOperation)(this.s.client, new add_user_1.AddUserOperation(this, username, password, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"removeUser\",\n    value: function removeUser(username, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new remove_user_1.RemoveUserOperation(this, username, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"setProfilingLevel\",\n    value: function setProfilingLevel(level, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new set_profiling_level_1.SetProfilingLevelOperation(this, level, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"profilingLevel\",\n    value: function profilingLevel(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new profiling_level_1.ProfilingLevelOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"indexInformation\",\n    value: function indexInformation(name, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.client, new indexes_1.IndexInformationOperation(this, name, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    /**\n     * Unref all sockets\n     * @deprecated This function is deprecated and will be removed in the next major version.\n     */\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      (0, utils_1.getTopology)(this).unref();\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates,\n     * replacements, deletions, and invalidations) in this database. Will ignore all\n     * changes to system collections.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct usecases:\n     * - The first is to provide the schema that may be defined for all the collections within this database\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TSchema - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Allow optionally not specifying a pipeline\n      if (!Array.isArray(pipeline)) {\n        options = pipeline;\n        pipeline = [];\n      }\n      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    } /** Return the db logger */\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.s.logger;\n    }\n  }, {\n    key: \"databaseName\",\n    get: function get() {\n      return this.s.namespace.db;\n    } // Options\n  }, {\n    key: \"options\",\n    get: function get() {\n      return this.s.options;\n    }\n    /**\n     * slaveOk specified\n     * @deprecated Use secondaryOk instead\n     */\n  }, {\n    key: \"slaveOk\",\n    get: function get() {\n      return this.secondaryOk;\n    }\n    /**\n     * Check if a secondary can be used (because the read preference is *not* set to primary)\n     */\n  }, {\n    key: \"secondaryOk\",\n    get: function get() {\n      var _a;\n      return ((_a = this.s.readPreference) === null || _a === void 0 ? void 0 : _a.preference) !== 'primary' || false;\n    }\n  }, {\n    key: \"readConcern\",\n    get: function get() {\n      return this.s.readConcern;\n    }\n    /**\n     * The current readPreference of the Db. If not explicitly defined for\n     * this Db, will be inherited from the parent MongoClient\n     */\n  }, {\n    key: \"readPreference\",\n    get: function get() {\n      if (this.s.readPreference == null) {\n        return this.s.client.readPreference;\n      }\n      return this.s.readPreference;\n    }\n  }, {\n    key: \"bsonOptions\",\n    get: function get() {\n      return this.s.bsonOptions;\n    } // get the write Concern\n  }, {\n    key: \"writeConcern\",\n    get: function get() {\n      return this.s.writeConcern;\n    }\n  }, {\n    key: \"namespace\",\n    get: function get() {\n      return this.s.namespace.toString();\n    }\n  }, {\n    key: \"logger\",\n    get: function get() {\n      return this.s.logger;\n    }\n  }]);\n  return Db;\n}();\nexports.Db = Db;\nDb.SYSTEM_NAMESPACE_COLLECTION = CONSTANTS.SYSTEM_NAMESPACE_COLLECTION;\nDb.SYSTEM_INDEX_COLLECTION = CONSTANTS.SYSTEM_INDEX_COLLECTION;\nDb.SYSTEM_PROFILE_COLLECTION = CONSTANTS.SYSTEM_PROFILE_COLLECTION;\nDb.SYSTEM_USER_COLLECTION = CONSTANTS.SYSTEM_USER_COLLECTION;\nDb.SYSTEM_COMMAND_COLLECTION = CONSTANTS.SYSTEM_COMMAND_COLLECTION;\nDb.SYSTEM_JS_COLLECTION = CONSTANTS.SYSTEM_JS_COLLECTION;\n// TODO(NODE-3484): Refactor into MongoDBNamespace\n// Validate the database name\nfunction validateDatabaseName(databaseName) {\n  if (typeof databaseName !== 'string') throw new error_1.MongoInvalidArgumentError('Database name must be a string');\n  if (databaseName.length === 0) throw new error_1.MongoInvalidArgumentError('Database name cannot be the empty string');\n  if (databaseName === '$external') return;\n  var invalidChars = [' ', '.', '$', '/', '\\\\'];\n  for (var i = 0; i < invalidChars.length; i++) {\n    if (databaseName.indexOf(invalidChars[i]) !== -1) throw new error_1.MongoAPIError(\"database names cannot contain the character '\".concat(invalidChars[i], \"'\"));\n  }\n}","map":null,"metadata":{},"sourceType":"script"}