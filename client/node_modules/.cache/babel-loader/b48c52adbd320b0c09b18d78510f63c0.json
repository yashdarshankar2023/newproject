{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _assertThisInitialized = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/assertThisInitialized\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MongoClient = exports.ServerApiVersion = void 0;\nvar bson_1 = require(\"./bson\");\nvar change_stream_1 = require(\"./change_stream\");\nvar connection_string_1 = require(\"./connection_string\");\nvar db_1 = require(\"./db\");\nvar error_1 = require(\"./error\");\nvar mongo_types_1 = require(\"./mongo_types\");\nvar connect_1 = require(\"./operations/connect\");\nvar promise_provider_1 = require(\"./promise_provider\");\nvar read_preference_1 = require(\"./read_preference\");\nvar server_selection_1 = require(\"./sdam/server_selection\");\nvar sessions_1 = require(\"./sessions\");\nvar utils_1 = require(\"./utils\");\n/** @public */\nexports.ServerApiVersion = Object.freeze({\n  v1: '1'\n});\n/** @internal */\nvar kOptions = Symbol('options');\n/**\n * The **MongoClient** class is a class that allows for making Connections to MongoDB.\n * @public\n *\n * @remarks\n * The programmatically provided options take precedence over the URI options.\n *\n * @example\n * ```js\n * // Connect using a MongoClient instance\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * const mongoClient = new MongoClient(url);\n * mongoClient.connect(function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n *\n * @example\n * ```js\n * // Connect using the MongoClient.connect static method\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   const db = client.db(dbName);\n *   client.close();\n * });\n * ```\n */\nvar MongoClient = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(MongoClient, _mongo_types_1$TypedE);\n  function MongoClient(url, options) {\n    var _this;\n    _classCallCheck(this, MongoClient);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MongoClient).call(this));\n    _this[kOptions] = (0, connection_string_1.parseOptions)(url, _assertThisInitialized(_assertThisInitialized(_this)), options);\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    var client = _assertThisInitialized(_assertThisInitialized(_this));\n    // The internal state\n    _this.s = {\n      url: url,\n      bsonOptions: (0, bson_1.resolveBSONOptions)(_this[kOptions]),\n      namespace: (0, utils_1.ns)('admin'),\n      hasBeenClosed: false,\n      sessionPool: new sessions_1.ServerSessionPool(_assertThisInitialized(_assertThisInitialized(_this))),\n      activeSessions: new Set(),\n      get options() {\n        return client[kOptions];\n      },\n      get readConcern() {\n        return client[kOptions].readConcern;\n      },\n      get writeConcern() {\n        return client[kOptions].writeConcern;\n      },\n      get readPreference() {\n        return client[kOptions].readPreference;\n      },\n      get logger() {\n        return client[kOptions].logger;\n      },\n      get isMongoClient() {\n        return true;\n      }\n    };\n    return _this;\n  }\n  _createClass(MongoClient, [{\n    key: \"connect\",\n    value: function connect(callback) {\n      var _this2 = this;\n      if (callback && typeof callback !== 'function') {\n        throw new error_1.MongoInvalidArgumentError('Method `connect` only accepts a callback');\n      }\n      return (0, utils_1.maybePromise)(callback, function (cb) {\n        (0, connect_1.connect)(_this2, _this2[kOptions], function (err) {\n          if (err) return cb(err);\n          cb(undefined, _this2);\n        });\n      });\n    }\n  }, {\n    key: \"close\",\n    value: function close(forceOrCallback, callback) {\n      var _this3 = this;\n      // There's no way to set hasBeenClosed back to false\n      Object.defineProperty(this.s, 'hasBeenClosed', {\n        value: true,\n        enumerable: true,\n        configurable: false,\n        writable: false\n      });\n      if (typeof forceOrCallback === 'function') {\n        callback = forceOrCallback;\n      }\n      var force = typeof forceOrCallback === 'boolean' ? forceOrCallback : false;\n      return (0, utils_1.maybePromise)(callback, function (callback) {\n        if (_this3.topology == null) {\n          // Do not connect just to end sessions\n          return callback();\n        }\n        var activeSessionEnds = Array.from(_this3.s.activeSessions, function (session) {\n          return session.endSession();\n        });\n        _this3.s.activeSessions.clear();\n        Promise.all(activeSessionEnds).then(function () {\n          if (_this3.topology == null) {\n            return;\n          }\n          // If we would attempt to select a server and get nothing back we short circuit\n          // to avoid the server selection timeout.\n          var selector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.primaryPreferred);\n          var topologyDescription = _this3.topology.description;\n          var serverDescriptions = Array.from(topologyDescription.servers.values());\n          var servers = selector(topologyDescription, serverDescriptions);\n          if (servers.length === 0) {\n            return;\n          }\n          var endSessions = Array.from(_this3.s.sessionPool.sessions, function (_ref) {\n            var id = _ref.id;\n            return id;\n          });\n          if (endSessions.length === 0) return;\n          return _this3.db('admin').command({\n            endSessions: endSessions\n          }, {\n            readPreference: read_preference_1.ReadPreference.primaryPreferred,\n            noResponse: true\n          }).catch(function () {\n            return null;\n          }); // outcome does not matter\n        }).then(function () {\n          if (_this3.topology == null) {\n            return;\n          }\n          // clear out references to old topology\n          var topology = _this3.topology;\n          _this3.topology = undefined;\n          return new Promise(function (resolve, reject) {\n            topology.close({\n              force: force\n            }, function (error) {\n              if (error) return reject(error);\n              var encrypter = _this3[kOptions].encrypter;\n              if (encrypter) {\n                return encrypter.close(_this3, force, function (error) {\n                  if (error) return reject(error);\n                  resolve();\n                });\n              }\n              resolve();\n            });\n          });\n        }).then(function () {\n          return callback();\n        }, function (error) {\n          return callback(error);\n        });\n      });\n    }\n    /**\n     * Create a new Db instance sharing the current socket connections.\n     *\n     * @param dbName - The name of the database we want to use. If not provided, use database name from connection string.\n     * @param options - Optional settings for Db construction\n     */\n  }, {\n    key: \"db\",\n    value: function db(dbName, options) {\n      options = options !== null && options !== void 0 ? options : {};\n      // Default to db from connection string if not provided\n      if (!dbName) {\n        dbName = this.options.dbName;\n      }\n      // Copy the options and add out internal override of the not shared flag\n      var finalOptions = Object.assign({}, this[kOptions], options);\n      // Return the db object\n      var db = new db_1.Db(this, dbName, finalOptions);\n      // Return the database\n      return db;\n    }\n  }, {\n    key: \"startSession\",\n    value: function startSession(options) {\n      var _this4 = this;\n      var session = new sessions_1.ClientSession(this, this.s.sessionPool, _objectSpread({\n        explicit: true\n      }, options), this[kOptions]);\n      this.s.activeSessions.add(session);\n      session.once('ended', function () {\n        _this4.s.activeSessions.delete(session);\n      });\n      return session;\n    }\n  }, {\n    key: \"withSession\",\n    value: function withSession(optionsOrOperation, callback) {\n      var options = _objectSpread({\n        // Always define an owner\n        owner: Symbol()\n      }, typeof optionsOrOperation === 'object' ? optionsOrOperation : {});\n      var withSessionCallback = typeof optionsOrOperation === 'function' ? optionsOrOperation : callback;\n      if (withSessionCallback == null) {\n        throw new error_1.MongoInvalidArgumentError('Missing required callback parameter');\n      }\n      var session = this.startSession(options);\n      var Promise = promise_provider_1.PromiseProvider.get();\n      return Promise.resolve().then(function () {\n        return withSessionCallback(session);\n      }).then(function () {\n        // Do not return the result of callback\n      }).finally(function () {\n        session.endSession().catch(function () {\n          return null;\n        });\n      });\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates,\n     * replacements, deletions, and invalidations) in this cluster. Will ignore all\n     * changes to system collections, as well as the local, admin, and config databases.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct usecases:\n     * - The first is to provide the schema that may be defined for all the data within the current cluster\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TSchema - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Allow optionally not specifying a pipeline\n      if (!Array.isArray(pipeline)) {\n        options = pipeline;\n        pipeline = [];\n      }\n      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    } /** Return the mongo client logger */\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.s.logger;\n    }\n  }, {\n    key: \"options\",\n    get: function get() {\n      return Object.freeze(_objectSpread({}, this[kOptions]));\n    }\n  }, {\n    key: \"serverApi\",\n    get: function get() {\n      return this[kOptions].serverApi && Object.freeze(_objectSpread({}, this[kOptions].serverApi));\n    }\n    /**\n     * Intended for APM use only\n     * @internal\n     */\n  }, {\n    key: \"monitorCommands\",\n    get: function get() {\n      return this[kOptions].monitorCommands;\n    },\n    set: function set(value) {\n      this[kOptions].monitorCommands = value;\n    }\n  }, {\n    key: \"autoEncrypter\",\n    get: function get() {\n      return this[kOptions].autoEncrypter;\n    }\n  }, {\n    key: \"readConcern\",\n    get: function get() {\n      return this.s.readConcern;\n    }\n  }, {\n    key: \"writeConcern\",\n    get: function get() {\n      return this.s.writeConcern;\n    }\n  }, {\n    key: \"readPreference\",\n    get: function get() {\n      return this.s.readPreference;\n    }\n  }, {\n    key: \"bsonOptions\",\n    get: function get() {\n      return this.s.bsonOptions;\n    }\n  }, {\n    key: \"logger\",\n    get: function get() {\n      return this.s.logger;\n    }\n  }], [{\n    key: \"connect\",\n    value: function connect(url, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n      try {\n        // Create client\n        var mongoClient = new MongoClient(url, options);\n        // Execute the connect method\n        if (callback) {\n          return mongoClient.connect(callback);\n        } else {\n          return mongoClient.connect();\n        }\n      } catch (error) {\n        if (callback) return callback(error);else return promise_provider_1.PromiseProvider.get().reject(error);\n      }\n    }\n  }]);\n  return MongoClient;\n}(mongo_types_1.TypedEventEmitter);\nexports.MongoClient = MongoClient;","map":null,"metadata":{},"sourceType":"script"}