{"ast":null,"code":"\"use strict\";\n\nvar _defineProperty = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LEGAL_TCP_SOCKET_OPTIONS = exports.LEGAL_TLS_SOCKET_OPTIONS = exports.prepareHandshakeDocument = exports.connect = void 0;\nvar net = require(\"net\");\nvar socks_1 = require(\"socks\");\nvar tls = require(\"tls\");\nvar bson_1 = require(\"../bson\");\nvar constants_1 = require(\"../constants\");\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nvar auth_provider_1 = require(\"./auth/auth_provider\");\nvar gssapi_1 = require(\"./auth/gssapi\");\nvar mongocr_1 = require(\"./auth/mongocr\");\nvar mongodb_aws_1 = require(\"./auth/mongodb_aws\");\nvar plain_1 = require(\"./auth/plain\");\nvar providers_1 = require(\"./auth/providers\");\nvar scram_1 = require(\"./auth/scram\");\nvar x509_1 = require(\"./auth/x509\");\nvar connection_1 = require(\"./connection\");\nvar constants_2 = require(\"./wire_protocol/constants\");\nvar AUTH_PROVIDERS = new Map([[providers_1.AuthMechanism.MONGODB_AWS, new mongodb_aws_1.MongoDBAWS()], [providers_1.AuthMechanism.MONGODB_CR, new mongocr_1.MongoCR()], [providers_1.AuthMechanism.MONGODB_GSSAPI, new gssapi_1.GSSAPI()], [providers_1.AuthMechanism.MONGODB_PLAIN, new plain_1.Plain()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA1, new scram_1.ScramSHA1()], [providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, new scram_1.ScramSHA256()], [providers_1.AuthMechanism.MONGODB_X509, new x509_1.X509()]]);\nfunction connect(options, callback) {\n  makeConnection(_objectSpread({}, options, {\n    existingSocket: undefined\n  }), function (err, socket) {\n    var _a;\n    if (err || !socket) {\n      return callback(err);\n    }\n    var ConnectionType = (_a = options.connectionType) !== null && _a !== void 0 ? _a : connection_1.Connection;\n    if (options.autoEncrypter) {\n      ConnectionType = connection_1.CryptoConnection;\n    }\n    performInitialHandshake(new ConnectionType(socket, options), options, callback);\n  });\n}\nexports.connect = connect;\nfunction checkSupportedServer(hello, options) {\n  var _a;\n  var serverVersionHighEnough = hello && (typeof hello.maxWireVersion === 'number' || hello.maxWireVersion instanceof bson_1.Int32) && hello.maxWireVersion >= constants_2.MIN_SUPPORTED_WIRE_VERSION;\n  var serverVersionLowEnough = hello && (typeof hello.minWireVersion === 'number' || hello.minWireVersion instanceof bson_1.Int32) && hello.minWireVersion <= constants_2.MAX_SUPPORTED_WIRE_VERSION;\n  if (serverVersionHighEnough) {\n    if (serverVersionLowEnough) {\n      return null;\n    }\n    var _message = \"Server at \".concat(options.hostAddress, \" reports minimum wire version \").concat(JSON.stringify(hello.minWireVersion), \", but this version of the Node.js Driver requires at most \").concat(constants_2.MAX_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(constants_2.MAX_SUPPORTED_SERVER_VERSION, \")\");\n    return new error_1.MongoCompatibilityError(_message);\n  }\n  var message = \"Server at \".concat(options.hostAddress, \" reports maximum wire version \").concat((_a = JSON.stringify(hello.maxWireVersion)) !== null && _a !== void 0 ? _a : 0, \", but this version of the Node.js Driver requires at least \").concat(constants_2.MIN_SUPPORTED_WIRE_VERSION, \" (MongoDB \").concat(constants_2.MIN_SUPPORTED_SERVER_VERSION, \")\");\n  return new error_1.MongoCompatibilityError(message);\n}\nfunction performInitialHandshake(conn, options, _callback) {\n  var callback = function callback(err, ret) {\n    if (err && conn) {\n      conn.destroy();\n    }\n    _callback(err, ret);\n  };\n  var credentials = options.credentials;\n  if (credentials) {\n    if (!(credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT) && !AUTH_PROVIDERS.get(credentials.mechanism)) {\n      callback(new error_1.MongoInvalidArgumentError(\"AuthMechanism '\".concat(credentials.mechanism, \"' not supported\")));\n      return;\n    }\n  }\n  var authContext = new auth_provider_1.AuthContext(conn, credentials, options);\n  prepareHandshakeDocument(authContext, function (err, handshakeDoc) {\n    if (err || !handshakeDoc) {\n      return callback(err);\n    }\n    var handshakeOptions = Object.assign({}, options);\n    if (typeof options.connectTimeoutMS === 'number') {\n      // The handshake technically is a monitoring check, so its socket timeout should be connectTimeoutMS\n      handshakeOptions.socketTimeoutMS = options.connectTimeoutMS;\n    }\n    var start = new Date().getTime();\n    conn.command((0, utils_1.ns)('admin.$cmd'), handshakeDoc, handshakeOptions, function (err, response) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      if ((response === null || response === void 0 ? void 0 : response.ok) === 0) {\n        callback(new error_1.MongoServerError(response));\n        return;\n      }\n      if (!('isWritablePrimary' in response)) {\n        // Provide hello-style response document.\n        response.isWritablePrimary = response[constants_1.LEGACY_HELLO_COMMAND];\n      }\n      if (response.helloOk) {\n        conn.helloOk = true;\n      }\n      var supportedServerErr = checkSupportedServer(response, options);\n      if (supportedServerErr) {\n        callback(supportedServerErr);\n        return;\n      }\n      if (options.loadBalanced) {\n        if (!response.serviceId) {\n          return callback(new error_1.MongoCompatibilityError('Driver attempted to initialize in load balancing mode, ' + 'but the server does not support this mode.'));\n        }\n      }\n      // NOTE: This is metadata attached to the connection while porting away from\n      //       handshake being done in the `Server` class. Likely, it should be\n      //       relocated, or at very least restructured.\n      conn.hello = response;\n      conn.lastHelloMS = new Date().getTime() - start;\n      if (!response.arbiterOnly && credentials) {\n        // store the response on auth context\n        authContext.response = response;\n        var resolvedCredentials = credentials.resolveAuthMechanism(response);\n        var provider = AUTH_PROVIDERS.get(resolvedCredentials.mechanism);\n        if (!provider) {\n          return callback(new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(resolvedCredentials.mechanism, \" defined.\")));\n        }\n        provider.auth(authContext, function (err) {\n          if (err) {\n            if (err instanceof error_1.MongoError) {\n              err.addErrorLabel(error_1.MongoErrorLabel.HandshakeError);\n              if ((0, error_1.needsRetryableWriteLabel)(err, response.maxWireVersion)) {\n                err.addErrorLabel(error_1.MongoErrorLabel.RetryableWriteError);\n              }\n            }\n            return callback(err);\n          }\n          callback(undefined, conn);\n        });\n        return;\n      }\n      callback(undefined, conn);\n    });\n  });\n}\n/**\n * @internal\n *\n * This function is only exposed for testing purposes.\n */\nfunction prepareHandshakeDocument(authContext, callback) {\n  var _handshakeDoc;\n  var options = authContext.options;\n  var compressors = options.compressors ? options.compressors : [];\n  var serverApi = authContext.connection.serverApi;\n  var handshakeDoc = (_handshakeDoc = {}, _defineProperty(_handshakeDoc, (serverApi === null || serverApi === void 0 ? void 0 : serverApi.version) ? 'hello' : constants_1.LEGACY_HELLO_COMMAND, true), _defineProperty(_handshakeDoc, \"helloOk\", true), _defineProperty(_handshakeDoc, \"client\", options.metadata || (0, utils_1.makeClientMetadata)(options)), _defineProperty(_handshakeDoc, \"compression\", compressors), _handshakeDoc);\n  if (options.loadBalanced === true) {\n    handshakeDoc.loadBalanced = true;\n  }\n  var credentials = authContext.credentials;\n  if (credentials) {\n    if (credentials.mechanism === providers_1.AuthMechanism.MONGODB_DEFAULT && credentials.username) {\n      handshakeDoc.saslSupportedMechs = \"\".concat(credentials.source, \".\").concat(credentials.username);\n      var _provider = AUTH_PROVIDERS.get(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256);\n      if (!_provider) {\n        // This auth mechanism is always present.\n        return callback(new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(providers_1.AuthMechanism.MONGODB_SCRAM_SHA256, \" defined.\")));\n      }\n      return _provider.prepare(handshakeDoc, authContext, callback);\n    }\n    var provider = AUTH_PROVIDERS.get(credentials.mechanism);\n    if (!provider) {\n      return callback(new error_1.MongoInvalidArgumentError(\"No AuthProvider for \".concat(credentials.mechanism, \" defined.\")));\n    }\n    return provider.prepare(handshakeDoc, authContext, callback);\n  }\n  callback(undefined, handshakeDoc);\n}\nexports.prepareHandshakeDocument = prepareHandshakeDocument;\n/** @public */\nexports.LEGAL_TLS_SOCKET_OPTIONS = ['ALPNProtocols', 'ca', 'cert', 'checkServerIdentity', 'ciphers', 'crl', 'ecdhCurve', 'key', 'minDHSize', 'passphrase', 'pfx', 'rejectUnauthorized', 'secureContext', 'secureProtocol', 'servername', 'session'];\n/** @public */\nexports.LEGAL_TCP_SOCKET_OPTIONS = ['family', 'hints', 'localAddress', 'localPort', 'lookup'];\nfunction parseConnectOptions(options) {\n  var hostAddress = options.hostAddress;\n  if (!hostAddress) throw new error_1.MongoInvalidArgumentError('Option \"hostAddress\" is required');\n  var result = {};\n  var _iterator = _createForOfIteratorHelper(exports.LEGAL_TCP_SOCKET_OPTIONS),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var name = _step.value;\n      if (options[name] != null) {\n        result[name] = options[name];\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  if (typeof hostAddress.socketPath === 'string') {\n    result.path = hostAddress.socketPath;\n    return result;\n  } else if (typeof hostAddress.host === 'string') {\n    result.host = hostAddress.host;\n    result.port = hostAddress.port;\n    return result;\n  } else {\n    // This should never happen since we set up HostAddresses\n    // But if we don't throw here the socket could hang until timeout\n    // TODO(NODE-3483)\n    throw new error_1.MongoRuntimeError(\"Unexpected HostAddress \".concat(JSON.stringify(hostAddress)));\n  }\n}\nfunction parseSslOptions(options) {\n  var result = parseConnectOptions(options);\n  // Merge in valid SSL options\n  var _iterator2 = _createForOfIteratorHelper(exports.LEGAL_TLS_SOCKET_OPTIONS),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var name = _step2.value;\n      if (options[name] != null) {\n        result[name] = options[name];\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  if (options.existingSocket) {\n    result.socket = options.existingSocket;\n  }\n  // Set default sni servername to be the same as host\n  if (result.servername == null && result.host && !net.isIP(result.host)) {\n    result.servername = result.host;\n  }\n  return result;\n}\nvar SOCKET_ERROR_EVENT_LIST = ['error', 'close', 'timeout', 'parseError'];\nvar SOCKET_ERROR_EVENTS = new Set(SOCKET_ERROR_EVENT_LIST);\nfunction makeConnection(options, _callback) {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n  var useTLS = (_a = options.tls) !== null && _a !== void 0 ? _a : false;\n  var keepAlive = (_b = options.keepAlive) !== null && _b !== void 0 ? _b : true;\n  var socketTimeoutMS = (_d = (_c = options.socketTimeoutMS) !== null && _c !== void 0 ? _c : Reflect.get(options, 'socketTimeout')) !== null && _d !== void 0 ? _d : 0;\n  var noDelay = (_e = options.noDelay) !== null && _e !== void 0 ? _e : true;\n  var connectTimeoutMS = (_f = options.connectTimeoutMS) !== null && _f !== void 0 ? _f : 30000;\n  var rejectUnauthorized = (_g = options.rejectUnauthorized) !== null && _g !== void 0 ? _g : true;\n  var keepAliveInitialDelay = (_j = ((_h = options.keepAliveInitialDelay) !== null && _h !== void 0 ? _h : 120000) > socketTimeoutMS ? Math.round(socketTimeoutMS / 2) : options.keepAliveInitialDelay) !== null && _j !== void 0 ? _j : 120000;\n  var existingSocket = options.existingSocket;\n  var socket;\n  var callback = function callback(err, ret) {\n    if (err && socket) {\n      socket.destroy();\n    }\n    _callback(err, ret);\n  };\n  if (options.proxyHost != null) {\n    // Currently, only Socks5 is supported.\n    return makeSocks5Connection(_objectSpread({}, options, {\n      connectTimeoutMS: connectTimeoutMS // Should always be present for Socks5\n    }), callback);\n  }\n  if (useTLS) {\n    var tlsSocket = tls.connect(parseSslOptions(options));\n    if (typeof tlsSocket.disableRenegotiation === 'function') {\n      tlsSocket.disableRenegotiation();\n    }\n    socket = tlsSocket;\n  } else if (existingSocket) {\n    // In the TLS case, parseSslOptions() sets options.socket to existingSocket,\n    // so we only need to handle the non-TLS case here (where existingSocket\n    // gives us all we need out of the box).\n    socket = existingSocket;\n  } else {\n    socket = net.createConnection(parseConnectOptions(options));\n  }\n  socket.setKeepAlive(keepAlive, keepAliveInitialDelay);\n  socket.setTimeout(connectTimeoutMS);\n  socket.setNoDelay(noDelay);\n  var connectEvent = useTLS ? 'secureConnect' : 'connect';\n  var cancellationHandler;\n  function errorHandler(eventName) {\n    return function (err) {\n      SOCKET_ERROR_EVENTS.forEach(function (event) {\n        return socket.removeAllListeners(event);\n      });\n      if (cancellationHandler && options.cancellationToken) {\n        options.cancellationToken.removeListener('cancel', cancellationHandler);\n      }\n      socket.removeListener(connectEvent, connectHandler);\n      callback(connectionFailureError(eventName, err));\n    };\n  }\n  function connectHandler() {\n    SOCKET_ERROR_EVENTS.forEach(function (event) {\n      return socket.removeAllListeners(event);\n    });\n    if (cancellationHandler && options.cancellationToken) {\n      options.cancellationToken.removeListener('cancel', cancellationHandler);\n    }\n    if ('authorizationError' in socket) {\n      if (socket.authorizationError && rejectUnauthorized) {\n        return callback(socket.authorizationError);\n      }\n    }\n    socket.setTimeout(socketTimeoutMS);\n    callback(undefined, socket);\n  }\n  SOCKET_ERROR_EVENTS.forEach(function (event) {\n    return socket.once(event, errorHandler(event));\n  });\n  if (options.cancellationToken) {\n    cancellationHandler = errorHandler('cancel');\n    options.cancellationToken.once('cancel', cancellationHandler);\n  }\n  if (existingSocket) {\n    process.nextTick(connectHandler);\n  } else {\n    socket.once(connectEvent, connectHandler);\n  }\n}\nfunction makeSocks5Connection(options, callback) {\n  var _a, _b;\n  var hostAddress = utils_1.HostAddress.fromHostPort((_a = options.proxyHost) !== null && _a !== void 0 ? _a : '',\n  // proxyHost is guaranteed to set here\n  (_b = options.proxyPort) !== null && _b !== void 0 ? _b : 1080);\n  // First, connect to the proxy server itself:\n  makeConnection(_objectSpread({}, options, {\n    hostAddress: hostAddress,\n    tls: false,\n    proxyHost: undefined\n  }), function (err, rawSocket) {\n    if (err) {\n      return callback(err);\n    }\n    var destination = parseConnectOptions(options);\n    if (typeof destination.host !== 'string' || typeof destination.port !== 'number') {\n      return callback(new error_1.MongoInvalidArgumentError('Can only make Socks5 connections to TCP hosts'));\n    }\n    // Then, establish the Socks5 proxy connection:\n    socks_1.SocksClient.createConnection({\n      existing_socket: rawSocket,\n      timeout: options.connectTimeoutMS,\n      command: 'connect',\n      destination: {\n        host: destination.host,\n        port: destination.port\n      },\n      proxy: {\n        // host and port are ignored because we pass existing_socket\n        host: 'iLoveJavaScript',\n        port: 0,\n        type: 5,\n        userId: options.proxyUsername || undefined,\n        password: options.proxyPassword || undefined\n      }\n    }).then(function (_ref) {\n      var socket = _ref.socket;\n      // Finally, now treat the resulting duplex stream as the\n      // socket over which we send and receive wire protocol messages:\n      makeConnection(_objectSpread({}, options, {\n        existingSocket: socket,\n        proxyHost: undefined\n      }), callback);\n    }, function (error) {\n      return callback(connectionFailureError('error', error));\n    });\n  });\n}\nfunction connectionFailureError(type, err) {\n  switch (type) {\n    case 'error':\n      return new error_1.MongoNetworkError(err);\n    case 'timeout':\n      return new error_1.MongoNetworkTimeoutError('connection timed out');\n    case 'close':\n      return new error_1.MongoNetworkError('connection closed');\n    case 'cancel':\n      return new error_1.MongoNetworkError('connection establishment was cancelled');\n    default:\n      return new error_1.MongoNetworkError('unknown network error');\n  }\n}","map":null,"metadata":{},"sourceType":"script"}