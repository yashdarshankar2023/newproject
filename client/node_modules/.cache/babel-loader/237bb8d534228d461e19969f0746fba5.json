{"ast":null,"code":"\"use strict\";\n\nfunction makeException(ErrorType, message, options) {\n  if (options.globals) {\n    ErrorType = options.globals[ErrorType.name];\n  }\n  return new ErrorType(\"\".concat(options.context ? options.context : \"Value\", \" \").concat(message, \".\"));\n}\nfunction toNumber(value, options) {\n  if (typeof value === \"bigint\") {\n    throw makeException(TypeError, \"is a BigInt which cannot be converted to a number\", options);\n  }\n  if (!options.globals) {\n    return Number(value);\n  }\n  return options.globals.Number(value);\n}\n\n// Round x to the nearest integer, choosing the even integer if it lies halfway between two.\nfunction evenRound(x) {\n  // There are four cases for numbers with fractional part being .5:\n  //\n  // case |     x     | floor(x) | round(x) | expected | x <> 0 | x % 1 | x & 1 |   example\n  //   1  |  2n + 0.5 |  2n      |  2n + 1  |  2n      |   >    |  0.5  |   0   |  0.5 ->  0\n  //   2  |  2n + 1.5 |  2n + 1  |  2n + 2  |  2n + 2  |   >    |  0.5  |   1   |  1.5 ->  2\n  //   3  | -2n - 0.5 | -2n - 1  | -2n      | -2n      |   <    | -0.5  |   0   | -0.5 ->  0\n  //   4  | -2n - 1.5 | -2n - 2  | -2n - 1  | -2n - 2  |   <    | -0.5  |   1   | -1.5 -> -2\n  // (where n is a non-negative integer)\n  //\n  // Branch here for cases 1 and 4\n  if (x > 0 && x % 1 === +0.5 && (x & 1) === 0 || x < 0 && x % 1 === -0.5 && (x & 1) === 1) {\n    return censorNegativeZero(Math.floor(x));\n  }\n  return censorNegativeZero(Math.round(x));\n}\nfunction integerPart(n) {\n  return censorNegativeZero(Math.trunc(n));\n}\nfunction sign(x) {\n  return x < 0 ? -1 : 1;\n}\nfunction modulo(x, y) {\n  // https://tc39.github.io/ecma262/#eqn-modulo\n  // Note that http://stackoverflow.com/a/4467559/3191 does NOT work for large modulos\n  var signMightNotMatch = x % y;\n  if (sign(y) !== sign(signMightNotMatch)) {\n    return signMightNotMatch + y;\n  }\n  return signMightNotMatch;\n}\nfunction censorNegativeZero(x) {\n  return x === 0 ? 0 : x;\n}\nfunction createIntegerConversion(bitLength, _ref) {\n  var unsigned = _ref.unsigned;\n  var lowerBound, upperBound;\n  if (unsigned) {\n    lowerBound = 0;\n    upperBound = Math.pow(2, bitLength) - 1;\n  } else {\n    lowerBound = -Math.pow(2, bitLength - 1);\n    upperBound = Math.pow(2, bitLength - 1) - 1;\n  }\n  var twoToTheBitLength = Math.pow(2, bitLength);\n  var twoToOneLessThanTheBitLength = Math.pow(2, bitLength - 1);\n  return function (value) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var x = toNumber(value, options);\n    x = censorNegativeZero(x);\n    if (options.enforceRange) {\n      if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite number\", options);\n      }\n      x = integerPart(x);\n      if (x < lowerBound || x > upperBound) {\n        throw makeException(TypeError, \"is outside the accepted range of \".concat(lowerBound, \" to \").concat(upperBound, \", inclusive\"), options);\n      }\n      return x;\n    }\n    if (!Number.isNaN(x) && options.clamp) {\n      x = Math.min(Math.max(x, lowerBound), upperBound);\n      x = evenRound(x);\n      return x;\n    }\n    if (!Number.isFinite(x) || x === 0) {\n      return 0;\n    }\n    x = integerPart(x);\n\n    // Math.pow(2, 64) is not accurately representable in JavaScript, so try to avoid these per-spec operations if\n    // possible. Hopefully it's an optimization for the non-64-bitLength cases too.\n    if (x >= lowerBound && x <= upperBound) {\n      return x;\n    }\n\n    // These will not work great for bitLength of 64, but oh well. See the README for more details.\n    x = modulo(x, twoToTheBitLength);\n    if (!unsigned && x >= twoToOneLessThanTheBitLength) {\n      return x - twoToTheBitLength;\n    }\n    return x;\n  };\n}\nfunction createLongLongConversion(bitLength, _ref2) {\n  var unsigned = _ref2.unsigned;\n  var upperBound = Number.MAX_SAFE_INTEGER;\n  var lowerBound = unsigned ? 0 : Number.MIN_SAFE_INTEGER;\n  var asBigIntN = unsigned ? BigInt.asUintN : BigInt.asIntN;\n  return function (value) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var x = toNumber(value, options);\n    x = censorNegativeZero(x);\n    if (options.enforceRange) {\n      if (!Number.isFinite(x)) {\n        throw makeException(TypeError, \"is not a finite number\", options);\n      }\n      x = integerPart(x);\n      if (x < lowerBound || x > upperBound) {\n        throw makeException(TypeError, \"is outside the accepted range of \".concat(lowerBound, \" to \").concat(upperBound, \", inclusive\"), options);\n      }\n      return x;\n    }\n    if (!Number.isNaN(x) && options.clamp) {\n      x = Math.min(Math.max(x, lowerBound), upperBound);\n      x = evenRound(x);\n      return x;\n    }\n    if (!Number.isFinite(x) || x === 0) {\n      return 0;\n    }\n    var xBigInt = BigInt(integerPart(x));\n    xBigInt = asBigIntN(bitLength, xBigInt);\n    return Number(xBigInt);\n  };\n}\nexports.any = function (value) {\n  return value;\n};\nexports.undefined = function () {\n  return undefined;\n};\nexports.boolean = function (value) {\n  return Boolean(value);\n};\nexports.byte = createIntegerConversion(8, {\n  unsigned: false\n});\nexports.octet = createIntegerConversion(8, {\n  unsigned: true\n});\nexports.short = createIntegerConversion(16, {\n  unsigned: false\n});\nexports[\"unsigned short\"] = createIntegerConversion(16, {\n  unsigned: true\n});\nexports.long = createIntegerConversion(32, {\n  unsigned: false\n});\nexports[\"unsigned long\"] = createIntegerConversion(32, {\n  unsigned: true\n});\nexports[\"long long\"] = createLongLongConversion(64, {\n  unsigned: false\n});\nexports[\"unsigned long long\"] = createLongLongConversion(64, {\n  unsigned: true\n});\nexports.double = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var x = toNumber(value, options);\n  if (!Number.isFinite(x)) {\n    throw makeException(TypeError, \"is not a finite floating-point value\", options);\n  }\n  return x;\n};\nexports[\"unrestricted double\"] = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var x = toNumber(value, options);\n  return x;\n};\nexports.float = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var x = toNumber(value, options);\n  if (!Number.isFinite(x)) {\n    throw makeException(TypeError, \"is not a finite floating-point value\", options);\n  }\n  if (Object.is(x, -0)) {\n    return x;\n  }\n  var y = Math.fround(x);\n  if (!Number.isFinite(y)) {\n    throw makeException(TypeError, \"is outside the range of a single-precision floating-point value\", options);\n  }\n  return y;\n};\nexports[\"unrestricted float\"] = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var x = toNumber(value, options);\n  if (isNaN(x)) {\n    return x;\n  }\n  if (Object.is(x, -0)) {\n    return x;\n  }\n  return Math.fround(x);\n};\nexports.DOMString = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (options.treatNullAsEmptyString && value === null) {\n    return \"\";\n  }\n  if (typeof value === \"symbol\") {\n    throw makeException(TypeError, \"is a symbol, which cannot be converted to a string\", options);\n  }\n  var StringCtor = options.globals ? options.globals.String : String;\n  return StringCtor(value);\n};\nexports.ByteString = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var x = exports.DOMString(value, options);\n  var c;\n  for (var i = 0; (c = x.codePointAt(i)) !== undefined; ++i) {\n    if (c > 255) {\n      throw makeException(TypeError, \"is not a valid ByteString\", options);\n    }\n  }\n  return x;\n};\nexports.USVString = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var S = exports.DOMString(value, options);\n  var n = S.length;\n  var U = [];\n  for (var i = 0; i < n; ++i) {\n    var c = S.charCodeAt(i);\n    if (c < 0xD800 || c > 0xDFFF) {\n      U.push(String.fromCodePoint(c));\n    } else if (0xDC00 <= c && c <= 0xDFFF) {\n      U.push(String.fromCodePoint(0xFFFD));\n    } else if (i === n - 1) {\n      U.push(String.fromCodePoint(0xFFFD));\n    } else {\n      var d = S.charCodeAt(i + 1);\n      if (0xDC00 <= d && d <= 0xDFFF) {\n        var a = c & 0x3FF;\n        var b = d & 0x3FF;\n        U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));\n        ++i;\n      } else {\n        U.push(String.fromCodePoint(0xFFFD));\n      }\n    }\n  }\n  return U.join(\"\");\n};\nexports.object = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (value === null || typeof value !== \"object\" && typeof value !== \"function\") {\n    throw makeException(TypeError, \"is not an object\", options);\n  }\n  return value;\n};\nvar abByteLengthGetter = Object.getOwnPropertyDescriptor(ArrayBuffer.prototype, \"byteLength\").get;\nvar sabByteLengthGetter = typeof SharedArrayBuffer === \"function\" ? Object.getOwnPropertyDescriptor(SharedArrayBuffer.prototype, \"byteLength\").get : null;\nfunction isNonSharedArrayBuffer(value) {\n  try {\n    // This will throw on SharedArrayBuffers, but not detached ArrayBuffers.\n    // (The spec says it should throw, but the spec conflicts with implementations: https://github.com/tc39/ecma262/issues/678)\n    abByteLengthGetter.call(value);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\nfunction isSharedArrayBuffer(value) {\n  try {\n    sabByteLengthGetter.call(value);\n    return true;\n  } catch (_unused2) {\n    return false;\n  }\n}\nfunction isArrayBufferDetached(value) {\n  try {\n    // eslint-disable-next-line no-new\n    new Uint8Array(value);\n    return false;\n  } catch (_unused3) {\n    return true;\n  }\n}\nexports.ArrayBuffer = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!isNonSharedArrayBuffer(value)) {\n    if (options.allowShared && !isSharedArrayBuffer(value)) {\n      throw makeException(TypeError, \"is not an ArrayBuffer or SharedArrayBuffer\", options);\n    }\n    throw makeException(TypeError, \"is not an ArrayBuffer\", options);\n  }\n  if (isArrayBufferDetached(value)) {\n    throw makeException(TypeError, \"is a detached ArrayBuffer\", options);\n  }\n  return value;\n};\nvar dvByteLengthGetter = Object.getOwnPropertyDescriptor(DataView.prototype, \"byteLength\").get;\nexports.DataView = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  try {\n    dvByteLengthGetter.call(value);\n  } catch (e) {\n    throw makeException(TypeError, \"is not a DataView\", options);\n  }\n  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n    throw makeException(TypeError, \"is backed by a SharedArrayBuffer, which is not allowed\", options);\n  }\n  if (isArrayBufferDetached(value.buffer)) {\n    throw makeException(TypeError, \"is backed by a detached ArrayBuffer\", options);\n  }\n  return value;\n};\n\n// Returns the unforgeable `TypedArray` constructor name or `undefined`,\n// if the `this` value isn't a valid `TypedArray` object.\n//\n// https://tc39.es/ecma262/#sec-get-%typedarray%.prototype-@@tostringtag\nvar typedArrayNameGetter = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Uint8Array).prototype, Symbol.toStringTag).get;\n[Int8Array, Int16Array, Int32Array, Uint8Array, Uint16Array, Uint32Array, Uint8ClampedArray, Float32Array, Float64Array].forEach(function (func) {\n  var name = func.name;\n  var article = /^[AEIOU]/.test(name) ? \"an\" : \"a\";\n  exports[name] = function (value) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!ArrayBuffer.isView(value) || typedArrayNameGetter.call(value) !== name) {\n      throw makeException(TypeError, \"is not \".concat(article, \" \").concat(name, \" object\"), options);\n    }\n    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n    }\n    if (isArrayBufferDetached(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n    }\n    return value;\n  };\n});\n\n// Common definitions\n\nexports.ArrayBufferView = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!ArrayBuffer.isView(value)) {\n    throw makeException(TypeError, \"is not a view on an ArrayBuffer or SharedArrayBuffer\", options);\n  }\n  if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n    throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n  }\n  if (isArrayBufferDetached(value.buffer)) {\n    throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n  }\n  return value;\n};\nexports.BufferSource = function (value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (ArrayBuffer.isView(value)) {\n    if (!options.allowShared && isSharedArrayBuffer(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a SharedArrayBuffer, which is not allowed\", options);\n    }\n    if (isArrayBufferDetached(value.buffer)) {\n      throw makeException(TypeError, \"is a view on a detached ArrayBuffer\", options);\n    }\n    return value;\n  }\n  if (!options.allowShared && !isNonSharedArrayBuffer(value)) {\n    throw makeException(TypeError, \"is not an ArrayBuffer or a view on one\", options);\n  }\n  if (options.allowShared && !isSharedArrayBuffer(value) && !isNonSharedArrayBuffer(value)) {\n    throw makeException(TypeError, \"is not an ArrayBuffer, SharedArrayBuffer, or a view on one\", options);\n  }\n  if (isArrayBufferDetached(value)) {\n    throw makeException(TypeError, \"is a detached ArrayBuffer\", options);\n  }\n  return value;\n};\nexports.DOMTimeStamp = exports[\"unsigned long long\"];","map":null,"metadata":{},"sourceType":"script"}