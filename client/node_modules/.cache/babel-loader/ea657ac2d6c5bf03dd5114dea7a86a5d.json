{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _defineProperty = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\nvar _ref;\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ServerCapabilities = exports.Topology = void 0;\nvar Denque = require(\"denque\");\nvar timers_1 = require(\"timers\");\nvar util_1 = require(\"util\");\nvar bson_1 = require(\"../bson\");\nvar connection_string_1 = require(\"../connection_string\");\nvar constants_1 = require(\"../constants\");\nvar error_1 = require(\"../error\");\nvar mongo_types_1 = require(\"../mongo_types\");\nvar read_preference_1 = require(\"../read_preference\");\nvar utils_1 = require(\"../utils\");\nvar common_1 = require(\"./common\");\nvar events_1 = require(\"./events\");\nvar server_1 = require(\"./server\");\nvar server_description_1 = require(\"./server_description\");\nvar server_selection_1 = require(\"./server_selection\");\nvar srv_polling_1 = require(\"./srv_polling\");\nvar topology_description_1 = require(\"./topology_description\");\n// Global state\nvar globalTopologyCounter = 0;\nvar stateTransition = (0, utils_1.makeStateMachine)((_ref = {}, _defineProperty(_ref, common_1.STATE_CLOSED, [common_1.STATE_CLOSED, common_1.STATE_CONNECTING]), _defineProperty(_ref, common_1.STATE_CONNECTING, [common_1.STATE_CONNECTING, common_1.STATE_CLOSING, common_1.STATE_CONNECTED, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CONNECTED, [common_1.STATE_CONNECTED, common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _defineProperty(_ref, common_1.STATE_CLOSING, [common_1.STATE_CLOSING, common_1.STATE_CLOSED]), _ref));\n/** @internal */\nvar kCancelled = Symbol('cancelled');\n/** @internal */\nvar kWaitQueue = Symbol('waitQueue');\n/**\n * A container of server instances representing a connection to a MongoDB topology.\n * @internal\n */\nvar Topology = /*#__PURE__*/function (_mongo_types_1$TypedE) {\n  _inherits(Topology, _mongo_types_1$TypedE);\n  /**\n   * @param seedlist - a list of HostAddress instances to connect to\n   */\n  function Topology(seeds, options) {\n    var _this;\n    _classCallCheck(this, Topology);\n    var _a;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Topology).call(this));\n    // Legacy CSFLE support\n    _this.bson = Object.create(null);\n    _this.bson.serialize = bson_1.serialize;\n    _this.bson.deserialize = bson_1.deserialize;\n    // Options should only be undefined in tests, MongoClient will always have defined options\n    options = options !== null && options !== void 0 ? options : _objectSpread({\n      hosts: [utils_1.HostAddress.fromString('localhost:27017')]\n    }, Object.fromEntries(connection_string_1.DEFAULT_OPTIONS.entries()), Object.fromEntries(connection_string_1.FEATURE_FLAGS.entries()));\n    if (typeof seeds === 'string') {\n      seeds = [utils_1.HostAddress.fromString(seeds)];\n    } else if (!Array.isArray(seeds)) {\n      seeds = [seeds];\n    }\n    var seedlist = [];\n    var _iterator = _createForOfIteratorHelper(seeds),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var seed = _step.value;\n        if (typeof seed === 'string') {\n          seedlist.push(utils_1.HostAddress.fromString(seed));\n        } else if (seed instanceof utils_1.HostAddress) {\n          seedlist.push(seed);\n        } else {\n          // FIXME(NODE-3483): May need to be a MongoParseError\n          throw new error_1.MongoRuntimeError(\"Topology cannot be constructed from \".concat(JSON.stringify(seed)));\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var topologyType = topologyTypeFromOptions(options);\n    var topologyId = globalTopologyCounter++;\n    var selectedHosts = options.srvMaxHosts == null || options.srvMaxHosts === 0 || options.srvMaxHosts >= seedlist.length ? seedlist : (0, utils_1.shuffle)(seedlist, options.srvMaxHosts);\n    var serverDescriptions = new Map();\n    var _iterator2 = _createForOfIteratorHelper(selectedHosts),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var hostAddress = _step2.value;\n        serverDescriptions.set(hostAddress.toString(), new server_description_1.ServerDescription(hostAddress));\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    _this[kWaitQueue] = new Denque();\n    _this.s = {\n      // the id of this topology\n      id: topologyId,\n      // passed in options\n      options: options,\n      // initial seedlist of servers to connect to\n      seedlist: seedlist,\n      // initial state\n      state: common_1.STATE_CLOSED,\n      // the topology description\n      description: new topology_description_1.TopologyDescription(topologyType, serverDescriptions, options.replicaSet, undefined, undefined, undefined, options),\n      serverSelectionTimeoutMS: options.serverSelectionTimeoutMS,\n      heartbeatFrequencyMS: options.heartbeatFrequencyMS,\n      minHeartbeatFrequencyMS: options.minHeartbeatFrequencyMS,\n      // a map of server instances to normalized addresses\n      servers: new Map(),\n      credentials: options === null || options === void 0 ? void 0 : options.credentials,\n      clusterTime: undefined,\n      // timer management\n      connectionTimers: new Set(),\n      detectShardedTopology: function detectShardedTopology(ev) {\n        return _this.detectShardedTopology(ev);\n      },\n      detectSrvRecords: function detectSrvRecords(ev) {\n        return _this.detectSrvRecords(ev);\n      }\n    };\n    if (options.srvHost && !options.loadBalanced) {\n      _this.s.srvPoller = (_a = options.srvPoller) !== null && _a !== void 0 ? _a : new srv_polling_1.SrvPoller({\n        heartbeatFrequencyMS: _this.s.heartbeatFrequencyMS,\n        srvHost: options.srvHost,\n        srvMaxHosts: options.srvMaxHosts,\n        srvServiceName: options.srvServiceName\n      });\n      _this.on(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this.s.detectShardedTopology);\n    }\n    return _this;\n  }\n  _createClass(Topology, [{\n    key: \"detectShardedTopology\",\n    value: function detectShardedTopology(event) {\n      var _a, _b, _c;\n      var previousType = event.previousDescription.type;\n      var newType = event.newDescription.type;\n      var transitionToSharded = previousType !== common_1.TopologyType.Sharded && newType === common_1.TopologyType.Sharded;\n      var srvListeners = (_a = this.s.srvPoller) === null || _a === void 0 ? void 0 : _a.listeners(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY);\n      var listeningToSrvPolling = !!(srvListeners === null || srvListeners === void 0 ? void 0 : srvListeners.includes(this.s.detectSrvRecords));\n      if (transitionToSharded && !listeningToSrvPolling) {\n        (_b = this.s.srvPoller) === null || _b === void 0 ? void 0 : _b.on(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, this.s.detectSrvRecords);\n        (_c = this.s.srvPoller) === null || _c === void 0 ? void 0 : _c.start();\n      }\n    }\n  }, {\n    key: \"detectSrvRecords\",\n    value: function detectSrvRecords(ev) {\n      var previousTopologyDescription = this.s.description;\n      this.s.description = this.s.description.updateFromSrvPollingEvent(ev, this.s.options.srvMaxHosts);\n      if (this.s.description === previousTopologyDescription) {\n        // Nothing changed, so return\n        return;\n      }\n      updateServers(this);\n      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n    }\n    /**\n     * @returns A `TopologyDescription` for this topology\n     */\n  }, {\n    key: \"connect\",\n    /** Initiate server connect */value: function connect(options, callback) {\n      var _this2 = this;\n      var _a;\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n      if (this.s.state === common_1.STATE_CONNECTED) {\n        if (typeof callback === 'function') {\n          callback();\n        }\n        return;\n      }\n      stateTransition(this, common_1.STATE_CONNECTING);\n      // emit SDAM monitoring events\n      this.emit(Topology.TOPOLOGY_OPENING, new events_1.TopologyOpeningEvent(this.s.id));\n      // emit an event for the topology change\n      this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, new topology_description_1.TopologyDescription(common_1.TopologyType.Unknown),\n      // initial is always Unknown\n      this.s.description));\n      // connect all known servers, then attempt server selection to connect\n      var serverDescriptions = Array.from(this.s.description.servers.values());\n      this.s.servers = new Map(serverDescriptions.map(function (serverDescription) {\n        return [serverDescription.address, createAndConnectServer(_this2, serverDescription)];\n      }));\n      // In load balancer mode we need to fake a server description getting\n      // emitted from the monitor, since the monitor doesn't exist.\n      if (this.s.options.loadBalanced) {\n        var _iterator3 = _createForOfIteratorHelper(serverDescriptions),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var description = _step3.value;\n            var newDescription = new server_description_1.ServerDescription(description.hostAddress, undefined, {\n              loadBalanced: this.s.options.loadBalanced\n            });\n            this.serverUpdateHandler(newDescription);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      var exitWithError = function exitWithError(error) {\n        return callback ? callback(error) : _this2.emit(Topology.ERROR, error);\n      };\n      var readPreference = (_a = options.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n      this.selectServer((0, server_selection_1.readPreferenceServerSelector)(readPreference), options, function (err, server) {\n        if (err) {\n          return _this2.close({\n            force: false\n          }, function () {\n            return exitWithError(err);\n          });\n        }\n        // TODO: NODE-2471\n        var skipPingOnConnect = _this2.s.options[Symbol.for('@@mdb.skipPingOnConnect')] === true;\n        if (!skipPingOnConnect && server && _this2.s.credentials) {\n          server.command((0, utils_1.ns)('admin.$cmd'), {\n            ping: 1\n          }, {}, function (err) {\n            if (err) {\n              return exitWithError(err);\n            }\n            stateTransition(_this2, common_1.STATE_CONNECTED);\n            _this2.emit(Topology.OPEN, _this2);\n            _this2.emit(Topology.CONNECT, _this2);\n            callback === null || callback === void 0 ? void 0 : callback(undefined, _this2);\n          });\n          return;\n        }\n        stateTransition(_this2, common_1.STATE_CONNECTED);\n        _this2.emit(Topology.OPEN, _this2);\n        _this2.emit(Topology.CONNECT, _this2);\n        callback === null || callback === void 0 ? void 0 : callback(undefined, _this2);\n      });\n    } /** Close this topology */\n  }, {\n    key: \"close\",\n    value: function close(options, callback) {\n      var _this3 = this;\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      if (typeof options === 'boolean') {\n        options = {\n          force: options\n        };\n      }\n      options = options !== null && options !== void 0 ? options : {};\n      if (this.s.state === common_1.STATE_CLOSED || this.s.state === common_1.STATE_CLOSING) {\n        return callback === null || callback === void 0 ? void 0 : callback();\n      }\n      var destroyedServers = Array.from(this.s.servers.values(), function (server) {\n        return (0, util_1.promisify)(destroyServer)(server, _this3, options);\n      });\n      Promise.all(destroyedServers).then(function () {\n        _this3.s.servers.clear();\n        stateTransition(_this3, common_1.STATE_CLOSING);\n        drainWaitQueue(_this3[kWaitQueue], new error_1.MongoTopologyClosedError());\n        (0, common_1.drainTimerQueue)(_this3.s.connectionTimers);\n        if (_this3.s.srvPoller) {\n          _this3.s.srvPoller.stop();\n          _this3.s.srvPoller.removeListener(srv_polling_1.SrvPoller.SRV_RECORD_DISCOVERY, _this3.s.detectSrvRecords);\n        }\n        _this3.removeListener(Topology.TOPOLOGY_DESCRIPTION_CHANGED, _this3.s.detectShardedTopology);\n        stateTransition(_this3, common_1.STATE_CLOSED);\n        // emit an event for close\n        _this3.emit(Topology.TOPOLOGY_CLOSED, new events_1.TopologyClosedEvent(_this3.s.id));\n      }).finally(function () {\n        return callback === null || callback === void 0 ? void 0 : callback();\n      });\n    }\n    /**\n     * Selects a server according to the selection predicate provided\n     *\n     * @param selector - An optional selector to select servers by, defaults to a random selection within a latency window\n     * @param options - Optional settings related to server selection\n     * @param callback - The callback used to indicate success or failure\n     * @returns An instance of a `Server` meeting the criteria of the predicate provided\n     */\n  }, {\n    key: \"selectServer\",\n    value: function selectServer(selector, options, callback) {\n      var _this4 = this;\n      var serverSelector;\n      if (typeof selector !== 'function') {\n        if (typeof selector === 'string') {\n          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(read_preference_1.ReadPreference.fromString(selector));\n        } else {\n          var readPreference;\n          if (selector instanceof read_preference_1.ReadPreference) {\n            readPreference = selector;\n          } else {\n            read_preference_1.ReadPreference.translate(options);\n            readPreference = options.readPreference || read_preference_1.ReadPreference.primary;\n          }\n          serverSelector = (0, server_selection_1.readPreferenceServerSelector)(readPreference);\n        }\n      } else {\n        serverSelector = selector;\n      }\n      options = Object.assign({}, {\n        serverSelectionTimeoutMS: this.s.serverSelectionTimeoutMS\n      }, options);\n      var isSharded = this.description.type === common_1.TopologyType.Sharded;\n      var session = options.session;\n      var transaction = session && session.transaction;\n      if (isSharded && transaction && transaction.server) {\n        callback(undefined, transaction.server);\n        return;\n      }\n      var waitQueueMember = {\n        serverSelector: serverSelector,\n        transaction: transaction,\n        callback: callback\n      };\n      var serverSelectionTimeoutMS = options.serverSelectionTimeoutMS;\n      if (serverSelectionTimeoutMS) {\n        waitQueueMember.timer = (0, timers_1.setTimeout)(function () {\n          waitQueueMember[kCancelled] = true;\n          waitQueueMember.timer = undefined;\n          var timeoutError = new error_1.MongoServerSelectionError(\"Server selection timed out after \".concat(serverSelectionTimeoutMS, \" ms\"), _this4.description);\n          waitQueueMember.callback(timeoutError);\n        }, serverSelectionTimeoutMS);\n      }\n      this[kWaitQueue].push(waitQueueMember);\n      processWaitQueue(this);\n    } // Sessions related methods\n    /**\n     * @returns Whether the topology should initiate selection to determine session support\n     */\n  }, {\n    key: \"shouldCheckForSessionSupport\",\n    value: function shouldCheckForSessionSupport() {\n      if (this.description.type === common_1.TopologyType.Single) {\n        return !this.description.hasKnownServers;\n      }\n      return !this.description.hasDataBearingServers;\n    }\n    /**\n     * @returns Whether sessions are supported on the current topology\n     */\n  }, {\n    key: \"hasSessionSupport\",\n    value: function hasSessionSupport() {\n      return this.loadBalanced || this.description.logicalSessionTimeoutMinutes != null;\n    }\n    /**\n     * Update the internal TopologyDescription with a ServerDescription\n     *\n     * @param serverDescription - The server to update in the internal list of server descriptions\n     */\n  }, {\n    key: \"serverUpdateHandler\",\n    value: function serverUpdateHandler(serverDescription) {\n      if (!this.s.description.hasServer(serverDescription.address)) {\n        return;\n      }\n      // ignore this server update if its from an outdated topologyVersion\n      if (isStaleServerDescription(this.s.description, serverDescription)) {\n        return;\n      }\n      // these will be used for monitoring events later\n      var previousTopologyDescription = this.s.description;\n      var previousServerDescription = this.s.description.servers.get(serverDescription.address);\n      if (!previousServerDescription) {\n        return;\n      }\n      // Driver Sessions Spec: \"Whenever a driver receives a cluster time from\n      // a server it MUST compare it to the current highest seen cluster time\n      // for the deployment. If the new cluster time is higher than the\n      // highest seen cluster time it MUST become the new highest seen cluster\n      // time. Two cluster times are compared using only the BsonTimestamp\n      // value of the clusterTime embedded field.\"\n      var clusterTime = serverDescription.$clusterTime;\n      if (clusterTime) {\n        (0, common_1._advanceClusterTime)(this, clusterTime);\n      }\n      // If we already know all the information contained in this updated description, then\n      // we don't need to emit SDAM events, but still need to update the description, in order\n      // to keep client-tracked attributes like last update time and round trip time up to date\n      var equalDescriptions = previousServerDescription && previousServerDescription.equals(serverDescription);\n      // first update the TopologyDescription\n      this.s.description = this.s.description.update(serverDescription);\n      if (this.s.description.compatibilityError) {\n        this.emit(Topology.ERROR, new error_1.MongoCompatibilityError(this.s.description.compatibilityError));\n        return;\n      }\n      // emit monitoring events for this change\n      if (!equalDescriptions) {\n        var newDescription = this.s.description.servers.get(serverDescription.address);\n        if (newDescription) {\n          this.emit(Topology.SERVER_DESCRIPTION_CHANGED, new events_1.ServerDescriptionChangedEvent(this.s.id, serverDescription.address, previousServerDescription, newDescription));\n        }\n      }\n      // update server list from updated descriptions\n      updateServers(this, serverDescription);\n      // attempt to resolve any outstanding server selection attempts\n      if (this[kWaitQueue].length > 0) {\n        processWaitQueue(this);\n      }\n      if (!equalDescriptions) {\n        this.emit(Topology.TOPOLOGY_DESCRIPTION_CHANGED, new events_1.TopologyDescriptionChangedEvent(this.s.id, previousTopologyDescription, this.s.description));\n      }\n    }\n  }, {\n    key: \"auth\",\n    value: function auth(credentials, callback) {\n      if (typeof credentials === 'function') callback = credentials, credentials = undefined;\n      if (typeof callback === 'function') callback(undefined, true);\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      return this.s.state === common_1.STATE_CONNECTED;\n    }\n  }, {\n    key: \"isDestroyed\",\n    value: function isDestroyed() {\n      return this.s.state === common_1.STATE_CLOSED;\n    }\n    /**\n     * @deprecated This function is deprecated and will be removed in the next major version.\n     */\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      (0, utils_1.emitWarning)('`unref` is a noop and will be removed in the next major version');\n    } // NOTE: There are many places in code where we explicitly check the last hello\n    //       to do feature support detection. This should be done any other way, but for\n    //       now we will just return the first hello seen, which should suffice.\n  }, {\n    key: \"lastHello\",\n    value: function lastHello() {\n      var serverDescriptions = Array.from(this.description.servers.values());\n      if (serverDescriptions.length === 0) return {};\n      var sd = serverDescriptions.filter(function (sd) {\n        return sd.type !== common_1.ServerType.Unknown;\n      })[0];\n      var result = sd || {\n        maxWireVersion: this.description.commonWireVersion\n      };\n      return result;\n    }\n  }, {\n    key: \"description\",\n    get: function get() {\n      return this.s.description;\n    }\n  }, {\n    key: \"loadBalanced\",\n    get: function get() {\n      return this.s.options.loadBalanced;\n    }\n  }, {\n    key: \"capabilities\",\n    get: function get() {\n      return new ServerCapabilities(this.lastHello());\n    }\n  }, {\n    key: \"clientMetadata\",\n    get: function get() {\n      return this.s.options.metadata;\n    }\n  }, {\n    key: \"commonWireVersion\",\n    get: function get() {\n      return this.description.commonWireVersion;\n    }\n  }, {\n    key: \"logicalSessionTimeoutMinutes\",\n    get: function get() {\n      return this.description.logicalSessionTimeoutMinutes;\n    }\n  }, {\n    key: \"clusterTime\",\n    get: function get() {\n      return this.s.clusterTime;\n    },\n    set: function set(clusterTime) {\n      this.s.clusterTime = clusterTime;\n    }\n  }]);\n  return Topology;\n}(mongo_types_1.TypedEventEmitter);\nexports.Topology = Topology;\n/** @event */\nTopology.SERVER_OPENING = constants_1.SERVER_OPENING;\n/** @event */\nTopology.SERVER_CLOSED = constants_1.SERVER_CLOSED;\n/** @event */\nTopology.SERVER_DESCRIPTION_CHANGED = constants_1.SERVER_DESCRIPTION_CHANGED;\n/** @event */\nTopology.TOPOLOGY_OPENING = constants_1.TOPOLOGY_OPENING;\n/** @event */\nTopology.TOPOLOGY_CLOSED = constants_1.TOPOLOGY_CLOSED;\n/** @event */\nTopology.TOPOLOGY_DESCRIPTION_CHANGED = constants_1.TOPOLOGY_DESCRIPTION_CHANGED;\n/** @event */\nTopology.ERROR = constants_1.ERROR;\n/** @event */\nTopology.OPEN = constants_1.OPEN;\n/** @event */\nTopology.CONNECT = constants_1.CONNECT;\n/** @event */\nTopology.CLOSE = constants_1.CLOSE;\n/** @event */\nTopology.TIMEOUT = constants_1.TIMEOUT;\n/** Destroys a server, and removes all event listeners from the instance */\nfunction destroyServer(server, topology, options, callback) {\n  options = options !== null && options !== void 0 ? options : {};\n  var _iterator4 = _createForOfIteratorHelper(constants_1.LOCAL_SERVER_EVENTS),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var event = _step4.value;\n      server.removeAllListeners(event);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  server.destroy(options, function () {\n    topology.emit(Topology.SERVER_CLOSED, new events_1.ServerClosedEvent(topology.s.id, server.description.address));\n    var _iterator5 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),\n      _step5;\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var event = _step5.value;\n        server.removeAllListeners(event);\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    if (typeof callback === 'function') {\n      callback();\n    }\n  });\n}\n/** Predicts the TopologyType from options */\nfunction topologyTypeFromOptions(options) {\n  if (options === null || options === void 0 ? void 0 : options.directConnection) {\n    return common_1.TopologyType.Single;\n  }\n  if (options === null || options === void 0 ? void 0 : options.replicaSet) {\n    return common_1.TopologyType.ReplicaSetNoPrimary;\n  }\n  if (options === null || options === void 0 ? void 0 : options.loadBalanced) {\n    return common_1.TopologyType.LoadBalanced;\n  }\n  return common_1.TopologyType.Unknown;\n}\n/**\n * Creates new server instances and attempts to connect them\n *\n * @param topology - The topology that this server belongs to\n * @param serverDescription - The description for the server to initialize and connect to\n */\nfunction createAndConnectServer(topology, serverDescription) {\n  topology.emit(Topology.SERVER_OPENING, new events_1.ServerOpeningEvent(topology.s.id, serverDescription.address));\n  var server = new server_1.Server(topology, serverDescription, topology.s.options);\n  var _iterator6 = _createForOfIteratorHelper(constants_1.SERVER_RELAY_EVENTS),\n    _step6;\n  try {\n    var _loop = function _loop() {\n      var event = _step6.value;\n      server.on(event, function (e) {\n        return topology.emit(event, e);\n      });\n    };\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      _loop();\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  server.on(server_1.Server.DESCRIPTION_RECEIVED, function (description) {\n    return topology.serverUpdateHandler(description);\n  });\n  server.connect();\n  return server;\n}\n/**\n * @param topology - Topology to update.\n * @param incomingServerDescription - New server description.\n */\nfunction updateServers(topology, incomingServerDescription) {\n  // update the internal server's description\n  if (incomingServerDescription && topology.s.servers.has(incomingServerDescription.address)) {\n    var server = topology.s.servers.get(incomingServerDescription.address);\n    if (server) {\n      server.s.description = incomingServerDescription;\n    }\n  }\n  // add new servers for all descriptions we currently don't know about locally\n  var _iterator7 = _createForOfIteratorHelper(topology.description.servers.values()),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var serverDescription = _step7.value;\n      if (!topology.s.servers.has(serverDescription.address)) {\n        var _server = createAndConnectServer(topology, serverDescription);\n        topology.s.servers.set(serverDescription.address, _server);\n      }\n    }\n    // for all servers no longer known, remove their descriptions and destroy their instances\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n  var _iterator8 = _createForOfIteratorHelper(topology.s.servers),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var entry = _step8.value;\n      var serverAddress = entry[0];\n      if (topology.description.hasServer(serverAddress)) {\n        continue;\n      }\n      if (!topology.s.servers.has(serverAddress)) {\n        continue;\n      }\n      var _server2 = topology.s.servers.get(serverAddress);\n      topology.s.servers.delete(serverAddress);\n      // prepare server for garbage collection\n      if (_server2) {\n        destroyServer(_server2, topology);\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\nfunction drainWaitQueue(queue, err) {\n  while (queue.length) {\n    var waitQueueMember = queue.shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n    if (waitQueueMember.timer) {\n      (0, timers_1.clearTimeout)(waitQueueMember.timer);\n    }\n    if (!waitQueueMember[kCancelled]) {\n      waitQueueMember.callback(err);\n    }\n  }\n}\nfunction processWaitQueue(topology) {\n  if (topology.s.state === common_1.STATE_CLOSED) {\n    drainWaitQueue(topology[kWaitQueue], new error_1.MongoTopologyClosedError());\n    return;\n  }\n  var isSharded = topology.description.type === common_1.TopologyType.Sharded;\n  var serverDescriptions = Array.from(topology.description.servers.values());\n  var membersToProcess = topology[kWaitQueue].length;\n  for (var i = 0; i < membersToProcess; ++i) {\n    var waitQueueMember = topology[kWaitQueue].shift();\n    if (!waitQueueMember) {\n      continue;\n    }\n    if (waitQueueMember[kCancelled]) {\n      continue;\n    }\n    var selectedDescriptions = void 0;\n    try {\n      var serverSelector = waitQueueMember.serverSelector;\n      selectedDescriptions = serverSelector ? serverSelector(topology.description, serverDescriptions) : serverDescriptions;\n    } catch (e) {\n      if (waitQueueMember.timer) {\n        (0, timers_1.clearTimeout)(waitQueueMember.timer);\n      }\n      waitQueueMember.callback(e);\n      continue;\n    }\n    var selectedServer = void 0;\n    if (selectedDescriptions.length === 0) {\n      topology[kWaitQueue].push(waitQueueMember);\n      continue;\n    } else if (selectedDescriptions.length === 1) {\n      selectedServer = topology.s.servers.get(selectedDescriptions[0].address);\n    } else {\n      // don't shuffle the array if there are only two elements\n      var descriptions = selectedDescriptions.length === 2 ? selectedDescriptions : (0, utils_1.shuffle)(selectedDescriptions, 2);\n      var server1 = topology.s.servers.get(descriptions[0].address);\n      var server2 = topology.s.servers.get(descriptions[1].address);\n      selectedServer = server1 && server2 && server1.s.operationCount < server2.s.operationCount ? server1 : server2;\n    }\n    if (!selectedServer) {\n      waitQueueMember.callback(new error_1.MongoServerSelectionError('server selection returned a server description but the server was not found in the topology', topology.description));\n      return;\n    }\n    var transaction = waitQueueMember.transaction;\n    if (isSharded && transaction && transaction.isActive && selectedServer) {\n      transaction.pinServer(selectedServer);\n    }\n    if (waitQueueMember.timer) {\n      (0, timers_1.clearTimeout)(waitQueueMember.timer);\n    }\n    waitQueueMember.callback(undefined, selectedServer);\n  }\n  if (topology[kWaitQueue].length > 0) {\n    // ensure all server monitors attempt monitoring soon\n    var _iterator9 = _createForOfIteratorHelper(topology.s.servers),\n      _step9;\n    try {\n      var _loop2 = function _loop2() {\n        var _step9$value = _slicedToArray(_step9.value, 2),\n          server = _step9$value[1];\n        process.nextTick(function scheduleServerCheck() {\n          return server.requestCheck();\n        });\n      };\n      for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator9.e(err);\n    } finally {\n      _iterator9.f();\n    }\n  }\n}\nfunction isStaleServerDescription(topologyDescription, incomingServerDescription) {\n  var currentServerDescription = topologyDescription.servers.get(incomingServerDescription.address);\n  var currentTopologyVersion = currentServerDescription === null || currentServerDescription === void 0 ? void 0 : currentServerDescription.topologyVersion;\n  return (0, server_description_1.compareTopologyVersion)(currentTopologyVersion, incomingServerDescription.topologyVersion) > 0;\n}\n/** @public */\nvar ServerCapabilities = /*#__PURE__*/function () {\n  function ServerCapabilities(hello) {\n    _classCallCheck(this, ServerCapabilities);\n    this.minWireVersion = hello.minWireVersion || 0;\n    this.maxWireVersion = hello.maxWireVersion || 0;\n  }\n  _createClass(ServerCapabilities, [{\n    key: \"hasAggregationCursor\",\n    get: function get() {\n      return this.maxWireVersion >= 1;\n    }\n  }, {\n    key: \"hasWriteCommands\",\n    get: function get() {\n      return this.maxWireVersion >= 2;\n    }\n  }, {\n    key: \"hasTextSearch\",\n    get: function get() {\n      return this.minWireVersion >= 0;\n    }\n  }, {\n    key: \"hasAuthCommands\",\n    get: function get() {\n      return this.maxWireVersion >= 1;\n    }\n  }, {\n    key: \"hasListCollectionsCommand\",\n    get: function get() {\n      return this.maxWireVersion >= 3;\n    }\n  }, {\n    key: \"hasListIndexesCommand\",\n    get: function get() {\n      return this.maxWireVersion >= 3;\n    }\n  }, {\n    key: \"supportsSnapshotReads\",\n    get: function get() {\n      return this.maxWireVersion >= 13;\n    }\n  }, {\n    key: \"commandsTakeWriteConcern\",\n    get: function get() {\n      return this.maxWireVersion >= 5;\n    }\n  }, {\n    key: \"commandsTakeCollation\",\n    get: function get() {\n      return this.maxWireVersion >= 5;\n    }\n  }]);\n  return ServerCapabilities;\n}();\nexports.ServerCapabilities = ServerCapabilities;","map":null,"metadata":{},"sourceType":"script"}