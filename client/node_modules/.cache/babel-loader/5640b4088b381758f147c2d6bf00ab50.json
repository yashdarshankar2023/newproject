{"ast":null,"code":"\"use strict\";\n\nvar _get = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nvar _slicedToArray = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.IndexInformationOperation = exports.IndexExistsOperation = exports.ListIndexesOperation = exports.DropIndexesOperation = exports.DropIndexOperation = exports.EnsureIndexOperation = exports.CreateIndexOperation = exports.CreateIndexesOperation = exports.IndexesOperation = void 0;\nvar error_1 = require(\"../error\");\nvar read_preference_1 = require(\"../read_preference\");\nvar utils_1 = require(\"../utils\");\nvar command_1 = require(\"./command\");\nvar common_functions_1 = require(\"./common_functions\");\nvar operation_1 = require(\"./operation\");\nvar VALID_INDEX_OPTIONS = new Set(['background', 'unique', 'name', 'partialFilterExpression', 'sparse', 'hidden', 'expireAfterSeconds', 'storageEngine', 'collation', 'version',\n// text indexes\n'weights', 'default_language', 'language_override', 'textIndexVersion',\n// 2d-sphere indexes\n'2dsphereIndexVersion',\n// 2d indexes\n'bits', 'min', 'max',\n// geoHaystack Indexes\n'bucketSize',\n// wildcard indexes\n'wildcardProjection']);\nfunction isIndexDirection(x) {\n  return typeof x === 'number' || x === '2d' || x === '2dsphere' || x === 'text' || x === 'geoHaystack';\n}\nfunction isSingleIndexTuple(t) {\n  return Array.isArray(t) && t.length === 2 && isIndexDirection(t[1]);\n}\nfunction makeIndexSpec(indexSpec, options) {\n  var _a;\n  var key = new Map();\n  var indexSpecs = !Array.isArray(indexSpec) || isSingleIndexTuple(indexSpec) ? [indexSpec] : indexSpec;\n  // Iterate through array and handle different types\n  var _iterator = _createForOfIteratorHelper(indexSpecs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var spec = _step.value;\n      if (typeof spec === 'string') {\n        key.set(spec, 1);\n      } else if (Array.isArray(spec)) {\n        key.set(spec[0], (_a = spec[1]) !== null && _a !== void 0 ? _a : 1);\n      } else if (spec instanceof Map) {\n        var _iterator2 = _createForOfIteratorHelper(spec),\n          _step2;\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _step2$value = _slicedToArray(_step2.value, 2),\n              property = _step2$value[0],\n              value = _step2$value[1];\n            key.set(property, value);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      } else if ((0, utils_1.isObject)(spec)) {\n        for (var _i = 0, _Object$entries = Object.entries(spec); _i < _Object$entries.length; _i++) {\n          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n            _property = _Object$entries$_i[0],\n            _value = _Object$entries$_i[1];\n          key.set(_property, _value);\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return _objectSpread({}, options, {\n    key: key\n  });\n}\n/** @internal */\nvar IndexesOperation = /*#__PURE__*/function (_operation_1$Abstract) {\n  _inherits(IndexesOperation, _operation_1$Abstract);\n  function IndexesOperation(collection, options) {\n    var _this;\n    _classCallCheck(this, IndexesOperation);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(IndexesOperation).call(this, options));\n    _this.options = options;\n    _this.collection = collection;\n    return _this;\n  }\n  _createClass(IndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var coll = this.collection;\n      var options = this.options;\n      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread({\n        full: true\n      }, options, {\n        readPreference: this.readPreference,\n        session: session\n      }), callback);\n    }\n  }]);\n  return IndexesOperation;\n}(operation_1.AbstractOperation);\nexports.IndexesOperation = IndexesOperation;\n/** @internal */\nvar CreateIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe) {\n  _inherits(CreateIndexesOperation, _command_1$CommandOpe);\n  function CreateIndexesOperation(parent, collectionName, indexes, options) {\n    var _this2;\n    _classCallCheck(this, CreateIndexesOperation);\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CreateIndexesOperation).call(this, parent, options));\n    _this2.options = options !== null && options !== void 0 ? options : {};\n    _this2.collectionName = collectionName;\n    _this2.indexes = indexes.map(function (userIndex) {\n      // Ensure the key is a Map to preserve index key ordering\n      var key = userIndex.key instanceof Map ? userIndex.key : new Map(Object.entries(userIndex.key));\n      var name = userIndex.name != null ? userIndex.name : Array.from(key).flat().join('_');\n      var validIndexOptions = Object.fromEntries(Object.entries(_objectSpread({}, userIndex)).filter(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n          optionName = _ref2[0];\n        return VALID_INDEX_OPTIONS.has(optionName);\n      }));\n      return _objectSpread({}, validIndexOptions, {\n        name: name,\n        key: key\n      });\n    });\n    return _this2;\n  }\n  _createClass(CreateIndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var options = this.options;\n      var indexes = this.indexes;\n      var serverWireVersion = (0, utils_1.maxWireVersion)(server);\n      var cmd = {\n        createIndexes: this.collectionName,\n        indexes: indexes\n      };\n      if (options.commitQuorum != null) {\n        if (serverWireVersion < 9) {\n          callback(new error_1.MongoCompatibilityError('Option `commitQuorum` for `createIndexes` not supported on servers < 4.4'));\n          return;\n        }\n        cmd.commitQuorum = options.commitQuorum;\n      }\n      // collation is set on each index, it should not be defined at the root\n      this.options.collation = undefined;\n      _get(_getPrototypeOf(CreateIndexesOperation.prototype), \"executeCommand\", this).call(this, server, session, cmd, function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        var indexNames = indexes.map(function (index) {\n          return index.name || '';\n        });\n        callback(undefined, indexNames);\n      });\n    }\n  }]);\n  return CreateIndexesOperation;\n}(command_1.CommandOperation);\nexports.CreateIndexesOperation = CreateIndexesOperation;\n/** @internal */\nvar CreateIndexOperation = /*#__PURE__*/function (_CreateIndexesOperati) {\n  _inherits(CreateIndexOperation, _CreateIndexesOperati);\n  function CreateIndexOperation(parent, collectionName, indexSpec, options) {\n    _classCallCheck(this, CreateIndexOperation);\n    return _possibleConstructorReturn(this, _getPrototypeOf(CreateIndexOperation).call(this, parent, collectionName, [makeIndexSpec(indexSpec, options)], options));\n  }\n  _createClass(CreateIndexOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      _get(_getPrototypeOf(CreateIndexOperation.prototype), \"execute\", this).call(this, server, session, function (err, indexNames) {\n        if (err || !indexNames) return callback(err);\n        return callback(undefined, indexNames[0]);\n      });\n    }\n  }]);\n  return CreateIndexOperation;\n}(CreateIndexesOperation);\nexports.CreateIndexOperation = CreateIndexOperation;\n/** @internal */\nvar EnsureIndexOperation = /*#__PURE__*/function (_CreateIndexOperation) {\n  _inherits(EnsureIndexOperation, _CreateIndexOperation);\n  function EnsureIndexOperation(db, collectionName, indexSpec, options) {\n    var _this3;\n    _classCallCheck(this, EnsureIndexOperation);\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(EnsureIndexOperation).call(this, db, collectionName, indexSpec, options));\n    _this3.readPreference = read_preference_1.ReadPreference.primary;\n    _this3.db = db;\n    _this3.collectionName = collectionName;\n    return _this3;\n  }\n  _createClass(EnsureIndexOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this4 = this;\n      var indexName = this.indexes[0].name;\n      var cursor = this.db.collection(this.collectionName).listIndexes({\n        session: session\n      });\n      cursor.toArray(function (err, indexes) {\n        /// ignore \"NamespaceNotFound\" errors\n        if (err && err.code !== error_1.MONGODB_ERROR_CODES.NamespaceNotFound) {\n          return callback(err);\n        }\n        if (indexes) {\n          indexes = Array.isArray(indexes) ? indexes : [indexes];\n          if (indexes.some(function (index) {\n            return index.name === indexName;\n          })) {\n            callback(undefined, indexName);\n            return;\n          }\n        }\n        _get(_getPrototypeOf(EnsureIndexOperation.prototype), \"execute\", _this4).call(_this4, server, session, callback);\n      });\n    }\n  }]);\n  return EnsureIndexOperation;\n}(CreateIndexOperation);\nexports.EnsureIndexOperation = EnsureIndexOperation;\n/** @internal */\nvar DropIndexOperation = /*#__PURE__*/function (_command_1$CommandOpe2) {\n  _inherits(DropIndexOperation, _command_1$CommandOpe2);\n  function DropIndexOperation(collection, indexName, options) {\n    var _this5;\n    _classCallCheck(this, DropIndexOperation);\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(DropIndexOperation).call(this, collection, options));\n    _this5.options = options !== null && options !== void 0 ? options : {};\n    _this5.collection = collection;\n    _this5.indexName = indexName;\n    return _this5;\n  }\n  _createClass(DropIndexOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var cmd = {\n        dropIndexes: this.collection.collectionName,\n        index: this.indexName\n      };\n      _get(_getPrototypeOf(DropIndexOperation.prototype), \"executeCommand\", this).call(this, server, session, cmd, callback);\n    }\n  }]);\n  return DropIndexOperation;\n}(command_1.CommandOperation);\nexports.DropIndexOperation = DropIndexOperation;\n/** @internal */\nvar DropIndexesOperation = /*#__PURE__*/function (_DropIndexOperation) {\n  _inherits(DropIndexesOperation, _DropIndexOperation);\n  function DropIndexesOperation(collection, options) {\n    _classCallCheck(this, DropIndexesOperation);\n    return _possibleConstructorReturn(this, _getPrototypeOf(DropIndexesOperation).call(this, collection, '*', options));\n  }\n  _createClass(DropIndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      _get(_getPrototypeOf(DropIndexesOperation.prototype), \"execute\", this).call(this, server, session, function (err) {\n        if (err) return callback(err, false);\n        callback(undefined, true);\n      });\n    }\n  }]);\n  return DropIndexesOperation;\n}(DropIndexOperation);\nexports.DropIndexesOperation = DropIndexesOperation;\n/** @internal */\nvar ListIndexesOperation = /*#__PURE__*/function (_command_1$CommandOpe3) {\n  _inherits(ListIndexesOperation, _command_1$CommandOpe3);\n  function ListIndexesOperation(collection, options) {\n    var _this6;\n    _classCallCheck(this, ListIndexesOperation);\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(ListIndexesOperation).call(this, collection, options));\n    _this6.options = options !== null && options !== void 0 ? options : {};\n    _this6.collectionNamespace = collection.s.namespace;\n    return _this6;\n  }\n  _createClass(ListIndexesOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var serverWireVersion = (0, utils_1.maxWireVersion)(server);\n      var cursor = this.options.batchSize ? {\n        batchSize: this.options.batchSize\n      } : {};\n      var command = {\n        listIndexes: this.collectionNamespace.collection,\n        cursor: cursor\n      };\n      // we check for undefined specifically here to allow falsy values\n      // eslint-disable-next-line no-restricted-syntax\n      if (serverWireVersion >= 9 && this.options.comment !== undefined) {\n        command.comment = this.options.comment;\n      }\n      _get(_getPrototypeOf(ListIndexesOperation.prototype), \"executeCommand\", this).call(this, server, session, command, callback);\n    }\n  }]);\n  return ListIndexesOperation;\n}(command_1.CommandOperation);\nexports.ListIndexesOperation = ListIndexesOperation;\n/** @internal */\nvar IndexExistsOperation = /*#__PURE__*/function (_operation_1$Abstract2) {\n  _inherits(IndexExistsOperation, _operation_1$Abstract2);\n  function IndexExistsOperation(collection, indexes, options) {\n    var _this7;\n    _classCallCheck(this, IndexExistsOperation);\n    _this7 = _possibleConstructorReturn(this, _getPrototypeOf(IndexExistsOperation).call(this, options));\n    _this7.options = options;\n    _this7.collection = collection;\n    _this7.indexes = indexes;\n    return _this7;\n  }\n  _createClass(IndexExistsOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var coll = this.collection;\n      var indexes = this.indexes;\n      (0, common_functions_1.indexInformation)(coll.s.db, coll.collectionName, _objectSpread({}, this.options, {\n        readPreference: this.readPreference,\n        session: session\n      }), function (err, indexInformation) {\n        // If we have an error return\n        if (err != null) return callback(err);\n        // Let's check for the index names\n        if (!Array.isArray(indexes)) return callback(undefined, indexInformation[indexes] != null);\n        // Check in list of indexes\n        for (var i = 0; i < indexes.length; i++) {\n          if (indexInformation[indexes[i]] == null) {\n            return callback(undefined, false);\n          }\n        }\n        // All keys found return true\n        return callback(undefined, true);\n      });\n    }\n  }]);\n  return IndexExistsOperation;\n}(operation_1.AbstractOperation);\nexports.IndexExistsOperation = IndexExistsOperation;\n/** @internal */\nvar IndexInformationOperation = /*#__PURE__*/function (_operation_1$Abstract3) {\n  _inherits(IndexInformationOperation, _operation_1$Abstract3);\n  function IndexInformationOperation(db, name, options) {\n    var _this8;\n    _classCallCheck(this, IndexInformationOperation);\n    _this8 = _possibleConstructorReturn(this, _getPrototypeOf(IndexInformationOperation).call(this, options));\n    _this8.options = options !== null && options !== void 0 ? options : {};\n    _this8.db = db;\n    _this8.name = name;\n    return _this8;\n  }\n  _createClass(IndexInformationOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var db = this.db;\n      var name = this.name;\n      (0, common_functions_1.indexInformation)(db, name, _objectSpread({}, this.options, {\n        readPreference: this.readPreference,\n        session: session\n      }), callback);\n    }\n  }]);\n  return IndexInformationOperation;\n}(operation_1.AbstractOperation);\nexports.IndexInformationOperation = IndexInformationOperation;\n(0, operation_1.defineAspects)(ListIndexesOperation, [operation_1.Aspect.READ_OPERATION, operation_1.Aspect.RETRYABLE, operation_1.Aspect.CURSOR_CREATING]);\n(0, operation_1.defineAspects)(CreateIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(CreateIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(EnsureIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexOperation, [operation_1.Aspect.WRITE_OPERATION]);\n(0, operation_1.defineAspects)(DropIndexesOperation, [operation_1.Aspect.WRITE_OPERATION]);","map":null,"metadata":{},"sourceType":"script"}