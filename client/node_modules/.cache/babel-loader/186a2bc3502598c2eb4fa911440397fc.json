{"ast":null,"code":"\"use strict\";\n\nvar _objectSpread = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/objectSpread\");\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Collection = void 0;\nvar bson_1 = require(\"./bson\");\nvar ordered_1 = require(\"./bulk/ordered\");\nvar unordered_1 = require(\"./bulk/unordered\");\nvar change_stream_1 = require(\"./change_stream\");\nvar aggregation_cursor_1 = require(\"./cursor/aggregation_cursor\");\nvar find_cursor_1 = require(\"./cursor/find_cursor\");\nvar list_indexes_cursor_1 = require(\"./cursor/list_indexes_cursor\");\nvar error_1 = require(\"./error\");\nvar bulk_write_1 = require(\"./operations/bulk_write\");\nvar count_1 = require(\"./operations/count\");\nvar count_documents_1 = require(\"./operations/count_documents\");\nvar delete_1 = require(\"./operations/delete\");\nvar distinct_1 = require(\"./operations/distinct\");\nvar drop_1 = require(\"./operations/drop\");\nvar estimated_document_count_1 = require(\"./operations/estimated_document_count\");\nvar execute_operation_1 = require(\"./operations/execute_operation\");\nvar find_and_modify_1 = require(\"./operations/find_and_modify\");\nvar indexes_1 = require(\"./operations/indexes\");\nvar insert_1 = require(\"./operations/insert\");\nvar is_capped_1 = require(\"./operations/is_capped\");\nvar map_reduce_1 = require(\"./operations/map_reduce\");\nvar options_operation_1 = require(\"./operations/options_operation\");\nvar rename_1 = require(\"./operations/rename\");\nvar stats_1 = require(\"./operations/stats\");\nvar update_1 = require(\"./operations/update\");\nvar read_concern_1 = require(\"./read_concern\");\nvar read_preference_1 = require(\"./read_preference\");\nvar utils_1 = require(\"./utils\");\nvar write_concern_1 = require(\"./write_concern\");\n/**\n * The **Collection** class is an internal class that embodies a MongoDB collection\n * allowing for insert/update/remove/find and other command operation on that MongoDB collection.\n *\n * **COLLECTION Cannot directly be instantiated**\n * @public\n *\n * @example\n * ```js\n * const MongoClient = require('mongodb').MongoClient;\n * const test = require('assert');\n * // Connection url\n * const url = 'mongodb://localhost:27017';\n * // Database Name\n * const dbName = 'test';\n * // Connect using MongoClient\n * MongoClient.connect(url, function(err, client) {\n *   // Create a collection we want to drop later\n *   const col = client.db(dbName).collection('createIndexExample1');\n *   // Show that duplicate records got dropped\n *   col.find({}).toArray(function(err, items) {\n *     expect(err).to.not.exist;\n *     test.equal(4, items.length);\n *     client.close();\n *   });\n * });\n * ```\n */\nvar Collection = /*#__PURE__*/function () {\n  /**\n   * Create a new Collection instance\n   * @internal\n   */\n  function Collection(db, name, options) {\n    _classCallCheck(this, Collection);\n    var _a, _b;\n    (0, utils_1.checkCollectionName)(name);\n    // Internal state\n    this.s = {\n      db: db,\n      options: options,\n      namespace: new utils_1.MongoDBNamespace(db.databaseName, name),\n      pkFactory: (_b = (_a = db.options) === null || _a === void 0 ? void 0 : _a.pkFactory) !== null && _b !== void 0 ? _b : utils_1.DEFAULT_PK_FACTORY,\n      readPreference: read_preference_1.ReadPreference.fromOptions(options),\n      bsonOptions: (0, bson_1.resolveBSONOptions)(options, db),\n      readConcern: read_concern_1.ReadConcern.fromOptions(options),\n      writeConcern: write_concern_1.WriteConcern.fromOptions(options)\n    };\n  }\n  /**\n   * The name of the database this collection belongs to\n   */\n  _createClass(Collection, [{\n    key: \"insertOne\",\n    value: function insertOne(doc, options, callback) {\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      // CSFLE passes in { w: 'majority' } to ensure the lib works in both 3.x and 4.x\n      // we support that option style here only\n      if (options && Reflect.get(options, 'w')) {\n        options.writeConcern = write_concern_1.WriteConcern.fromOptions(Reflect.get(options, 'w'));\n      }\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertOneOperation(this, doc, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"insertMany\",\n    value: function insertMany(docs, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options ? Object.assign({}, options) : {\n        ordered: true\n      };\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new insert_1.InsertManyOperation(this, docs, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"bulkWrite\",\n    value: function bulkWrite(operations, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options || {\n        ordered: true\n      };\n      if (!Array.isArray(operations)) {\n        throw new error_1.MongoInvalidArgumentError('Argument \"operations\" must be an array of documents');\n      }\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new bulk_write_1.BulkWriteOperation(this, operations, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"updateOne\",\n    value: function updateOne(filter, update, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateOneOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"replaceOne\",\n    value: function replaceOne(filter, replacement, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.ReplaceOneOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"updateMany\",\n    value: function updateMany(filter, update, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new update_1.UpdateManyOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"deleteOne\",\n    value: function deleteOne(filter, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteOneOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"deleteMany\",\n    value: function deleteMany(filter, options, callback) {\n      if (filter == null) {\n        filter = {};\n        options = {};\n        callback = undefined;\n      } else if (typeof filter === 'function') {\n        callback = filter;\n        filter = {};\n        options = {};\n      } else if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new delete_1.DeleteManyOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"rename\",\n    value: function rename(newName, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      // Intentionally, we do not inherit options from parent for this operation.\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new rename_1.RenameOperation(this, newName, _objectSpread({}, options, {\n        readPreference: read_preference_1.ReadPreference.PRIMARY\n      })), callback);\n    }\n  }, {\n    key: \"drop\",\n    value: function drop(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new drop_1.DropCollectionOperation(this.s.db, this.collectionName, options), callback);\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(filter, options, callback) {\n      if (callback != null && typeof callback !== 'function') {\n        throw new error_1.MongoInvalidArgumentError('Third parameter to `findOne()` must be a callback or undefined');\n      }\n      if (typeof filter === 'function') {\n        callback = filter;\n        filter = {};\n        options = {};\n      }\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n      var finalFilter = filter !== null && filter !== void 0 ? filter : {};\n      var finalOptions = options !== null && options !== void 0 ? options : {};\n      return this.find(finalFilter, finalOptions).limit(-1).batchSize(1).next(callback);\n    }\n  }, {\n    key: \"find\",\n    value: function find(filter, options) {\n      if (arguments.length > 2) {\n        throw new error_1.MongoInvalidArgumentError('Method \"collection.find()\" accepts at most two arguments');\n      }\n      if (typeof options === 'function') {\n        throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n      }\n      return new find_cursor_1.FindCursor(this.s.db.s.client, this.s.namespace, filter, (0, utils_1.resolveOptions)(this, options));\n    }\n  }, {\n    key: \"options\",\n    value: function options(_options, callback) {\n      if (typeof _options === 'function') callback = _options, _options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new options_operation_1.OptionsOperation(this, (0, utils_1.resolveOptions)(this, _options)), callback);\n    }\n  }, {\n    key: \"isCapped\",\n    value: function isCapped(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new is_capped_1.IsCappedOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"createIndex\",\n    value: function createIndex(indexSpec, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexOperation(this, this.collectionName, indexSpec, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"createIndexes\",\n    value: function createIndexes(indexSpecs, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options ? Object.assign({}, options) : {};\n      if (typeof options.maxTimeMS !== 'number') delete options.maxTimeMS;\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.CreateIndexesOperation(this, this.collectionName, indexSpecs, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"dropIndex\",\n    value: function dropIndex(indexName, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = (0, utils_1.resolveOptions)(this, options);\n      // Run only against primary\n      options.readPreference = read_preference_1.ReadPreference.primary;\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexOperation(this, indexName, options), callback);\n    }\n  }, {\n    key: \"dropIndexes\",\n    value: function dropIndexes(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.DropIndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    /**\n     * Get the list of all indexes information for the collection.\n     *\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"listIndexes\",\n    value: function listIndexes(options) {\n      return new list_indexes_cursor_1.ListIndexesCursor(this, (0, utils_1.resolveOptions)(this, options));\n    }\n  }, {\n    key: \"indexExists\",\n    value: function indexExists(indexes, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexExistsOperation(this, indexes, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"indexInformation\",\n    value: function indexInformation(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexInformationOperation(this.s.db, this.collectionName, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"estimatedDocumentCount\",\n    value: function estimatedDocumentCount(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new estimated_document_count_1.EstimatedDocumentCountOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"countDocuments\",\n    value: function countDocuments(filter, options, callback) {\n      if (filter == null) {\n        filter = {}, options = {}, callback = undefined;\n      } else if (typeof filter === 'function') {\n        callback = filter, filter = {}, options = {};\n      } else {\n        if (arguments.length === 2) {\n          if (typeof options === 'function') callback = options, options = {};\n        }\n      }\n      filter !== null && filter !== void 0 ? filter : filter = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_documents_1.CountDocumentsOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    } // Implementation\n  }, {\n    key: \"distinct\",\n    value: function distinct(key, filter, options, callback) {\n      if (typeof filter === 'function') {\n        callback = filter, filter = {}, options = {};\n      } else {\n        if (arguments.length === 3 && typeof options === 'function') {\n          callback = options, options = {};\n        }\n      }\n      filter !== null && filter !== void 0 ? filter : filter = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new distinct_1.DistinctOperation(this, key, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"indexes\",\n    value: function indexes(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new indexes_1.IndexesOperation(this, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"stats\",\n    value: function stats(options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new stats_1.CollStatsOperation(this, options), callback);\n    }\n  }, {\n    key: \"findOneAndDelete\",\n    value: function findOneAndDelete(filter, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndDeleteOperation(this, filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"findOneAndReplace\",\n    value: function findOneAndReplace(filter, replacement, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndReplaceOperation(this, filter, replacement, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"findOneAndUpdate\",\n    value: function findOneAndUpdate(filter, update, options, callback) {\n      if (typeof options === 'function') callback = options, options = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new find_and_modify_1.FindOneAndUpdateOperation(this, filter, update, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    /**\n     * Execute an aggregation framework pipeline against the collection, needs MongoDB \\>= 2.2\n     *\n     * @param pipeline - An array of aggregation pipelines to execute\n     * @param options - Optional settings for the command\n     */\n  }, {\n    key: \"aggregate\",\n    value: function aggregate() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 ? arguments[1] : undefined;\n      if (arguments.length > 2) {\n        throw new error_1.MongoInvalidArgumentError('Method \"collection.aggregate()\" accepts at most two arguments');\n      }\n      if (!Array.isArray(pipeline)) {\n        throw new error_1.MongoInvalidArgumentError('Argument \"pipeline\" must be an array of aggregation stages');\n      }\n      if (typeof options === 'function') {\n        throw new error_1.MongoInvalidArgumentError('Argument \"options\" must not be function');\n      }\n      return new aggregation_cursor_1.AggregationCursor(this.s.db.s.client, this.s.namespace, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Create a new Change Stream, watching for new changes (insertions, updates, replacements, deletions, and invalidations) in this collection.\n     *\n     * @remarks\n     * watch() accepts two generic arguments for distinct usecases:\n     * - The first is to override the schema that may be defined for this specific collection\n     * - The second is to override the shape of the change stream document entirely, if it is not provided the type will default to ChangeStreamDocument of the first argument\n     * @example\n     * By just providing the first argument I can type the change to be `ChangeStreamDocument<{ _id: number }>`\n     * ```ts\n     * collection.watch<{ _id: number }>()\n     *   .on('change', change => console.log(change._id.toFixed(4)));\n     * ```\n     *\n     * @example\n     * Passing a second argument provides a way to reflect the type changes caused by an advanced pipeline.\n     * Here, we are using a pipeline to have MongoDB filter for insert changes only and add a comment.\n     * No need start from scratch on the ChangeStreamInsertDocument type!\n     * By using an intersection we can save time and ensure defaults remain the same type!\n     * ```ts\n     * collection\n     *   .watch<Schema, ChangeStreamInsertDocument<Schema> & { comment: string }>([\n     *     { $addFields: { comment: 'big changes' } },\n     *     { $match: { operationType: 'insert' } }\n     *   ])\n     *   .on('change', change => {\n     *     change.comment.startsWith('big');\n     *     change.operationType === 'insert';\n     *     // No need to narrow in code because the generics did that for us!\n     *     expectType<Schema>(change.fullDocument);\n     *   });\n     * ```\n     *\n     * @param pipeline - An array of {@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/|aggregation pipeline stages} through which to pass change stream documents. This allows for filtering (using $match) and manipulating the change stream documents.\n     * @param options - Optional settings for the command\n     * @typeParam TLocal - Type of the data being detected by the change stream\n     * @typeParam TChange - Type of the whole change stream document emitted\n     */\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      var pipeline = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Allow optionally not specifying a pipeline\n      if (!Array.isArray(pipeline)) {\n        options = pipeline;\n        pipeline = [];\n      }\n      return new change_stream_1.ChangeStream(this, pipeline, (0, utils_1.resolveOptions)(this, options));\n    }\n  }, {\n    key: \"mapReduce\",\n    value: function mapReduce(map, reduce, options, callback) {\n      (0, utils_1.emitWarningOnce)('collection.mapReduce is deprecated. Use the aggregation pipeline instead. Visit https://docs.mongodb.com/manual/reference/map-reduce-to-aggregation-pipeline for more information on how to translate map-reduce operations to the aggregation pipeline.');\n      if ('function' === typeof options) callback = options, options = {};\n      // Out must always be defined (make sure we don't break weirdly on pre 1.8+ servers)\n      // TODO NODE-3339: Figure out if this is still necessary given we no longer officially support pre-1.8\n      if ((options === null || options === void 0 ? void 0 : options.out) == null) {\n        throw new error_1.MongoInvalidArgumentError('Option \"out\" must be defined, see mongodb docs for possible values');\n      }\n      if ('function' === typeof map) {\n        map = map.toString();\n      }\n      if ('function' === typeof reduce) {\n        reduce = reduce.toString();\n      }\n      if ('function' === typeof options.finalize) {\n        options.finalize = options.finalize.toString();\n      }\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new map_reduce_1.MapReduceOperation(this, map, reduce, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n    /**\n     * Initiate an Out of order batch write operation. All operations will be buffered into insert/update/remove commands executed out of order.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n  }, {\n    key: \"initializeUnorderedBulkOp\",\n    value: function initializeUnorderedBulkOp(options) {\n      return new unordered_1.UnorderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    }\n    /**\n     * Initiate an In order bulk write operation. Operations will be serially executed in the order they are added, creating a new operation for each switch in types.\n     *\n     * @throws MongoNotConnectedError\n     * @remarks\n     * **NOTE:** MongoClient must be connected prior to calling this method due to a known limitation in this legacy implemenation.\n     * However, `collection.bulkWrite()` provides an equivalent API that does not require prior connecting.\n     */\n  }, {\n    key: \"initializeOrderedBulkOp\",\n    value: function initializeOrderedBulkOp(options) {\n      return new ordered_1.OrderedBulkOperation(this, (0, utils_1.resolveOptions)(this, options));\n    } /** Get the db scoped logger */\n  }, {\n    key: \"getLogger\",\n    value: function getLogger() {\n      return this.s.db.s.logger;\n    }\n  }, {\n    key: \"insert\",\n    /**\n     * Inserts a single document or a an array of documents into MongoDB. If documents passed in do not contain the **_id** field,\n     * one will be added to each of the documents missing it by the driver, mutating the document. This behavior\n     * can be overridden by setting the **forceServerObjectId** flag.\n     *\n     * @deprecated Use insertOne, insertMany or bulkWrite instead.\n     * @param docs - The documents to insert\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n    value: function insert(docs, options, callback) {\n      (0, utils_1.emitWarningOnce)('collection.insert is deprecated. Use insertOne, insertMany or bulkWrite instead.');\n      if (typeof options === 'function') callback = options, options = {};\n      options = options || {\n        ordered: false\n      };\n      docs = !Array.isArray(docs) ? [docs] : docs;\n      if (options.keepGoing === true) {\n        options.ordered = false;\n      }\n      return this.insertMany(docs, options, callback);\n    }\n    /**\n     * Updates documents.\n     *\n     * @deprecated use updateOne, updateMany or bulkWrite\n     * @param filter - The filter for the update operation.\n     * @param update - The update operations to be applied to the documents\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n  }, {\n    key: \"update\",\n    value: function update(filter, _update, options, callback) {\n      (0, utils_1.emitWarningOnce)('collection.update is deprecated. Use updateOne, updateMany, or bulkWrite instead.');\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n      return this.updateMany(filter, _update, options, callback);\n    }\n    /**\n     * Remove documents.\n     *\n     * @deprecated use deleteOne, deleteMany or bulkWrite\n     * @param filter - The filter for the remove operation.\n     * @param options - Optional settings for the command\n     * @param callback - An optional callback, a Promise will be returned if none is provided\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(filter, options, callback) {\n      (0, utils_1.emitWarningOnce)('collection.remove is deprecated. Use deleteOne, deleteMany, or bulkWrite instead.');\n      if (typeof options === 'function') callback = options, options = {};\n      options = options !== null && options !== void 0 ? options : {};\n      return this.deleteMany(filter, options, callback);\n    }\n  }, {\n    key: \"count\",\n    value: function count(filter, options, callback) {\n      if (typeof filter === 'function') {\n        callback = filter, filter = {}, options = {};\n      } else {\n        if (typeof options === 'function') callback = options, options = {};\n      }\n      filter !== null && filter !== void 0 ? filter : filter = {};\n      return (0, execute_operation_1.executeOperation)(this.s.db.s.client, new count_1.CountOperation(utils_1.MongoDBNamespace.fromString(this.namespace), filter, (0, utils_1.resolveOptions)(this, options)), callback);\n    }\n  }, {\n    key: \"dbName\",\n    get: function get() {\n      return this.s.namespace.db;\n    }\n    /**\n     * The name of this collection\n     */\n  }, {\n    key: \"collectionName\",\n    get: function get() {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return this.s.namespace.collection;\n    }\n    /**\n     * The namespace of this collection, in the format `${this.dbName}.${this.collectionName}`\n     */\n  }, {\n    key: \"namespace\",\n    get: function get() {\n      return this.s.namespace.toString();\n    }\n    /**\n     * The current readConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"readConcern\",\n    get: function get() {\n      if (this.s.readConcern == null) {\n        return this.s.db.readConcern;\n      }\n      return this.s.readConcern;\n    }\n    /**\n     * The current readPreference of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"readPreference\",\n    get: function get() {\n      if (this.s.readPreference == null) {\n        return this.s.db.readPreference;\n      }\n      return this.s.readPreference;\n    }\n  }, {\n    key: \"bsonOptions\",\n    get: function get() {\n      return this.s.bsonOptions;\n    }\n    /**\n     * The current writeConcern of the collection. If not explicitly defined for\n     * this collection, will be inherited from the parent DB\n     */\n  }, {\n    key: \"writeConcern\",\n    get: function get() {\n      if (this.s.writeConcern == null) {\n        return this.s.db.writeConcern;\n      }\n      return this.s.writeConcern;\n    } /** The current index hint for the collection */\n  }, {\n    key: \"hint\",\n    get: function get() {\n      return this.s.collectionHint;\n    },\n    set: function set(v) {\n      this.s.collectionHint = (0, utils_1.normalizeHintField)(v);\n    }\n  }, {\n    key: \"logger\",\n    get: function get() {\n      return this.s.db.s.logger;\n    }\n  }]);\n  return Collection;\n}();\nexports.Collection = Collection;","map":null,"metadata":{},"sourceType":"script"}