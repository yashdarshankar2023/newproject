{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveCname = exports.performGSSAPICanonicalizeHostName = exports.GSSAPI = exports.GSSAPICanonicalizationValue = void 0;\nvar dns = require(\"dns\");\nvar deps_1 = require(\"../../deps\");\nvar error_1 = require(\"../../error\");\nvar utils_1 = require(\"../../utils\");\nvar auth_provider_1 = require(\"./auth_provider\");\n/** @public */\nexports.GSSAPICanonicalizationValue = Object.freeze({\n  on: true,\n  off: false,\n  none: 'none',\n  forward: 'forward',\n  forwardAndReverse: 'forwardAndReverse'\n});\nvar GSSAPI = /*#__PURE__*/function (_auth_provider_1$Auth) {\n  _inherits(GSSAPI, _auth_provider_1$Auth);\n  function GSSAPI() {\n    _classCallCheck(this, GSSAPI);\n    return _possibleConstructorReturn(this, _getPrototypeOf(GSSAPI).apply(this, arguments));\n  }\n  _createClass(GSSAPI, [{\n    key: \"auth\",\n    value: function auth(authContext, callback) {\n      var connection = authContext.connection,\n        credentials = authContext.credentials;\n      if (credentials == null) return callback(new error_1.MongoMissingCredentialsError('Credentials required for GSSAPI authentication'));\n      var username = credentials.username;\n      function externalCommand(command, cb) {\n        return connection.command((0, utils_1.ns)('$external.$cmd'), command, undefined, cb);\n      }\n      makeKerberosClient(authContext, function (err, client) {\n        if (err) return callback(err);\n        if (client == null) return callback(new error_1.MongoMissingDependencyError('GSSAPI client missing'));\n        client.step('', function (err, payload) {\n          if (err) return callback(err);\n          externalCommand(saslStart(payload), function (err, result) {\n            if (err) return callback(err);\n            if (result == null) return callback();\n            negotiate(client, 10, result.payload, function (err, payload) {\n              if (err) return callback(err);\n              externalCommand(saslContinue(payload, result.conversationId), function (err, result) {\n                if (err) return callback(err);\n                if (result == null) return callback();\n                finalize(client, username, result.payload, function (err, payload) {\n                  if (err) return callback(err);\n                  externalCommand({\n                    saslContinue: 1,\n                    conversationId: result.conversationId,\n                    payload: payload\n                  }, function (err, result) {\n                    if (err) return callback(err);\n                    callback(undefined, result);\n                  });\n                });\n              });\n            });\n          });\n        });\n      });\n    }\n  }]);\n  return GSSAPI;\n}(auth_provider_1.AuthProvider);\nexports.GSSAPI = GSSAPI;\nfunction makeKerberosClient(authContext, callback) {\n  var _a;\n  var hostAddress = authContext.options.hostAddress;\n  var credentials = authContext.credentials;\n  if (!hostAddress || typeof hostAddress.host !== 'string' || !credentials) {\n    return callback(new error_1.MongoInvalidArgumentError('Connection must have host and port and credentials defined.'));\n  }\n  if ('kModuleError' in deps_1.Kerberos) {\n    return callback(deps_1.Kerberos['kModuleError']);\n  }\n  var initializeClient = deps_1.Kerberos.initializeClient;\n  var username = credentials.username,\n    password = credentials.password;\n  var mechanismProperties = credentials.mechanismProperties;\n  var serviceName = (_a = mechanismProperties.SERVICE_NAME) !== null && _a !== void 0 ? _a : 'mongodb';\n  performGSSAPICanonicalizeHostName(hostAddress.host, mechanismProperties, function (err, host) {\n    var _a;\n    if (err) return callback(err);\n    var initOptions = {};\n    if (password != null) {\n      Object.assign(initOptions, {\n        user: username,\n        password: password\n      });\n    }\n    var spnHost = (_a = mechanismProperties.SERVICE_HOST) !== null && _a !== void 0 ? _a : host;\n    var spn = \"\".concat(serviceName).concat(process.platform === 'win32' ? '/' : '@').concat(spnHost);\n    if ('SERVICE_REALM' in mechanismProperties) {\n      spn = \"\".concat(spn, \"@\").concat(mechanismProperties.SERVICE_REALM);\n    }\n    initializeClient(spn, initOptions, function (err, client) {\n      // TODO(NODE-3483)\n      if (err) return callback(new error_1.MongoRuntimeError(err));\n      callback(undefined, client);\n    });\n  });\n}\nfunction saslStart(payload) {\n  return {\n    saslStart: 1,\n    mechanism: 'GSSAPI',\n    payload: payload,\n    autoAuthorize: 1\n  };\n}\nfunction saslContinue(payload, conversationId) {\n  return {\n    saslContinue: 1,\n    conversationId: conversationId,\n    payload: payload\n  };\n}\nfunction negotiate(client, retries, payload, callback) {\n  client.step(payload, function (err, response) {\n    // Retries exhausted, raise error\n    if (err && retries === 0) return callback(err);\n    // Adjust number of retries and call step again\n    if (err) return negotiate(client, retries - 1, payload, callback);\n    // Return the payload\n    callback(undefined, response || '');\n  });\n}\nfunction finalize(client, user, payload, callback) {\n  // GSS Client Unwrap\n  client.unwrap(payload, function (err, response) {\n    if (err) return callback(err);\n    // Wrap the response\n    client.wrap(response || '', {\n      user: user\n    }, function (err, wrapped) {\n      if (err) return callback(err);\n      // Return the payload\n      callback(undefined, wrapped);\n    });\n  });\n}\nfunction performGSSAPICanonicalizeHostName(host, mechanismProperties, callback) {\n  var mode = mechanismProperties.CANONICALIZE_HOST_NAME;\n  if (!mode || mode === exports.GSSAPICanonicalizationValue.none) {\n    return callback(undefined, host);\n  }\n  // If forward and reverse or true\n  if (mode === exports.GSSAPICanonicalizationValue.on || mode === exports.GSSAPICanonicalizationValue.forwardAndReverse) {\n    // Perform the lookup of the ip address.\n    dns.lookup(host, function (error, address) {\n      // No ip found, return the error.\n      if (error) return callback(error);\n      // Perform a reverse ptr lookup on the ip address.\n      dns.resolvePtr(address, function (err, results) {\n        // This can error as ptr records may not exist for all ips. In this case\n        // fallback to a cname lookup as dns.lookup() does not return the\n        // cname.\n        if (err) {\n          return resolveCname(host, callback);\n        }\n        // If the ptr did not error but had no results, return the host.\n        callback(undefined, results.length > 0 ? results[0] : host);\n      });\n    });\n  } else {\n    // The case for forward is just to resolve the cname as dns.lookup()\n    // will not return it.\n    resolveCname(host, callback);\n  }\n}\nexports.performGSSAPICanonicalizeHostName = performGSSAPICanonicalizeHostName;\nfunction resolveCname(host, callback) {\n  // Attempt to resolve the host name\n  dns.resolveCname(host, function (err, r) {\n    if (err) return callback(undefined, host);\n    // Get the first resolve host id\n    if (r.length > 0) {\n      return callback(undefined, r[0]);\n    }\n    callback(undefined, host);\n  });\n}\nexports.resolveCname = resolveCname;","map":null,"metadata":{},"sourceType":"script"}