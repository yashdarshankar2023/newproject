{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BinMsg = exports.Msg = exports.Response = exports.Query = void 0;\nvar BSON = require(\"../bson\");\nvar error_1 = require(\"../error\");\nvar read_preference_1 = require(\"../read_preference\");\nvar utils_1 = require(\"../utils\");\nvar constants_1 = require(\"./wire_protocol/constants\");\n// Incrementing request id\nvar _requestId = 0;\n// Query flags\nvar OPTS_TAILABLE_CURSOR = 2;\nvar OPTS_SECONDARY = 4;\nvar OPTS_OPLOG_REPLAY = 8;\nvar OPTS_NO_CURSOR_TIMEOUT = 16;\nvar OPTS_AWAIT_DATA = 32;\nvar OPTS_EXHAUST = 64;\nvar OPTS_PARTIAL = 128;\n// Response flags\nvar CURSOR_NOT_FOUND = 1;\nvar QUERY_FAILURE = 2;\nvar SHARD_CONFIG_STALE = 4;\nvar AWAIT_CAPABLE = 8;\n/**************************************************************\n * QUERY\n **************************************************************/\n/** @internal */\nvar Query = /*#__PURE__*/function () {\n  function Query(ns, query, options) {\n    _classCallCheck(this, Query);\n    // Basic options needed to be passed in\n    // TODO(NODE-3483): Replace with MongoCommandError\n    if (ns == null) throw new error_1.MongoRuntimeError('Namespace must be specified for query');\n    // TODO(NODE-3483): Replace with MongoCommandError\n    if (query == null) throw new error_1.MongoRuntimeError('A query document must be specified for query');\n    // Validate that we are not passing 0x00 in the collection name\n    if (ns.indexOf('\\x00') !== -1) {\n      // TODO(NODE-3483): Use MongoNamespace static method\n      throw new error_1.MongoRuntimeError('Namespace cannot contain a null character');\n    }\n    // Basic options\n    this.ns = ns;\n    this.query = query;\n    // Additional options\n    this.numberToSkip = options.numberToSkip || 0;\n    this.numberToReturn = options.numberToReturn || 0;\n    this.returnFieldSelector = options.returnFieldSelector || undefined;\n    this.requestId = Query.getRequestId();\n    // special case for pre-3.2 find commands, delete ASAP\n    this.pre32Limit = options.pre32Limit;\n    // Serialization option\n    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;\n    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    this.batchSize = this.numberToReturn;\n    // Flags\n    this.tailable = false;\n    this.secondaryOk = typeof options.secondaryOk === 'boolean' ? options.secondaryOk : false;\n    this.oplogReplay = false;\n    this.noCursorTimeout = false;\n    this.awaitData = false;\n    this.exhaust = false;\n    this.partial = false;\n  }\n  /** Assign next request Id. */\n  _createClass(Query, [{\n    key: \"incRequestId\",\n    value: function incRequestId() {\n      this.requestId = _requestId++;\n    } /** Peek next request Id. */\n  }, {\n    key: \"nextRequestId\",\n    value: function nextRequestId() {\n      return _requestId + 1;\n    } /** Increment then return next request Id. */\n  }, {\n    key: \"toBin\",\n    // Uses a single allocated buffer for the process, avoiding multiple memory allocations\n    value: function toBin() {\n      var buffers = [];\n      var projection = null;\n      // Set up the flags\n      var flags = 0;\n      if (this.tailable) {\n        flags |= OPTS_TAILABLE_CURSOR;\n      }\n      if (this.secondaryOk) {\n        flags |= OPTS_SECONDARY;\n      }\n      if (this.oplogReplay) {\n        flags |= OPTS_OPLOG_REPLAY;\n      }\n      if (this.noCursorTimeout) {\n        flags |= OPTS_NO_CURSOR_TIMEOUT;\n      }\n      if (this.awaitData) {\n        flags |= OPTS_AWAIT_DATA;\n      }\n      if (this.exhaust) {\n        flags |= OPTS_EXHAUST;\n      }\n      if (this.partial) {\n        flags |= OPTS_PARTIAL;\n      }\n      // If batchSize is different to this.numberToReturn\n      if (this.batchSize !== this.numberToReturn) this.numberToReturn = this.batchSize;\n      // Allocate write protocol header buffer\n      var header = Buffer.alloc(4 * 4 +\n      // Header\n      4 +\n      // Flags\n      Buffer.byteLength(this.ns) + 1 +\n      // namespace\n      4 +\n      // numberToSkip\n      4 // numberToReturn\n      );\n      // Add header to buffers\n      buffers.push(header);\n      // Serialize the query\n      var query = BSON.serialize(this.query, {\n        checkKeys: this.checkKeys,\n        serializeFunctions: this.serializeFunctions,\n        ignoreUndefined: this.ignoreUndefined\n      });\n      // Add query document\n      buffers.push(query);\n      if (this.returnFieldSelector && Object.keys(this.returnFieldSelector).length > 0) {\n        // Serialize the projection document\n        projection = BSON.serialize(this.returnFieldSelector, {\n          checkKeys: this.checkKeys,\n          serializeFunctions: this.serializeFunctions,\n          ignoreUndefined: this.ignoreUndefined\n        });\n        // Add projection document\n        buffers.push(projection);\n      }\n      // Total message size\n      var totalLength = header.length + query.length + (projection ? projection.length : 0);\n      // Set up the index\n      var index = 4;\n      // Write total document length\n      header[3] = totalLength >> 24 & 0xff;\n      header[2] = totalLength >> 16 & 0xff;\n      header[1] = totalLength >> 8 & 0xff;\n      header[0] = totalLength & 0xff;\n      // Write header information requestId\n      header[index + 3] = this.requestId >> 24 & 0xff;\n      header[index + 2] = this.requestId >> 16 & 0xff;\n      header[index + 1] = this.requestId >> 8 & 0xff;\n      header[index] = this.requestId & 0xff;\n      index = index + 4;\n      // Write header information responseTo\n      header[index + 3] = 0 >> 24 & 0xff;\n      header[index + 2] = 0 >> 16 & 0xff;\n      header[index + 1] = 0 >> 8 & 0xff;\n      header[index] = 0 & 0xff;\n      index = index + 4;\n      // Write header information OP_QUERY\n      header[index + 3] = constants_1.OP_QUERY >> 24 & 0xff;\n      header[index + 2] = constants_1.OP_QUERY >> 16 & 0xff;\n      header[index + 1] = constants_1.OP_QUERY >> 8 & 0xff;\n      header[index] = constants_1.OP_QUERY & 0xff;\n      index = index + 4;\n      // Write header information flags\n      header[index + 3] = flags >> 24 & 0xff;\n      header[index + 2] = flags >> 16 & 0xff;\n      header[index + 1] = flags >> 8 & 0xff;\n      header[index] = flags & 0xff;\n      index = index + 4;\n      // Write collection name\n      index = index + header.write(this.ns, index, 'utf8') + 1;\n      header[index - 1] = 0;\n      // Write header information flags numberToSkip\n      header[index + 3] = this.numberToSkip >> 24 & 0xff;\n      header[index + 2] = this.numberToSkip >> 16 & 0xff;\n      header[index + 1] = this.numberToSkip >> 8 & 0xff;\n      header[index] = this.numberToSkip & 0xff;\n      index = index + 4;\n      // Write header information flags numberToReturn\n      header[index + 3] = this.numberToReturn >> 24 & 0xff;\n      header[index + 2] = this.numberToReturn >> 16 & 0xff;\n      header[index + 1] = this.numberToReturn >> 8 & 0xff;\n      header[index] = this.numberToReturn & 0xff;\n      index = index + 4;\n      // Return the buffers\n      return buffers;\n    }\n  }], [{\n    key: \"getRequestId\",\n    value: function getRequestId() {\n      return ++_requestId;\n    }\n  }]);\n  return Query;\n}();\nexports.Query = Query;\n/** @internal */\nvar Response = /*#__PURE__*/function () {\n  function Response(message, msgHeader, msgBody, opts) {\n    _classCallCheck(this, Response);\n    this.documents = new Array(0);\n    this.parsed = false;\n    this.raw = message;\n    this.data = msgBody;\n    this.opts = opts !== null && opts !== void 0 ? opts : {\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      bsonRegExp: false\n    };\n    // Read the message header\n    this.length = msgHeader.length;\n    this.requestId = msgHeader.requestId;\n    this.responseTo = msgHeader.responseTo;\n    this.opCode = msgHeader.opCode;\n    this.fromCompressed = msgHeader.fromCompressed;\n    // Flag values\n    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;\n    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;\n    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;\n    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;\n  }\n  _createClass(Response, [{\n    key: \"isParsed\",\n    value: function isParsed() {\n      return this.parsed;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(options) {\n      var _a, _b, _c, _d;\n      // Don't parse again if not needed\n      if (this.parsed) return;\n      options = options !== null && options !== void 0 ? options : {};\n      // Allow the return of raw documents instead of parsing\n      var raw = options.raw || false;\n      var documentsReturnedIn = options.documentsReturnedIn || null;\n      var promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;\n      var promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;\n      var promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;\n      var bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;\n      var bsonSize;\n      // Set up the options\n      var _options = {\n        promoteLongs: promoteLongs,\n        promoteValues: promoteValues,\n        promoteBuffers: promoteBuffers,\n        bsonRegExp: bsonRegExp\n      };\n      // Position within OP_REPLY at which documents start\n      // (See https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#wire-op-reply)\n      this.index = 20;\n      // Read the message body\n      this.responseFlags = this.data.readInt32LE(0);\n      this.cursorId = new BSON.Long(this.data.readInt32LE(4), this.data.readInt32LE(8));\n      this.startingFrom = this.data.readInt32LE(12);\n      this.numberReturned = this.data.readInt32LE(16);\n      // Preallocate document array\n      this.documents = new Array(this.numberReturned);\n      this.cursorNotFound = (this.responseFlags & CURSOR_NOT_FOUND) !== 0;\n      this.queryFailure = (this.responseFlags & QUERY_FAILURE) !== 0;\n      this.shardConfigStale = (this.responseFlags & SHARD_CONFIG_STALE) !== 0;\n      this.awaitCapable = (this.responseFlags & AWAIT_CAPABLE) !== 0;\n      // Parse Body\n      for (var i = 0; i < this.numberReturned; i++) {\n        bsonSize = this.data[this.index] | this.data[this.index + 1] << 8 | this.data[this.index + 2] << 16 | this.data[this.index + 3] << 24;\n        // If we have raw results specified slice the return document\n        if (raw) {\n          this.documents[i] = this.data.slice(this.index, this.index + bsonSize);\n        } else {\n          this.documents[i] = BSON.deserialize(this.data.slice(this.index, this.index + bsonSize), _options);\n        }\n        // Adjust the index\n        this.index = this.index + bsonSize;\n      }\n      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {\n        var fieldsAsRaw = {};\n        fieldsAsRaw[documentsReturnedIn] = true;\n        _options.fieldsAsRaw = fieldsAsRaw;\n        var doc = BSON.deserialize(this.documents[0], _options);\n        this.documents = [doc];\n      }\n      // Set parsed\n      this.parsed = true;\n    }\n  }]);\n  return Response;\n}();\nexports.Response = Response;\n// Implementation of OP_MSG spec:\n// https://github.com/mongodb/specifications/blob/master/source/message/OP_MSG.rst\n//\n// struct Section {\n//   uint8 payloadType;\n//   union payload {\n//       document  document; // payloadType == 0\n//       struct sequence { // payloadType == 1\n//           int32      size;\n//           cstring    identifier;\n//           document*  documents;\n//       };\n//   };\n// };\n// struct OP_MSG {\n//   struct MsgHeader {\n//       int32  messageLength;\n//       int32  requestID;\n//       int32  responseTo;\n//       int32  opCode = 2013;\n//   };\n//   uint32      flagBits;\n//   Section+    sections;\n//   [uint32     checksum;]\n// };\n// Msg Flags\nvar OPTS_CHECKSUM_PRESENT = 1;\nvar OPTS_MORE_TO_COME = 2;\nvar OPTS_EXHAUST_ALLOWED = 1 << 16;\n/** @internal */\nvar Msg = /*#__PURE__*/function () {\n  function Msg(ns, command, options) {\n    _classCallCheck(this, Msg);\n    // Basic options needed to be passed in\n    if (command == null) throw new error_1.MongoInvalidArgumentError('Query document must be specified for query');\n    // Basic options\n    this.ns = ns;\n    this.command = command;\n    this.command.$db = (0, utils_1.databaseNamespace)(ns);\n    if (options.readPreference && options.readPreference.mode !== read_preference_1.ReadPreference.PRIMARY) {\n      this.command.$readPreference = options.readPreference.toJSON();\n    }\n    // Ensure empty options\n    this.options = options !== null && options !== void 0 ? options : {};\n    // Additional options\n    this.requestId = options.requestId ? options.requestId : Msg.getRequestId();\n    // Serialization option\n    this.serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    this.ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : false;\n    this.checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    this.maxBsonSize = options.maxBsonSize || 1024 * 1024 * 16;\n    // flags\n    this.checksumPresent = false;\n    this.moreToCome = options.moreToCome || false;\n    this.exhaustAllowed = typeof options.exhaustAllowed === 'boolean' ? options.exhaustAllowed : false;\n  }\n  _createClass(Msg, [{\n    key: \"toBin\",\n    value: function toBin() {\n      var buffers = [];\n      var flags = 0;\n      if (this.checksumPresent) {\n        flags |= OPTS_CHECKSUM_PRESENT;\n      }\n      if (this.moreToCome) {\n        flags |= OPTS_MORE_TO_COME;\n      }\n      if (this.exhaustAllowed) {\n        flags |= OPTS_EXHAUST_ALLOWED;\n      }\n      var header = Buffer.alloc(4 * 4 +\n      // Header\n      4 // Flags\n      );\n\n      buffers.push(header);\n      var totalLength = header.length;\n      var command = this.command;\n      totalLength += this.makeDocumentSegment(buffers, command);\n      header.writeInt32LE(totalLength, 0); // messageLength\n      header.writeInt32LE(this.requestId, 4); // requestID\n      header.writeInt32LE(0, 8); // responseTo\n      header.writeInt32LE(constants_1.OP_MSG, 12); // opCode\n      header.writeUInt32LE(flags, 16); // flags\n      return buffers;\n    }\n  }, {\n    key: \"makeDocumentSegment\",\n    value: function makeDocumentSegment(buffers, document) {\n      var payloadTypeBuffer = Buffer.alloc(1);\n      payloadTypeBuffer[0] = 0;\n      var documentBuffer = this.serializeBson(document);\n      buffers.push(payloadTypeBuffer);\n      buffers.push(documentBuffer);\n      return payloadTypeBuffer.length + documentBuffer.length;\n    }\n  }, {\n    key: \"serializeBson\",\n    value: function serializeBson(document) {\n      return BSON.serialize(document, {\n        checkKeys: this.checkKeys,\n        serializeFunctions: this.serializeFunctions,\n        ignoreUndefined: this.ignoreUndefined\n      });\n    }\n  }], [{\n    key: \"getRequestId\",\n    value: function getRequestId() {\n      _requestId = _requestId + 1 & 0x7fffffff;\n      return _requestId;\n    }\n  }]);\n  return Msg;\n}();\nexports.Msg = Msg;\n/** @internal */\nvar BinMsg = /*#__PURE__*/function () {\n  function BinMsg(message, msgHeader, msgBody, opts) {\n    _classCallCheck(this, BinMsg);\n    this.parsed = false;\n    this.raw = message;\n    this.data = msgBody;\n    this.opts = opts !== null && opts !== void 0 ? opts : {\n      promoteLongs: true,\n      promoteValues: true,\n      promoteBuffers: false,\n      bsonRegExp: false\n    };\n    // Read the message header\n    this.length = msgHeader.length;\n    this.requestId = msgHeader.requestId;\n    this.responseTo = msgHeader.responseTo;\n    this.opCode = msgHeader.opCode;\n    this.fromCompressed = msgHeader.fromCompressed;\n    // Read response flags\n    this.responseFlags = msgBody.readInt32LE(0);\n    this.checksumPresent = (this.responseFlags & OPTS_CHECKSUM_PRESENT) !== 0;\n    this.moreToCome = (this.responseFlags & OPTS_MORE_TO_COME) !== 0;\n    this.exhaustAllowed = (this.responseFlags & OPTS_EXHAUST_ALLOWED) !== 0;\n    this.promoteLongs = typeof this.opts.promoteLongs === 'boolean' ? this.opts.promoteLongs : true;\n    this.promoteValues = typeof this.opts.promoteValues === 'boolean' ? this.opts.promoteValues : true;\n    this.promoteBuffers = typeof this.opts.promoteBuffers === 'boolean' ? this.opts.promoteBuffers : false;\n    this.bsonRegExp = typeof this.opts.bsonRegExp === 'boolean' ? this.opts.bsonRegExp : false;\n    this.documents = [];\n  }\n  _createClass(BinMsg, [{\n    key: \"isParsed\",\n    value: function isParsed() {\n      return this.parsed;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(options) {\n      var _a, _b, _c, _d;\n      // Don't parse again if not needed\n      if (this.parsed) return;\n      options = options !== null && options !== void 0 ? options : {};\n      this.index = 4;\n      // Allow the return of raw documents instead of parsing\n      var raw = options.raw || false;\n      var documentsReturnedIn = options.documentsReturnedIn || null;\n      var promoteLongs = (_a = options.promoteLongs) !== null && _a !== void 0 ? _a : this.opts.promoteLongs;\n      var promoteValues = (_b = options.promoteValues) !== null && _b !== void 0 ? _b : this.opts.promoteValues;\n      var promoteBuffers = (_c = options.promoteBuffers) !== null && _c !== void 0 ? _c : this.opts.promoteBuffers;\n      var bsonRegExp = (_d = options.bsonRegExp) !== null && _d !== void 0 ? _d : this.opts.bsonRegExp;\n      var validation = this.parseBsonSerializationOptions(options);\n      // Set up the options\n      var bsonOptions = {\n        promoteLongs: promoteLongs,\n        promoteValues: promoteValues,\n        promoteBuffers: promoteBuffers,\n        bsonRegExp: bsonRegExp,\n        validation: validation\n        // Due to the strictness of the BSON libraries validation option we need this cast\n      };\n\n      while (this.index < this.data.length) {\n        var payloadType = this.data.readUInt8(this.index++);\n        if (payloadType === 0) {\n          var bsonSize = this.data.readUInt32LE(this.index);\n          var bin = this.data.slice(this.index, this.index + bsonSize);\n          this.documents.push(raw ? bin : BSON.deserialize(bin, bsonOptions));\n          this.index += bsonSize;\n        } else if (payloadType === 1) {\n          // It was decided that no driver makes use of payload type 1\n          // TODO(NODE-3483): Replace with MongoDeprecationError\n          throw new error_1.MongoRuntimeError('OP_MSG Payload Type 1 detected unsupported protocol');\n        }\n      }\n      if (this.documents.length === 1 && documentsReturnedIn != null && raw) {\n        var fieldsAsRaw = {};\n        fieldsAsRaw[documentsReturnedIn] = true;\n        bsonOptions.fieldsAsRaw = fieldsAsRaw;\n        var doc = BSON.deserialize(this.documents[0], bsonOptions);\n        this.documents = [doc];\n      }\n      this.parsed = true;\n    }\n  }, {\n    key: \"parseBsonSerializationOptions\",\n    value: function parseBsonSerializationOptions(_ref) {\n      var enableUtf8Validation = _ref.enableUtf8Validation;\n      if (enableUtf8Validation === false) {\n        return {\n          utf8: false\n        };\n      }\n      return {\n        utf8: {\n          writeErrors: false\n        }\n      };\n    }\n  }]);\n  return BinMsg;\n}();\nexports.BinMsg = BinMsg;","map":null,"metadata":{},"sourceType":"script"}