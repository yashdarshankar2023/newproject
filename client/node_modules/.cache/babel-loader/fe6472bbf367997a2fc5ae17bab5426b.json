{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/toConsumableArray\");\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\nvar tr46 = require(\"tr46\");\nvar infra = require(\"./infra\");\nvar _require = require(\"./encoding\"),\n  utf8DecodeWithoutBOM = _require.utf8DecodeWithoutBOM;\nvar _require2 = require(\"./percent-encoding\"),\n  percentDecodeString = _require2.percentDecodeString,\n  utf8PercentEncodeCodePoint = _require2.utf8PercentEncodeCodePoint,\n  utf8PercentEncodeString = _require2.utf8PercentEncodeString,\n  isC0ControlPercentEncode = _require2.isC0ControlPercentEncode,\n  isFragmentPercentEncode = _require2.isFragmentPercentEncode,\n  isQueryPercentEncode = _require2.isQueryPercentEncode,\n  isSpecialQueryPercentEncode = _require2.isSpecialQueryPercentEncode,\n  isPathPercentEncode = _require2.isPathPercentEncode,\n  isUserinfoPercentEncode = _require2.isUserinfoPercentEncode;\nfunction p(char) {\n  return char.codePointAt(0);\n}\nvar specialSchemes = {\n  ftp: 21,\n  file: null,\n  http: 80,\n  https: 443,\n  ws: 80,\n  wss: 443\n};\nvar failure = Symbol(\"failure\");\nfunction countSymbols(str) {\n  return _toConsumableArray(str).length;\n}\nfunction at(input, idx) {\n  var c = input[idx];\n  return isNaN(c) ? undefined : String.fromCodePoint(c);\n}\nfunction isSingleDot(buffer) {\n  return buffer === \".\" || buffer.toLowerCase() === \"%2e\";\n}\nfunction isDoubleDot(buffer) {\n  buffer = buffer.toLowerCase();\n  return buffer === \"..\" || buffer === \"%2e.\" || buffer === \".%2e\" || buffer === \"%2e%2e\";\n}\nfunction isWindowsDriveLetterCodePoints(cp1, cp2) {\n  return infra.isASCIIAlpha(cp1) && (cp2 === p(\":\") || cp2 === p(\"|\"));\n}\nfunction isWindowsDriveLetterString(string) {\n  return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && (string[1] === \":\" || string[1] === \"|\");\n}\nfunction isNormalizedWindowsDriveLetterString(string) {\n  return string.length === 2 && infra.isASCIIAlpha(string.codePointAt(0)) && string[1] === \":\";\n}\nfunction containsForbiddenHostCodePoint(string) {\n  return string.search(/\\0|\\t|\\n|\\r| |#|%|\\/|:|<|>|\\?|@|\\[|\\\\|\\]|\\^|\\|/) !== -1;\n}\nfunction containsForbiddenHostCodePointExcludingPercent(string) {\n  return string.search(/\\0|\\t|\\n|\\r| |#|\\/|:|<|>|\\?|@|\\[|\\\\|\\]|\\^|\\|/) !== -1;\n}\nfunction isSpecialScheme(scheme) {\n  return specialSchemes[scheme] !== undefined;\n}\nfunction isSpecial(url) {\n  return isSpecialScheme(url.scheme);\n}\nfunction isNotSpecial(url) {\n  return !isSpecialScheme(url.scheme);\n}\nfunction defaultPort(scheme) {\n  return specialSchemes[scheme];\n}\nfunction parseIPv4Number(input) {\n  if (input === \"\") {\n    return failure;\n  }\n  var R = 10;\n  if (input.length >= 2 && input.charAt(0) === \"0\" && input.charAt(1).toLowerCase() === \"x\") {\n    input = input.substring(2);\n    R = 16;\n  } else if (input.length >= 2 && input.charAt(0) === \"0\") {\n    input = input.substring(1);\n    R = 8;\n  }\n  if (input === \"\") {\n    return 0;\n  }\n  var regex = /(?:(?![0-7])[\\s\\S])/;\n  if (R === 10) {\n    regex = /(?:(?![0-9])[\\s\\S])/;\n  }\n  if (R === 16) {\n    regex = /(?:(?![0-9A-Fa-f])[\\s\\S])/;\n  }\n  if (regex.test(input)) {\n    return failure;\n  }\n  return parseInt(input, R);\n}\nfunction parseIPv4(input) {\n  var parts = input.split(\".\");\n  if (parts[parts.length - 1] === \"\") {\n    if (parts.length > 1) {\n      parts.pop();\n    }\n  }\n  if (parts.length > 4) {\n    return failure;\n  }\n  var numbers = [];\n  var _iterator = _createForOfIteratorHelper(parts),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var part = _step.value;\n      var _n = parseIPv4Number(part);\n      if (_n === failure) {\n        return failure;\n      }\n      numbers.push(_n);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  for (var i = 0; i < numbers.length - 1; ++i) {\n    if (numbers[i] > 255) {\n      return failure;\n    }\n  }\n  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {\n    return failure;\n  }\n  var ipv4 = numbers.pop();\n  var counter = 0;\n  for (var _i = 0, _numbers = numbers; _i < _numbers.length; _i++) {\n    var n = _numbers[_i];\n    ipv4 += n * Math.pow(256, 3 - counter);\n    ++counter;\n  }\n  return ipv4;\n}\nfunction serializeIPv4(address) {\n  var output = \"\";\n  var n = address;\n  for (var i = 1; i <= 4; ++i) {\n    output = String(n % 256) + output;\n    if (i !== 4) {\n      output = \".\".concat(output);\n    }\n    n = Math.floor(n / 256);\n  }\n  return output;\n}\nfunction parseIPv6(input) {\n  var address = [0, 0, 0, 0, 0, 0, 0, 0];\n  var pieceIndex = 0;\n  var compress = null;\n  var pointer = 0;\n  input = Array.from(input, function (c) {\n    return c.codePointAt(0);\n  });\n  if (input[pointer] === p(\":\")) {\n    if (input[pointer + 1] !== p(\":\")) {\n      return failure;\n    }\n    pointer += 2;\n    ++pieceIndex;\n    compress = pieceIndex;\n  }\n  while (pointer < input.length) {\n    if (pieceIndex === 8) {\n      return failure;\n    }\n    if (input[pointer] === p(\":\")) {\n      if (compress !== null) {\n        return failure;\n      }\n      ++pointer;\n      ++pieceIndex;\n      compress = pieceIndex;\n      continue;\n    }\n    var value = 0;\n    var length = 0;\n    while (length < 4 && infra.isASCIIHex(input[pointer])) {\n      value = value * 0x10 + parseInt(at(input, pointer), 16);\n      ++pointer;\n      ++length;\n    }\n    if (input[pointer] === p(\".\")) {\n      if (length === 0) {\n        return failure;\n      }\n      pointer -= length;\n      if (pieceIndex > 6) {\n        return failure;\n      }\n      var numbersSeen = 0;\n      while (input[pointer] !== undefined) {\n        var ipv4Piece = null;\n        if (numbersSeen > 0) {\n          if (input[pointer] === p(\".\") && numbersSeen < 4) {\n            ++pointer;\n          } else {\n            return failure;\n          }\n        }\n        if (!infra.isASCIIDigit(input[pointer])) {\n          return failure;\n        }\n        while (infra.isASCIIDigit(input[pointer])) {\n          var number = parseInt(at(input, pointer));\n          if (ipv4Piece === null) {\n            ipv4Piece = number;\n          } else if (ipv4Piece === 0) {\n            return failure;\n          } else {\n            ipv4Piece = ipv4Piece * 10 + number;\n          }\n          if (ipv4Piece > 255) {\n            return failure;\n          }\n          ++pointer;\n        }\n        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;\n        ++numbersSeen;\n        if (numbersSeen === 2 || numbersSeen === 4) {\n          ++pieceIndex;\n        }\n      }\n      if (numbersSeen !== 4) {\n        return failure;\n      }\n      break;\n    } else if (input[pointer] === p(\":\")) {\n      ++pointer;\n      if (input[pointer] === undefined) {\n        return failure;\n      }\n    } else if (input[pointer] !== undefined) {\n      return failure;\n    }\n    address[pieceIndex] = value;\n    ++pieceIndex;\n  }\n  if (compress !== null) {\n    var swaps = pieceIndex - compress;\n    pieceIndex = 7;\n    while (pieceIndex !== 0 && swaps > 0) {\n      var temp = address[compress + swaps - 1];\n      address[compress + swaps - 1] = address[pieceIndex];\n      address[pieceIndex] = temp;\n      --pieceIndex;\n      --swaps;\n    }\n  } else if (compress === null && pieceIndex !== 8) {\n    return failure;\n  }\n  return address;\n}\nfunction serializeIPv6(address) {\n  var output = \"\";\n  var compress = findLongestZeroSequence(address);\n  var ignore0 = false;\n  for (var pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {\n    if (ignore0 && address[pieceIndex] === 0) {\n      continue;\n    } else if (ignore0) {\n      ignore0 = false;\n    }\n    if (compress === pieceIndex) {\n      var separator = pieceIndex === 0 ? \"::\" : \":\";\n      output += separator;\n      ignore0 = true;\n      continue;\n    }\n    output += address[pieceIndex].toString(16);\n    if (pieceIndex !== 7) {\n      output += \":\";\n    }\n  }\n  return output;\n}\nfunction parseHost(input) {\n  var isNotSpecialArg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (input[0] === \"[\") {\n    if (input[input.length - 1] !== \"]\") {\n      return failure;\n    }\n    return parseIPv6(input.substring(1, input.length - 1));\n  }\n  if (isNotSpecialArg) {\n    return parseOpaqueHost(input);\n  }\n  var domain = utf8DecodeWithoutBOM(percentDecodeString(input));\n  var asciiDomain = domainToASCII(domain);\n  if (asciiDomain === failure) {\n    return failure;\n  }\n  if (containsForbiddenHostCodePoint(asciiDomain)) {\n    return failure;\n  }\n  if (endsInANumber(asciiDomain)) {\n    return parseIPv4(asciiDomain);\n  }\n  return asciiDomain;\n}\nfunction endsInANumber(input) {\n  var parts = input.split(\".\");\n  if (parts[parts.length - 1] === \"\") {\n    if (parts.length === 1) {\n      return false;\n    }\n    parts.pop();\n  }\n  var last = parts[parts.length - 1];\n  if (parseIPv4Number(last) !== failure) {\n    return true;\n  }\n  if (/^[0-9]+$/.test(last)) {\n    return true;\n  }\n  return false;\n}\nfunction parseOpaqueHost(input) {\n  if (containsForbiddenHostCodePointExcludingPercent(input)) {\n    return failure;\n  }\n  return utf8PercentEncodeString(input, isC0ControlPercentEncode);\n}\nfunction findLongestZeroSequence(arr) {\n  var maxIdx = null;\n  var maxLen = 1; // only find elements > 1\n  var currStart = null;\n  var currLen = 0;\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] !== 0) {\n      if (currLen > maxLen) {\n        maxIdx = currStart;\n        maxLen = currLen;\n      }\n      currStart = null;\n      currLen = 0;\n    } else {\n      if (currStart === null) {\n        currStart = i;\n      }\n      ++currLen;\n    }\n  }\n\n  // if trailing zeros\n  if (currLen > maxLen) {\n    return currStart;\n  }\n  return maxIdx;\n}\nfunction serializeHost(host) {\n  if (typeof host === \"number\") {\n    return serializeIPv4(host);\n  }\n\n  // IPv6 serializer\n  if (host instanceof Array) {\n    return \"[\".concat(serializeIPv6(host), \"]\");\n  }\n  return host;\n}\nfunction domainToASCII(domain) {\n  var beStrict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var result = tr46.toASCII(domain, {\n    checkBidi: true,\n    checkHyphens: false,\n    checkJoiners: true,\n    useSTD3ASCIIRules: beStrict,\n    verifyDNSLength: beStrict\n  });\n  if (result === null || result === \"\") {\n    return failure;\n  }\n  return result;\n}\nfunction trimControlChars(url) {\n  return url.replace(/^[\\0- ]+|[\\0- ]+$/g, \"\");\n}\nfunction trimTabAndNewline(url) {\n  return url.replace(/\\t|\\n|\\r/g, \"\");\n}\nfunction shortenPath(url) {\n  var path = url.path;\n  if (path.length === 0) {\n    return;\n  }\n  if (url.scheme === \"file\" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {\n    return;\n  }\n  path.pop();\n}\nfunction includesCredentials(url) {\n  return url.username !== \"\" || url.password !== \"\";\n}\nfunction cannotHaveAUsernamePasswordPort(url) {\n  return url.host === null || url.host === \"\" || hasAnOpaquePath(url) || url.scheme === \"file\";\n}\nfunction hasAnOpaquePath(url) {\n  return typeof url.path === \"string\";\n}\nfunction isNormalizedWindowsDriveLetter(string) {\n  return /^[A-Za-z]:$/.test(string);\n}\nfunction URLStateMachine(input, base, encodingOverride, url, stateOverride) {\n  this.pointer = 0;\n  this.input = input;\n  this.base = base || null;\n  this.encodingOverride = encodingOverride || \"utf-8\";\n  this.stateOverride = stateOverride;\n  this.url = url;\n  this.failure = false;\n  this.parseError = false;\n  if (!this.url) {\n    this.url = {\n      scheme: \"\",\n      username: \"\",\n      password: \"\",\n      host: null,\n      port: null,\n      path: [],\n      query: null,\n      fragment: null\n    };\n    var _res = trimControlChars(this.input);\n    if (_res !== this.input) {\n      this.parseError = true;\n    }\n    this.input = _res;\n  }\n  var res = trimTabAndNewline(this.input);\n  if (res !== this.input) {\n    this.parseError = true;\n  }\n  this.input = res;\n  this.state = stateOverride || \"scheme start\";\n  this.buffer = \"\";\n  this.atFlag = false;\n  this.arrFlag = false;\n  this.passwordTokenSeenFlag = false;\n  this.input = Array.from(this.input, function (c) {\n    return c.codePointAt(0);\n  });\n  for (; this.pointer <= this.input.length; ++this.pointer) {\n    var c = this.input[this.pointer];\n    var cStr = isNaN(c) ? undefined : String.fromCodePoint(c);\n\n    // exec state machine\n    var ret = this[\"parse \".concat(this.state)](c, cStr);\n    if (!ret) {\n      break; // terminate algorithm\n    } else if (ret === failure) {\n      this.failure = true;\n      break;\n    }\n  }\n}\nURLStateMachine.prototype[\"parse scheme start\"] = function parseSchemeStart(c, cStr) {\n  if (infra.isASCIIAlpha(c)) {\n    this.buffer += cStr.toLowerCase();\n    this.state = \"scheme\";\n  } else if (!this.stateOverride) {\n    this.state = \"no scheme\";\n    --this.pointer;\n  } else {\n    this.parseError = true;\n    return failure;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse scheme\"] = function parseScheme(c, cStr) {\n  if (infra.isASCIIAlphanumeric(c) || c === p(\"+\") || c === p(\"-\") || c === p(\".\")) {\n    this.buffer += cStr.toLowerCase();\n  } else if (c === p(\":\")) {\n    if (this.stateOverride) {\n      if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {\n        return false;\n      }\n      if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {\n        return false;\n      }\n      if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === \"file\") {\n        return false;\n      }\n      if (this.url.scheme === \"file\" && this.url.host === \"\") {\n        return false;\n      }\n    }\n    this.url.scheme = this.buffer;\n    if (this.stateOverride) {\n      if (this.url.port === defaultPort(this.url.scheme)) {\n        this.url.port = null;\n      }\n      return false;\n    }\n    this.buffer = \"\";\n    if (this.url.scheme === \"file\") {\n      if (this.input[this.pointer + 1] !== p(\"/\") || this.input[this.pointer + 2] !== p(\"/\")) {\n        this.parseError = true;\n      }\n      this.state = \"file\";\n    } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {\n      this.state = \"special relative or authority\";\n    } else if (isSpecial(this.url)) {\n      this.state = \"special authority slashes\";\n    } else if (this.input[this.pointer + 1] === p(\"/\")) {\n      this.state = \"path or authority\";\n      ++this.pointer;\n    } else {\n      this.url.path = \"\";\n      this.state = \"opaque path\";\n    }\n  } else if (!this.stateOverride) {\n    this.buffer = \"\";\n    this.state = \"no scheme\";\n    this.pointer = -1;\n  } else {\n    this.parseError = true;\n    return failure;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse no scheme\"] = function parseNoScheme(c) {\n  if (this.base === null || hasAnOpaquePath(this.base) && c !== p(\"#\")) {\n    return failure;\n  } else if (hasAnOpaquePath(this.base) && c === p(\"#\")) {\n    this.url.scheme = this.base.scheme;\n    this.url.path = this.base.path;\n    this.url.query = this.base.query;\n    this.url.fragment = \"\";\n    this.state = \"fragment\";\n  } else if (this.base.scheme === \"file\") {\n    this.state = \"file\";\n    --this.pointer;\n  } else {\n    this.state = \"relative\";\n    --this.pointer;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse special relative or authority\"] = function parseSpecialRelativeOrAuthority(c) {\n  if (c === p(\"/\") && this.input[this.pointer + 1] === p(\"/\")) {\n    this.state = \"special authority ignore slashes\";\n    ++this.pointer;\n  } else {\n    this.parseError = true;\n    this.state = \"relative\";\n    --this.pointer;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse path or authority\"] = function parsePathOrAuthority(c) {\n  if (c === p(\"/\")) {\n    this.state = \"authority\";\n  } else {\n    this.state = \"path\";\n    --this.pointer;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse relative\"] = function parseRelative(c) {\n  this.url.scheme = this.base.scheme;\n  if (c === p(\"/\")) {\n    this.state = \"relative slash\";\n  } else if (isSpecial(this.url) && c === p(\"\\\\\")) {\n    this.parseError = true;\n    this.state = \"relative slash\";\n  } else {\n    this.url.username = this.base.username;\n    this.url.password = this.base.password;\n    this.url.host = this.base.host;\n    this.url.port = this.base.port;\n    this.url.path = this.base.path.slice();\n    this.url.query = this.base.query;\n    if (c === p(\"?\")) {\n      this.url.query = \"\";\n      this.state = \"query\";\n    } else if (c === p(\"#\")) {\n      this.url.fragment = \"\";\n      this.state = \"fragment\";\n    } else if (!isNaN(c)) {\n      this.url.query = null;\n      this.url.path.pop();\n      this.state = \"path\";\n      --this.pointer;\n    }\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse relative slash\"] = function parseRelativeSlash(c) {\n  if (isSpecial(this.url) && (c === p(\"/\") || c === p(\"\\\\\"))) {\n    if (c === p(\"\\\\\")) {\n      this.parseError = true;\n    }\n    this.state = \"special authority ignore slashes\";\n  } else if (c === p(\"/\")) {\n    this.state = \"authority\";\n  } else {\n    this.url.username = this.base.username;\n    this.url.password = this.base.password;\n    this.url.host = this.base.host;\n    this.url.port = this.base.port;\n    this.state = \"path\";\n    --this.pointer;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse special authority slashes\"] = function parseSpecialAuthoritySlashes(c) {\n  if (c === p(\"/\") && this.input[this.pointer + 1] === p(\"/\")) {\n    this.state = \"special authority ignore slashes\";\n    ++this.pointer;\n  } else {\n    this.parseError = true;\n    this.state = \"special authority ignore slashes\";\n    --this.pointer;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse special authority ignore slashes\"] = function parseSpecialAuthorityIgnoreSlashes(c) {\n  if (c !== p(\"/\") && c !== p(\"\\\\\")) {\n    this.state = \"authority\";\n    --this.pointer;\n  } else {\n    this.parseError = true;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse authority\"] = function parseAuthority(c, cStr) {\n  if (c === p(\"@\")) {\n    this.parseError = true;\n    if (this.atFlag) {\n      this.buffer = \"%40\".concat(this.buffer);\n    }\n    this.atFlag = true;\n\n    // careful, this is based on buffer and has its own pointer (this.pointer != pointer) and inner chars\n    var len = countSymbols(this.buffer);\n    for (var pointer = 0; pointer < len; ++pointer) {\n      var codePoint = this.buffer.codePointAt(pointer);\n      if (codePoint === p(\":\") && !this.passwordTokenSeenFlag) {\n        this.passwordTokenSeenFlag = true;\n        continue;\n      }\n      var encodedCodePoints = utf8PercentEncodeCodePoint(codePoint, isUserinfoPercentEncode);\n      if (this.passwordTokenSeenFlag) {\n        this.url.password += encodedCodePoints;\n      } else {\n        this.url.username += encodedCodePoints;\n      }\n    }\n    this.buffer = \"\";\n  } else if (isNaN(c) || c === p(\"/\") || c === p(\"?\") || c === p(\"#\") || isSpecial(this.url) && c === p(\"\\\\\")) {\n    if (this.atFlag && this.buffer === \"\") {\n      this.parseError = true;\n      return failure;\n    }\n    this.pointer -= countSymbols(this.buffer) + 1;\n    this.buffer = \"\";\n    this.state = \"host\";\n  } else {\n    this.buffer += cStr;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse hostname\"] = URLStateMachine.prototype[\"parse host\"] = function parseHostName(c, cStr) {\n  if (this.stateOverride && this.url.scheme === \"file\") {\n    --this.pointer;\n    this.state = \"file host\";\n  } else if (c === p(\":\") && !this.arrFlag) {\n    if (this.buffer === \"\") {\n      this.parseError = true;\n      return failure;\n    }\n    if (this.stateOverride === \"hostname\") {\n      return false;\n    }\n    var host = parseHost(this.buffer, isNotSpecial(this.url));\n    if (host === failure) {\n      return failure;\n    }\n    this.url.host = host;\n    this.buffer = \"\";\n    this.state = \"port\";\n  } else if (isNaN(c) || c === p(\"/\") || c === p(\"?\") || c === p(\"#\") || isSpecial(this.url) && c === p(\"\\\\\")) {\n    --this.pointer;\n    if (isSpecial(this.url) && this.buffer === \"\") {\n      this.parseError = true;\n      return failure;\n    } else if (this.stateOverride && this.buffer === \"\" && (includesCredentials(this.url) || this.url.port !== null)) {\n      this.parseError = true;\n      return false;\n    }\n    var _host = parseHost(this.buffer, isNotSpecial(this.url));\n    if (_host === failure) {\n      return failure;\n    }\n    this.url.host = _host;\n    this.buffer = \"\";\n    this.state = \"path start\";\n    if (this.stateOverride) {\n      return false;\n    }\n  } else {\n    if (c === p(\"[\")) {\n      this.arrFlag = true;\n    } else if (c === p(\"]\")) {\n      this.arrFlag = false;\n    }\n    this.buffer += cStr;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse port\"] = function parsePort(c, cStr) {\n  if (infra.isASCIIDigit(c)) {\n    this.buffer += cStr;\n  } else if (isNaN(c) || c === p(\"/\") || c === p(\"?\") || c === p(\"#\") || isSpecial(this.url) && c === p(\"\\\\\") || this.stateOverride) {\n    if (this.buffer !== \"\") {\n      var port = parseInt(this.buffer);\n      if (port > Math.pow(2, 16) - 1) {\n        this.parseError = true;\n        return failure;\n      }\n      this.url.port = port === defaultPort(this.url.scheme) ? null : port;\n      this.buffer = \"\";\n    }\n    if (this.stateOverride) {\n      return false;\n    }\n    this.state = \"path start\";\n    --this.pointer;\n  } else {\n    this.parseError = true;\n    return failure;\n  }\n  return true;\n};\nvar fileOtherwiseCodePoints = new Set([p(\"/\"), p(\"\\\\\"), p(\"?\"), p(\"#\")]);\nfunction startsWithWindowsDriveLetter(input, pointer) {\n  var length = input.length - pointer;\n  return length >= 2 && isWindowsDriveLetterCodePoints(input[pointer], input[pointer + 1]) && (length === 2 || fileOtherwiseCodePoints.has(input[pointer + 2]));\n}\nURLStateMachine.prototype[\"parse file\"] = function parseFile(c) {\n  this.url.scheme = \"file\";\n  this.url.host = \"\";\n  if (c === p(\"/\") || c === p(\"\\\\\")) {\n    if (c === p(\"\\\\\")) {\n      this.parseError = true;\n    }\n    this.state = \"file slash\";\n  } else if (this.base !== null && this.base.scheme === \"file\") {\n    this.url.host = this.base.host;\n    this.url.path = this.base.path.slice();\n    this.url.query = this.base.query;\n    if (c === p(\"?\")) {\n      this.url.query = \"\";\n      this.state = \"query\";\n    } else if (c === p(\"#\")) {\n      this.url.fragment = \"\";\n      this.state = \"fragment\";\n    } else if (!isNaN(c)) {\n      this.url.query = null;\n      if (!startsWithWindowsDriveLetter(this.input, this.pointer)) {\n        shortenPath(this.url);\n      } else {\n        this.parseError = true;\n        this.url.path = [];\n      }\n      this.state = \"path\";\n      --this.pointer;\n    }\n  } else {\n    this.state = \"path\";\n    --this.pointer;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse file slash\"] = function parseFileSlash(c) {\n  if (c === p(\"/\") || c === p(\"\\\\\")) {\n    if (c === p(\"\\\\\")) {\n      this.parseError = true;\n    }\n    this.state = \"file host\";\n  } else {\n    if (this.base !== null && this.base.scheme === \"file\") {\n      if (!startsWithWindowsDriveLetter(this.input, this.pointer) && isNormalizedWindowsDriveLetterString(this.base.path[0])) {\n        this.url.path.push(this.base.path[0]);\n      }\n      this.url.host = this.base.host;\n    }\n    this.state = \"path\";\n    --this.pointer;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse file host\"] = function parseFileHost(c, cStr) {\n  if (isNaN(c) || c === p(\"/\") || c === p(\"\\\\\") || c === p(\"?\") || c === p(\"#\")) {\n    --this.pointer;\n    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {\n      this.parseError = true;\n      this.state = \"path\";\n    } else if (this.buffer === \"\") {\n      this.url.host = \"\";\n      if (this.stateOverride) {\n        return false;\n      }\n      this.state = \"path start\";\n    } else {\n      var host = parseHost(this.buffer, isNotSpecial(this.url));\n      if (host === failure) {\n        return failure;\n      }\n      if (host === \"localhost\") {\n        host = \"\";\n      }\n      this.url.host = host;\n      if (this.stateOverride) {\n        return false;\n      }\n      this.buffer = \"\";\n      this.state = \"path start\";\n    }\n  } else {\n    this.buffer += cStr;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse path start\"] = function parsePathStart(c) {\n  if (isSpecial(this.url)) {\n    if (c === p(\"\\\\\")) {\n      this.parseError = true;\n    }\n    this.state = \"path\";\n    if (c !== p(\"/\") && c !== p(\"\\\\\")) {\n      --this.pointer;\n    }\n  } else if (!this.stateOverride && c === p(\"?\")) {\n    this.url.query = \"\";\n    this.state = \"query\";\n  } else if (!this.stateOverride && c === p(\"#\")) {\n    this.url.fragment = \"\";\n    this.state = \"fragment\";\n  } else if (c !== undefined) {\n    this.state = \"path\";\n    if (c !== p(\"/\")) {\n      --this.pointer;\n    }\n  } else if (this.stateOverride && this.url.host === null) {\n    this.url.path.push(\"\");\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse path\"] = function parsePath(c) {\n  if (isNaN(c) || c === p(\"/\") || isSpecial(this.url) && c === p(\"\\\\\") || !this.stateOverride && (c === p(\"?\") || c === p(\"#\"))) {\n    if (isSpecial(this.url) && c === p(\"\\\\\")) {\n      this.parseError = true;\n    }\n    if (isDoubleDot(this.buffer)) {\n      shortenPath(this.url);\n      if (c !== p(\"/\") && !(isSpecial(this.url) && c === p(\"\\\\\"))) {\n        this.url.path.push(\"\");\n      }\n    } else if (isSingleDot(this.buffer) && c !== p(\"/\") && !(isSpecial(this.url) && c === p(\"\\\\\"))) {\n      this.url.path.push(\"\");\n    } else if (!isSingleDot(this.buffer)) {\n      if (this.url.scheme === \"file\" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {\n        this.buffer = \"\".concat(this.buffer[0], \":\");\n      }\n      this.url.path.push(this.buffer);\n    }\n    this.buffer = \"\";\n    if (c === p(\"?\")) {\n      this.url.query = \"\";\n      this.state = \"query\";\n    }\n    if (c === p(\"#\")) {\n      this.url.fragment = \"\";\n      this.state = \"fragment\";\n    }\n  } else {\n    // TODO: If c is not a URL code point and not \"%\", parse error.\n\n    if (c === p(\"%\") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\n      this.parseError = true;\n    }\n    this.buffer += utf8PercentEncodeCodePoint(c, isPathPercentEncode);\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse opaque path\"] = function parseOpaquePath(c) {\n  if (c === p(\"?\")) {\n    this.url.query = \"\";\n    this.state = \"query\";\n  } else if (c === p(\"#\")) {\n    this.url.fragment = \"\";\n    this.state = \"fragment\";\n  } else {\n    // TODO: Add: not a URL code point\n    if (!isNaN(c) && c !== p(\"%\")) {\n      this.parseError = true;\n    }\n    if (c === p(\"%\") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\n      this.parseError = true;\n    }\n    if (!isNaN(c)) {\n      this.url.path += utf8PercentEncodeCodePoint(c, isC0ControlPercentEncode);\n    }\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse query\"] = function parseQuery(c, cStr) {\n  if (!isSpecial(this.url) || this.url.scheme === \"ws\" || this.url.scheme === \"wss\") {\n    this.encodingOverride = \"utf-8\";\n  }\n  if (!this.stateOverride && c === p(\"#\") || isNaN(c)) {\n    var queryPercentEncodePredicate = isSpecial(this.url) ? isSpecialQueryPercentEncode : isQueryPercentEncode;\n    this.url.query += utf8PercentEncodeString(this.buffer, queryPercentEncodePredicate);\n    this.buffer = \"\";\n    if (c === p(\"#\")) {\n      this.url.fragment = \"\";\n      this.state = \"fragment\";\n    }\n  } else if (!isNaN(c)) {\n    // TODO: If c is not a URL code point and not \"%\", parse error.\n\n    if (c === p(\"%\") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\n      this.parseError = true;\n    }\n    this.buffer += cStr;\n  }\n  return true;\n};\nURLStateMachine.prototype[\"parse fragment\"] = function parseFragment(c) {\n  if (!isNaN(c)) {\n    // TODO: If c is not a URL code point and not \"%\", parse error.\n    if (c === p(\"%\") && (!infra.isASCIIHex(this.input[this.pointer + 1]) || !infra.isASCIIHex(this.input[this.pointer + 2]))) {\n      this.parseError = true;\n    }\n    this.url.fragment += utf8PercentEncodeCodePoint(c, isFragmentPercentEncode);\n  }\n  return true;\n};\nfunction serializeURL(url, excludeFragment) {\n  var output = \"\".concat(url.scheme, \":\");\n  if (url.host !== null) {\n    output += \"//\";\n    if (url.username !== \"\" || url.password !== \"\") {\n      output += url.username;\n      if (url.password !== \"\") {\n        output += \":\".concat(url.password);\n      }\n      output += \"@\";\n    }\n    output += serializeHost(url.host);\n    if (url.port !== null) {\n      output += \":\".concat(url.port);\n    }\n  }\n  if (url.host === null && !hasAnOpaquePath(url) && url.path.length > 1 && url.path[0] === \"\") {\n    output += \"/.\";\n  }\n  output += serializePath(url);\n  if (url.query !== null) {\n    output += \"?\".concat(url.query);\n  }\n  if (!excludeFragment && url.fragment !== null) {\n    output += \"#\".concat(url.fragment);\n  }\n  return output;\n}\nfunction serializeOrigin(tuple) {\n  var result = \"\".concat(tuple.scheme, \"://\");\n  result += serializeHost(tuple.host);\n  if (tuple.port !== null) {\n    result += \":\".concat(tuple.port);\n  }\n  return result;\n}\nfunction serializePath(url) {\n  if (hasAnOpaquePath(url)) {\n    return url.path;\n  }\n  var output = \"\";\n  var _iterator2 = _createForOfIteratorHelper(url.path),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var segment = _step2.value;\n      output += \"/\".concat(segment);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return output;\n}\nmodule.exports.serializeURL = serializeURL;\nmodule.exports.serializePath = serializePath;\nmodule.exports.serializeURLOrigin = function (url) {\n  // https://url.spec.whatwg.org/#concept-url-origin\n  switch (url.scheme) {\n    case \"blob\":\n      try {\n        return module.exports.serializeURLOrigin(module.exports.parseURL(serializePath(url)));\n      } catch (e) {\n        // serializing an opaque origin returns \"null\"\n        return \"null\";\n      }\n    case \"ftp\":\n    case \"http\":\n    case \"https\":\n    case \"ws\":\n    case \"wss\":\n      return serializeOrigin({\n        scheme: url.scheme,\n        host: url.host,\n        port: url.port\n      });\n    case \"file\":\n      // The spec says:\n      // > Unfortunate as it is, this is left as an exercise to the reader. When in doubt, return a new opaque origin.\n      // Browsers tested so far:\n      // - Chrome says \"file://\", but treats file: URLs as cross-origin for most (all?) purposes; see e.g.\n      //   https://bugs.chromium.org/p/chromium/issues/detail?id=37586\n      // - Firefox says \"null\", but treats file: URLs as same-origin sometimes based on directory stuff; see\n      //   https://developer.mozilla.org/en-US/docs/Archive/Misc_top_level/Same-origin_policy_for_file:_URIs\n      return \"null\";\n    default:\n      // serializing an opaque origin returns \"null\"\n      return \"null\";\n  }\n};\nmodule.exports.basicURLParse = function (input, options) {\n  if (options === undefined) {\n    options = {};\n  }\n  var usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);\n  if (usm.failure) {\n    return null;\n  }\n  return usm.url;\n};\nmodule.exports.setTheUsername = function (url, username) {\n  url.username = utf8PercentEncodeString(username, isUserinfoPercentEncode);\n};\nmodule.exports.setThePassword = function (url, password) {\n  url.password = utf8PercentEncodeString(password, isUserinfoPercentEncode);\n};\nmodule.exports.serializeHost = serializeHost;\nmodule.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;\nmodule.exports.hasAnOpaquePath = hasAnOpaquePath;\nmodule.exports.serializeInteger = function (integer) {\n  return String(integer);\n};\nmodule.exports.parseURL = function (input, options) {\n  if (options === undefined) {\n    options = {};\n  }\n\n  // We don't handle blobs, so this just delegates:\n  return module.exports.basicURLParse(input, {\n    baseURL: options.baseURL,\n    encodingOverride: options.encodingOverride\n  });\n};","map":null,"metadata":{},"sourceType":"script"}