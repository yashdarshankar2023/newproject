{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, \"throw\" === context.method) { if (delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method)) return ContinueSentinel; context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a 'throw' method\"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, \"constructor\", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocksClientError = exports.SocksClient = void 0;\nvar events_1 = require(\"events\");\nvar net = require(\"net\");\nvar ip = require(\"ip\");\nvar smart_buffer_1 = require(\"smart-buffer\");\nvar constants_1 = require(\"../common/constants\");\nvar helpers_1 = require(\"../common/helpers\");\nvar receivebuffer_1 = require(\"../common/receivebuffer\");\nvar util_1 = require(\"../common/util\");\nObject.defineProperty(exports, \"SocksClientError\", {\n  enumerable: true,\n  get: function get() {\n    return util_1.SocksClientError;\n  }\n});\nvar SocksClient = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(SocksClient, _events_1$EventEmitte);\n  function SocksClient(options) {\n    var _this;\n    _classCallCheck(this, SocksClient);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SocksClient).call(this));\n    _this.options = Object.assign({}, options);\n    // Validate SocksClientOptions\n    (0, helpers_1.validateSocksClientOptions)(options);\n    // Default state\n    _this.setState(constants_1.SocksClientState.Created);\n    return _this;\n  }\n  /**\n   * Creates a new SOCKS connection.\n   *\n   * Note: Supports callbacks and promises. Only supports the connect command.\n   * @param options { SocksClientOptions } Options.\n   * @param callback { Function } An optional callback function.\n   * @returns { Promise }\n   */\n  _createClass(SocksClient, [{\n    key: \"setState\",\n    /**\n     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.\n     */\n    value: function setState(newState) {\n      if (this.state !== constants_1.SocksClientState.Error) {\n        this.state = newState;\n      }\n    }\n    /**\n     * Starts the connection establishment to the proxy and destination.\n     * @param existingSocket Connected socket to use instead of creating a new one (internal use).\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(existingSocket) {\n      var _this2 = this;\n      this.onDataReceived = function (data) {\n        return _this2.onDataReceivedHandler(data);\n      };\n      this.onClose = function () {\n        return _this2.onCloseHandler();\n      };\n      this.onError = function (err) {\n        return _this2.onErrorHandler(err);\n      };\n      this.onConnect = function () {\n        return _this2.onConnectHandler();\n      };\n      // Start timeout timer (defaults to 30 seconds)\n      var timer = setTimeout(function () {\n        return _this2.onEstablishedTimeout();\n      }, this.options.timeout || constants_1.DEFAULT_TIMEOUT);\n      // check whether unref is available as it differs from browser to NodeJS (#33)\n      if (timer.unref && typeof timer.unref === 'function') {\n        timer.unref();\n      }\n      // If an existing socket is provided, use it to negotiate SOCKS handshake. Otherwise create a new Socket.\n      if (existingSocket) {\n        this.socket = existingSocket;\n      } else {\n        this.socket = new net.Socket();\n      }\n      // Attach Socket error handlers.\n      this.socket.once('close', this.onClose);\n      this.socket.once('error', this.onError);\n      this.socket.once('connect', this.onConnect);\n      this.socket.on('data', this.onDataReceived);\n      this.setState(constants_1.SocksClientState.Connecting);\n      this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();\n      if (existingSocket) {\n        this.socket.emit('connect');\n      } else {\n        this.socket.connect(this.getSocketOptions());\n        if (this.options.set_tcp_nodelay !== undefined && this.options.set_tcp_nodelay !== null) {\n          this.socket.setNoDelay(!!this.options.set_tcp_nodelay);\n        }\n      }\n      // Listen for established event so we can re-emit any excess data received during handshakes.\n      this.prependOnceListener('established', function (info) {\n        setImmediate(function () {\n          if (_this2.receiveBuffer.length > 0) {\n            var excessData = _this2.receiveBuffer.get(_this2.receiveBuffer.length);\n            info.socket.emit('data', excessData);\n          }\n          info.socket.resume();\n        });\n      });\n    } // Socket options (defaults host/port to options.proxy.host/options.proxy.port)\n  }, {\n    key: \"getSocketOptions\",\n    value: function getSocketOptions() {\n      return Object.assign(Object.assign({}, this.options.socket_options), {\n        host: this.options.proxy.host || this.options.proxy.ipaddress,\n        port: this.options.proxy.port\n      });\n    }\n    /**\n     * Handles internal Socks timeout callback.\n     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.\n     */\n  }, {\n    key: \"onEstablishedTimeout\",\n    value: function onEstablishedTimeout() {\n      if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {\n        this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);\n      }\n    }\n    /**\n     * Handles Socket connect event.\n     */\n  }, {\n    key: \"onConnectHandler\",\n    value: function onConnectHandler() {\n      this.setState(constants_1.SocksClientState.Connected);\n      // Send initial handshake.\n      if (this.options.proxy.type === 4) {\n        this.sendSocks4InitialHandshake();\n      } else {\n        this.sendSocks5InitialHandshake();\n      }\n      this.setState(constants_1.SocksClientState.SentInitialHandshake);\n    }\n    /**\n     * Handles Socket data event.\n     * @param data\n     */\n  }, {\n    key: \"onDataReceivedHandler\",\n    value: function onDataReceivedHandler(data) {\n      /*\n        All received data is appended to a ReceiveBuffer.\n        This makes sure that all the data we need is received before we attempt to process it.\n      */\n      this.receiveBuffer.append(data);\n      // Process data that we have.\n      this.processData();\n    }\n    /**\n     * Handles processing of the data we have received.\n     */\n  }, {\n    key: \"processData\",\n    value: function processData() {\n      // If we have enough data to process the next step in the SOCKS handshake, proceed.\n      while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {\n        // Sent initial handshake, waiting for response.\n        if (this.state === constants_1.SocksClientState.SentInitialHandshake) {\n          if (this.options.proxy.type === 4) {\n            // Socks v4 only has one handshake response.\n            this.handleSocks4FinalHandshakeResponse();\n          } else {\n            // Socks v5 has two handshakes, handle initial one here.\n            this.handleInitialSocks5HandshakeResponse();\n          }\n          // Sent auth request for Socks v5, waiting for response.\n        } else if (this.state === constants_1.SocksClientState.SentAuthentication) {\n          this.handleInitialSocks5AuthenticationHandshakeResponse();\n          // Sent final Socks v5 handshake, waiting for final response.\n        } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {\n          this.handleSocks5FinalHandshakeResponse();\n          // Socks BIND established. Waiting for remote connection via proxy.\n        } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {\n          if (this.options.proxy.type === 4) {\n            this.handleSocks4IncomingConnectionResponse();\n          } else {\n            this.handleSocks5IncomingConnectionResponse();\n          }\n        } else {\n          this.closeSocket(constants_1.ERRORS.InternalError);\n          break;\n        }\n      }\n    }\n    /**\n     * Handles Socket close event.\n     * @param had_error\n     */\n  }, {\n    key: \"onCloseHandler\",\n    value: function onCloseHandler() {\n      this.closeSocket(constants_1.ERRORS.SocketClosed);\n    }\n    /**\n     * Handles Socket error event.\n     * @param err\n     */\n  }, {\n    key: \"onErrorHandler\",\n    value: function onErrorHandler(err) {\n      this.closeSocket(err.message);\n    }\n    /**\n     * Removes internal event listeners on the underlying Socket.\n     */\n  }, {\n    key: \"removeInternalSocketHandlers\",\n    value: function removeInternalSocketHandlers() {\n      // Pauses data flow of the socket (this is internally resumed after 'established' is emitted)\n      this.socket.pause();\n      this.socket.removeListener('data', this.onDataReceived);\n      this.socket.removeListener('close', this.onClose);\n      this.socket.removeListener('error', this.onError);\n      this.socket.removeListener('connect', this.onConnect);\n    }\n    /**\n     * Closes and destroys the underlying Socket. Emits an error event.\n     * @param err { String } An error string to include in error event.\n     */\n  }, {\n    key: \"closeSocket\",\n    value: function closeSocket(err) {\n      // Make sure only one 'error' event is fired for the lifetime of this SocksClient instance.\n      if (this.state !== constants_1.SocksClientState.Error) {\n        // Set internal state to Error.\n        this.setState(constants_1.SocksClientState.Error);\n        // Destroy Socket\n        this.socket.destroy();\n        // Remove internal listeners\n        this.removeInternalSocketHandlers();\n        // Fire 'error' event.\n        this.emit('error', new util_1.SocksClientError(err, this.options));\n      }\n    }\n    /**\n     * Sends initial Socks v4 handshake request.\n     */\n  }, {\n    key: \"sendSocks4InitialHandshake\",\n    value: function sendSocks4InitialHandshake() {\n      var userId = this.options.proxy.userId || '';\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt8(0x04);\n      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);\n      buff.writeUInt16BE(this.options.destination.port);\n      // Socks 4 (IPv4)\n      if (net.isIPv4(this.options.destination.host)) {\n        buff.writeBuffer(ip.toBuffer(this.options.destination.host));\n        buff.writeStringNT(userId);\n        // Socks 4a (hostname)\n      } else {\n        buff.writeUInt8(0x00);\n        buff.writeUInt8(0x00);\n        buff.writeUInt8(0x00);\n        buff.writeUInt8(0x01);\n        buff.writeStringNT(userId);\n        buff.writeStringNT(this.options.destination.host);\n      }\n      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;\n      this.socket.write(buff.toBuffer());\n    }\n    /**\n     * Handles Socks v4 handshake response.\n     * @param data\n     */\n  }, {\n    key: \"handleSocks4FinalHandshakeResponse\",\n    value: function handleSocks4FinalHandshakeResponse() {\n      var data = this.receiveBuffer.get(8);\n      if (data[1] !== constants_1.Socks4Response.Granted) {\n        this.closeSocket(\"\".concat(constants_1.ERRORS.Socks4ProxyRejectedConnection, \" - (\").concat(constants_1.Socks4Response[data[1]], \")\"));\n      } else {\n        // Bind response\n        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {\n          var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n          buff.readOffset = 2;\n          var remoteHost = {\n            port: buff.readUInt16BE(),\n            host: ip.fromLong(buff.readUInt32BE())\n          };\n          // If host is 0.0.0.0, set to proxy host.\n          if (remoteHost.host === '0.0.0.0') {\n            remoteHost.host = this.options.proxy.ipaddress;\n          }\n          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);\n          this.emit('bound', {\n            remoteHost: remoteHost,\n            socket: this.socket\n          });\n          // Connect response\n        } else {\n          this.setState(constants_1.SocksClientState.Established);\n          this.removeInternalSocketHandlers();\n          this.emit('established', {\n            socket: this.socket\n          });\n        }\n      }\n    }\n    /**\n     * Handles Socks v4 incoming connection request (BIND)\n     * @param data\n     */\n  }, {\n    key: \"handleSocks4IncomingConnectionResponse\",\n    value: function handleSocks4IncomingConnectionResponse() {\n      var data = this.receiveBuffer.get(8);\n      if (data[1] !== constants_1.Socks4Response.Granted) {\n        this.closeSocket(\"\".concat(constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection, \" - (\").concat(constants_1.Socks4Response[data[1]], \")\"));\n      } else {\n        var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n        buff.readOffset = 2;\n        var remoteHost = {\n          port: buff.readUInt16BE(),\n          host: ip.fromLong(buff.readUInt32BE())\n        };\n        this.setState(constants_1.SocksClientState.Established);\n        this.removeInternalSocketHandlers();\n        this.emit('established', {\n          remoteHost: remoteHost,\n          socket: this.socket\n        });\n      }\n    }\n    /**\n     * Sends initial Socks v5 handshake request.\n     */\n  }, {\n    key: \"sendSocks5InitialHandshake\",\n    value: function sendSocks5InitialHandshake() {\n      var buff = new smart_buffer_1.SmartBuffer();\n      // By default we always support no auth.\n      var supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];\n      // We should only tell the proxy we support user/pass auth if auth info is actually provided.\n      // Note: As of Tor v0.3.5.7+, if user/pass auth is an option from the client, by default it will always take priority.\n      if (this.options.proxy.userId || this.options.proxy.password) {\n        supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);\n      }\n      // Custom auth method?\n      if (this.options.proxy.custom_auth_method !== undefined) {\n        supportedAuthMethods.push(this.options.proxy.custom_auth_method);\n      }\n      // Build handshake packet\n      buff.writeUInt8(0x05);\n      buff.writeUInt8(supportedAuthMethods.length);\n      for (var _i = 0, _supportedAuthMethods = supportedAuthMethods; _i < _supportedAuthMethods.length; _i++) {\n        var authMethod = _supportedAuthMethods[_i];\n        buff.writeUInt8(authMethod);\n      }\n      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;\n      this.socket.write(buff.toBuffer());\n      this.setState(constants_1.SocksClientState.SentInitialHandshake);\n    }\n    /**\n     * Handles initial Socks v5 handshake response.\n     * @param data\n     */\n  }, {\n    key: \"handleInitialSocks5HandshakeResponse\",\n    value: function handleInitialSocks5HandshakeResponse() {\n      var data = this.receiveBuffer.get(2);\n      if (data[0] !== 0x05) {\n        this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);\n      } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {\n        this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);\n      } else {\n        // If selected Socks v5 auth method is no auth, send final handshake request.\n        if (data[1] === constants_1.Socks5Auth.NoAuth) {\n          this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;\n          this.sendSocks5CommandRequest();\n          // If selected Socks v5 auth method is user/password, send auth handshake.\n        } else if (data[1] === constants_1.Socks5Auth.UserPass) {\n          this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;\n          this.sendSocks5UserPassAuthentication();\n          // If selected Socks v5 auth method is the custom_auth_method, send custom handshake.\n        } else if (data[1] === this.options.proxy.custom_auth_method) {\n          this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;\n          this.sendSocks5CustomAuthentication();\n        } else {\n          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);\n        }\n      }\n    }\n    /**\n     * Sends Socks v5 user & password auth handshake.\n     *\n     * Note: No auth and user/pass are currently supported.\n     */\n  }, {\n    key: \"sendSocks5UserPassAuthentication\",\n    value: function sendSocks5UserPassAuthentication() {\n      var userId = this.options.proxy.userId || '';\n      var password = this.options.proxy.password || '';\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt8(0x01);\n      buff.writeUInt8(Buffer.byteLength(userId));\n      buff.writeString(userId);\n      buff.writeUInt8(Buffer.byteLength(password));\n      buff.writeString(password);\n      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;\n      this.socket.write(buff.toBuffer());\n      this.setState(constants_1.SocksClientState.SentAuthentication);\n    }\n  }, {\n    key: \"sendSocks5CustomAuthentication\",\n    value: function sendSocks5CustomAuthentication() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;\n                _context.t0 = this.socket;\n                _context.next = 4;\n                return this.options.proxy.custom_auth_request_handler();\n              case 4:\n                _context.t1 = _context.sent;\n                _context.t0.write.call(_context.t0, _context.t1);\n                this.setState(constants_1.SocksClientState.SentAuthentication);\n              case 7:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"handleSocks5CustomAuthHandshakeResponse\",\n    value: function handleSocks5CustomAuthHandshakeResponse(data) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.options.proxy.custom_auth_response_handler(data);\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }, {\n    key: \"handleSocks5AuthenticationNoAuthHandshakeResponse\",\n    value: function handleSocks5AuthenticationNoAuthHandshakeResponse(data) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", data[1] === 0x00);\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n    }\n  }, {\n    key: \"handleSocks5AuthenticationUserPassHandshakeResponse\",\n    value: function handleSocks5AuthenticationUserPassHandshakeResponse(data) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                return _context4.abrupt(\"return\", data[1] === 0x00);\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n    }\n    /**\n     * Handles Socks v5 auth handshake response.\n     * @param data\n     */\n  }, {\n    key: \"handleInitialSocks5AuthenticationHandshakeResponse\",\n    value: function handleInitialSocks5AuthenticationHandshakeResponse() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var authResult;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);\n                authResult = false;\n                if (!(this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth)) {\n                  _context5.next = 8;\n                  break;\n                }\n                _context5.next = 5;\n                return this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));\n              case 5:\n                authResult = _context5.sent;\n                _context5.next = 18;\n                break;\n              case 8:\n                if (!(this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass)) {\n                  _context5.next = 14;\n                  break;\n                }\n                _context5.next = 11;\n                return this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));\n              case 11:\n                authResult = _context5.sent;\n                _context5.next = 18;\n                break;\n              case 14:\n                if (!(this.socks5ChosenAuthType === this.options.proxy.custom_auth_method)) {\n                  _context5.next = 18;\n                  break;\n                }\n                _context5.next = 17;\n                return this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));\n              case 17:\n                authResult = _context5.sent;\n              case 18:\n                if (!authResult) {\n                  this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);\n                } else {\n                  this.sendSocks5CommandRequest();\n                }\n              case 19:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n    /**\n     * Sends Socks v5 final handshake request.\n     */\n  }, {\n    key: \"sendSocks5CommandRequest\",\n    value: function sendSocks5CommandRequest() {\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt8(0x05);\n      buff.writeUInt8(constants_1.SocksCommand[this.options.command]);\n      buff.writeUInt8(0x00);\n      // ipv4, ipv6, domain?\n      if (net.isIPv4(this.options.destination.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n        buff.writeBuffer(ip.toBuffer(this.options.destination.host));\n      } else if (net.isIPv6(this.options.destination.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n        buff.writeBuffer(ip.toBuffer(this.options.destination.host));\n      } else {\n        buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n        buff.writeUInt8(this.options.destination.host.length);\n        buff.writeString(this.options.destination.host);\n      }\n      buff.writeUInt16BE(this.options.destination.port);\n      this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n      this.socket.write(buff.toBuffer());\n      this.setState(constants_1.SocksClientState.SentFinalHandshake);\n    }\n    /**\n     * Handles Socks v5 final handshake response.\n     * @param data\n     */\n  }, {\n    key: \"handleSocks5FinalHandshakeResponse\",\n    value: function handleSocks5FinalHandshakeResponse() {\n      // Peek at available data (we need at least 5 bytes to get the hostname length)\n      var header = this.receiveBuffer.peek(5);\n      if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n        this.closeSocket(\"\".concat(constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected, \" - \").concat(constants_1.Socks5Response[header[1]]));\n      } else {\n        // Read address type\n        var addressType = header[3];\n        var remoteHost;\n        var buff;\n        // IPv4\n        if (addressType === constants_1.Socks5HostType.IPv4) {\n          // Check if data is available.\n          var dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n          if (this.receiveBuffer.length < dataNeeded) {\n            this.nextRequiredPacketBufferSize = dataNeeded;\n            return;\n          }\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n          remoteHost = {\n            host: ip.fromLong(buff.readUInt32BE()),\n            port: buff.readUInt16BE()\n          };\n          // If given host is 0.0.0.0, assume remote proxy ip instead.\n          if (remoteHost.host === '0.0.0.0') {\n            remoteHost.host = this.options.proxy.ipaddress;\n          }\n          // Hostname\n        } else if (addressType === constants_1.Socks5HostType.Hostname) {\n          var hostLength = header[4];\n          var _dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + host + port\n          // Check if data is available.\n          if (this.receiveBuffer.length < _dataNeeded) {\n            this.nextRequiredPacketBufferSize = _dataNeeded;\n            return;\n          }\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded).slice(5));\n          remoteHost = {\n            host: buff.readString(hostLength),\n            port: buff.readUInt16BE()\n          };\n          // IPv6\n        } else if (addressType === constants_1.Socks5HostType.IPv6) {\n          // Check if data is available.\n          var _dataNeeded2 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n          if (this.receiveBuffer.length < _dataNeeded2) {\n            this.nextRequiredPacketBufferSize = _dataNeeded2;\n            return;\n          }\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded2).slice(4));\n          remoteHost = {\n            host: ip.toString(buff.readBuffer(16)),\n            port: buff.readUInt16BE()\n          };\n        }\n        // We have everything we need\n        this.setState(constants_1.SocksClientState.ReceivedFinalResponse);\n        // If using CONNECT, the client is now in the established state.\n        if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {\n          this.setState(constants_1.SocksClientState.Established);\n          this.removeInternalSocketHandlers();\n          this.emit('established', {\n            remoteHost: remoteHost,\n            socket: this.socket\n          });\n        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {\n          /* If using BIND, the Socks client is now in BoundWaitingForConnection state.\n             This means that the remote proxy server is waiting for a remote connection to the bound port. */\n          this.setState(constants_1.SocksClientState.BoundWaitingForConnection);\n          this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;\n          this.emit('bound', {\n            remoteHost: remoteHost,\n            socket: this.socket\n          });\n          /*\n            If using Associate, the Socks client is now Established. And the proxy server is now accepting UDP packets at the\n            given bound port. This initial Socks TCP connection must remain open for the UDP relay to continue to work.\n          */\n        } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {\n          this.setState(constants_1.SocksClientState.Established);\n          this.removeInternalSocketHandlers();\n          this.emit('established', {\n            remoteHost: remoteHost,\n            socket: this.socket\n          });\n        }\n      }\n    }\n    /**\n     * Handles Socks v5 incoming connection request (BIND).\n     */\n  }, {\n    key: \"handleSocks5IncomingConnectionResponse\",\n    value: function handleSocks5IncomingConnectionResponse() {\n      // Peek at available data (we need at least 5 bytes to get the hostname length)\n      var header = this.receiveBuffer.peek(5);\n      if (header[0] !== 0x05 || header[1] !== constants_1.Socks5Response.Granted) {\n        this.closeSocket(\"\".concat(constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection, \" - \").concat(constants_1.Socks5Response[header[1]]));\n      } else {\n        // Read address type\n        var addressType = header[3];\n        var remoteHost;\n        var buff;\n        // IPv4\n        if (addressType === constants_1.Socks5HostType.IPv4) {\n          // Check if data is available.\n          var dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;\n          if (this.receiveBuffer.length < dataNeeded) {\n            this.nextRequiredPacketBufferSize = dataNeeded;\n            return;\n          }\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));\n          remoteHost = {\n            host: ip.fromLong(buff.readUInt32BE()),\n            port: buff.readUInt16BE()\n          };\n          // If given host is 0.0.0.0, assume remote proxy ip instead.\n          if (remoteHost.host === '0.0.0.0') {\n            remoteHost.host = this.options.proxy.ipaddress;\n          }\n          // Hostname\n        } else if (addressType === constants_1.Socks5HostType.Hostname) {\n          var hostLength = header[4];\n          var _dataNeeded3 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength); // header + host length + port\n          // Check if data is available.\n          if (this.receiveBuffer.length < _dataNeeded3) {\n            this.nextRequiredPacketBufferSize = _dataNeeded3;\n            return;\n          }\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded3).slice(5));\n          remoteHost = {\n            host: buff.readString(hostLength),\n            port: buff.readUInt16BE()\n          };\n          // IPv6\n        } else if (addressType === constants_1.Socks5HostType.IPv6) {\n          // Check if data is available.\n          var _dataNeeded4 = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;\n          if (this.receiveBuffer.length < _dataNeeded4) {\n            this.nextRequiredPacketBufferSize = _dataNeeded4;\n            return;\n          }\n          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(_dataNeeded4).slice(4));\n          remoteHost = {\n            host: ip.toString(buff.readBuffer(16)),\n            port: buff.readUInt16BE()\n          };\n        }\n        this.setState(constants_1.SocksClientState.Established);\n        this.removeInternalSocketHandlers();\n        this.emit('established', {\n          remoteHost: remoteHost,\n          socket: this.socket\n        });\n      }\n    }\n  }, {\n    key: \"socksClientOptions\",\n    get: function get() {\n      return Object.assign({}, this.options);\n    }\n  }], [{\n    key: \"createConnection\",\n    value: function createConnection(options, callback) {\n      return new Promise(function (resolve, reject) {\n        // Validate SocksClientOptions\n        try {\n          (0, helpers_1.validateSocksClientOptions)(options, ['connect']);\n        } catch (err) {\n          if (typeof callback === 'function') {\n            callback(err);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return resolve(err); // Resolves pending promise (prevents memory leaks).\n          } else {\n            return reject(err);\n          }\n        }\n        var client = new SocksClient(options);\n        client.connect(options.existing_socket);\n        client.once('established', function (info) {\n          client.removeAllListeners();\n          if (typeof callback === 'function') {\n            callback(null, info);\n            resolve(info); // Resolves pending promise (prevents memory leaks).\n          } else {\n            resolve(info);\n          }\n        });\n        // Error occurred, failed to establish connection.\n        client.once('error', function (err) {\n          client.removeAllListeners();\n          if (typeof callback === 'function') {\n            callback(err);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            resolve(err); // Resolves pending promise (prevents memory leaks).\n          } else {\n            reject(err);\n          }\n        });\n      });\n    }\n    /**\n     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.\n     *\n     * Note: Supports callbacks and promises. Only supports the connect method.\n     * Note: Implemented via createConnection() factory function.\n     * @param options { SocksClientChainOptions } Options\n     * @param callback { Function } An optional callback function.\n     * @returns { Promise }\n     */\n  }, {\n    key: \"createConnectionChain\",\n    value: function createConnectionChain(options, callback) {\n      var _this3 = this;\n      // eslint-disable-next-line no-async-promise-executor\n      return new Promise(function (resolve, reject) {\n        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n          var sock, i, nextProxy, nextDestination, result;\n          return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n            while (1) {\n              switch (_context6.prev = _context6.next) {\n                case 0:\n                  _context6.prev = 0;\n                  (0, helpers_1.validateSocksClientChainOptions)(options);\n                  _context6.next = 12;\n                  break;\n                case 4:\n                  _context6.prev = 4;\n                  _context6.t0 = _context6[\"catch\"](0);\n                  if (!(typeof callback === 'function')) {\n                    _context6.next = 11;\n                    break;\n                  }\n                  callback(_context6.t0);\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  return _context6.abrupt(\"return\", resolve(_context6.t0));\n                case 11:\n                  return _context6.abrupt(\"return\", reject(_context6.t0));\n                case 12:\n                  // Shuffle proxies\n                  if (options.randomizeChain) {\n                    (0, util_1.shuffleArray)(options.proxies);\n                  }\n                  _context6.prev = 13;\n                  i = 0;\n                case 15:\n                  if (!(i < options.proxies.length)) {\n                    _context6.next = 25;\n                    break;\n                  }\n                  nextProxy = options.proxies[i]; // If we've reached the last proxy in the chain, the destination is the actual destination, otherwise it's the next proxy.\n                  nextDestination = i === options.proxies.length - 1 ? options.destination : {\n                    host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,\n                    port: options.proxies[i + 1].port\n                  }; // Creates the next connection in the chain.\n                  _context6.next = 20;\n                  return SocksClient.createConnection({\n                    command: 'connect',\n                    proxy: nextProxy,\n                    destination: nextDestination\n                    // Initial connection ignores this as sock is undefined. Subsequent connections re-use the first proxy socket to form a chain.\n                  });\n                case 20:\n                  result = _context6.sent;\n                  // If sock is undefined, assign it here.\n                  if (!sock) {\n                    sock = result.socket;\n                  }\n                case 22:\n                  i++;\n                  _context6.next = 15;\n                  break;\n                case 25:\n                  if (typeof callback === 'function') {\n                    callback(null, {\n                      socket: sock\n                    });\n                    resolve({\n                      socket: sock\n                    }); // Resolves pending promise (prevents memory leaks).\n                  } else {\n                    resolve({\n                      socket: sock\n                    });\n                  }\n                  _context6.next = 31;\n                  break;\n                case 28:\n                  _context6.prev = 28;\n                  _context6.t1 = _context6[\"catch\"](13);\n                  if (typeof callback === 'function') {\n                    callback(_context6.t1);\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    resolve(_context6.t1); // Resolves pending promise (prevents memory leaks).\n                  } else {\n                    reject(_context6.t1);\n                  }\n                case 31:\n                case \"end\":\n                  return _context6.stop();\n              }\n            }\n          }, _callee6, null, [[0, 4], [13, 28]]);\n        }));\n      });\n    }\n    /**\n     * Creates a SOCKS UDP Frame.\n     * @param options\n     */\n  }, {\n    key: \"createUDPFrame\",\n    value: function createUDPFrame(options) {\n      var buff = new smart_buffer_1.SmartBuffer();\n      buff.writeUInt16BE(0);\n      buff.writeUInt8(options.frameNumber || 0);\n      // IPv4/IPv6/Hostname\n      if (net.isIPv4(options.remoteHost.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv4);\n        buff.writeUInt32BE(ip.toLong(options.remoteHost.host));\n      } else if (net.isIPv6(options.remoteHost.host)) {\n        buff.writeUInt8(constants_1.Socks5HostType.IPv6);\n        buff.writeBuffer(ip.toBuffer(options.remoteHost.host));\n      } else {\n        buff.writeUInt8(constants_1.Socks5HostType.Hostname);\n        buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));\n        buff.writeString(options.remoteHost.host);\n      }\n      // Port\n      buff.writeUInt16BE(options.remoteHost.port);\n      // Data\n      buff.writeBuffer(options.data);\n      return buff.toBuffer();\n    }\n    /**\n     * Parses a SOCKS UDP frame.\n     * @param data\n     */\n  }, {\n    key: \"parseUDPFrame\",\n    value: function parseUDPFrame(data) {\n      var buff = smart_buffer_1.SmartBuffer.fromBuffer(data);\n      buff.readOffset = 2;\n      var frameNumber = buff.readUInt8();\n      var hostType = buff.readUInt8();\n      var remoteHost;\n      if (hostType === constants_1.Socks5HostType.IPv4) {\n        remoteHost = ip.fromLong(buff.readUInt32BE());\n      } else if (hostType === constants_1.Socks5HostType.IPv6) {\n        remoteHost = ip.toString(buff.readBuffer(16));\n      } else {\n        remoteHost = buff.readString(buff.readUInt8());\n      }\n      var remotePort = buff.readUInt16BE();\n      return {\n        frameNumber: frameNumber,\n        remoteHost: {\n          host: remoteHost,\n          port: remotePort\n        },\n        data: buff.readBuffer()\n      };\n    }\n  }]);\n  return SocksClient;\n}(events_1.EventEmitter);\nexports.SocksClient = SocksClient;","map":null,"metadata":{},"sourceType":"script"}