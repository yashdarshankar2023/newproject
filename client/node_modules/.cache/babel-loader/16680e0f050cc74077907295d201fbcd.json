{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readPreferenceServerSelector = exports.secondaryWritableServerSelector = exports.sameServerSelector = exports.writableServerSelector = exports.MIN_SECONDARY_WRITE_WIRE_VERSION = void 0;\nvar error_1 = require(\"../error\");\nvar read_preference_1 = require(\"../read_preference\");\nvar common_1 = require(\"./common\");\n// max staleness constants\nvar IDLE_WRITE_PERIOD = 10000;\nvar SMALLEST_MAX_STALENESS_SECONDS = 90;\n//  Minimum version to try writes on secondaries.\nexports.MIN_SECONDARY_WRITE_WIRE_VERSION = 13;\n/**\n * Returns a server selector that selects for writable servers\n */\nfunction writableServerSelector() {\n  return function (topologyDescription, servers) {\n    return latencyWindowReducer(topologyDescription, servers.filter(function (s) {\n      return s.isWritable;\n    }));\n  };\n}\nexports.writableServerSelector = writableServerSelector;\n/**\n * The purpose of this selector is to select the same server, only\n * if it is in a state that it can have commands sent to it.\n */\nfunction sameServerSelector(description) {\n  return function (topologyDescription, servers) {\n    if (!description) return [];\n    // Filter the servers to match the provided description only if\n    // the type is not unknown.\n    return servers.filter(function (sd) {\n      return sd.address === description.address && sd.type !== common_1.ServerType.Unknown;\n    });\n  };\n}\nexports.sameServerSelector = sameServerSelector;\n/**\n * Returns a server selector that uses a read preference to select a\n * server potentially for a write on a secondary.\n */\nfunction secondaryWritableServerSelector(wireVersion, readPreference) {\n  // If server version < 5.0, read preference always primary.\n  // If server version >= 5.0...\n  // - If read preference is supplied, use that.\n  // - If no read preference is supplied, use primary.\n  if (!readPreference || !wireVersion || wireVersion && wireVersion < exports.MIN_SECONDARY_WRITE_WIRE_VERSION) {\n    return readPreferenceServerSelector(read_preference_1.ReadPreference.primary);\n  }\n  return readPreferenceServerSelector(readPreference);\n}\nexports.secondaryWritableServerSelector = secondaryWritableServerSelector;\n/**\n * Reduces the passed in array of servers by the rules of the \"Max Staleness\" specification\n * found here: https://github.com/mongodb/specifications/blob/master/source/max-staleness/max-staleness.rst\n *\n * @param readPreference - The read preference providing max staleness guidance\n * @param topologyDescription - The topology description\n * @param servers - The list of server descriptions to be reduced\n * @returns The list of servers that satisfy the requirements of max staleness\n */\nfunction maxStalenessReducer(readPreference, topologyDescription, servers) {\n  if (readPreference.maxStalenessSeconds == null || readPreference.maxStalenessSeconds < 0) {\n    return servers;\n  }\n  var maxStaleness = readPreference.maxStalenessSeconds;\n  var maxStalenessVariance = (topologyDescription.heartbeatFrequencyMS + IDLE_WRITE_PERIOD) / 1000;\n  if (maxStaleness < maxStalenessVariance) {\n    throw new error_1.MongoInvalidArgumentError(\"Option \\\"maxStalenessSeconds\\\" must be at least \".concat(maxStalenessVariance, \" seconds\"));\n  }\n  if (maxStaleness < SMALLEST_MAX_STALENESS_SECONDS) {\n    throw new error_1.MongoInvalidArgumentError(\"Option \\\"maxStalenessSeconds\\\" must be at least \".concat(SMALLEST_MAX_STALENESS_SECONDS, \" seconds\"));\n  }\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetWithPrimary) {\n    var primary = Array.from(topologyDescription.servers.values()).filter(primaryFilter)[0];\n    return servers.reduce(function (result, server) {\n      var _a;\n      var stalenessMS = server.lastUpdateTime - server.lastWriteDate - (primary.lastUpdateTime - primary.lastWriteDate) + topologyDescription.heartbeatFrequencyMS;\n      var staleness = stalenessMS / 1000;\n      var maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n      return result;\n    }, []);\n  }\n  if (topologyDescription.type === common_1.TopologyType.ReplicaSetNoPrimary) {\n    if (servers.length === 0) {\n      return servers;\n    }\n    var sMax = servers.reduce(function (max, s) {\n      return s.lastWriteDate > max.lastWriteDate ? s : max;\n    });\n    return servers.reduce(function (result, server) {\n      var _a;\n      var stalenessMS = sMax.lastWriteDate - server.lastWriteDate + topologyDescription.heartbeatFrequencyMS;\n      var staleness = stalenessMS / 1000;\n      var maxStalenessSeconds = (_a = readPreference.maxStalenessSeconds) !== null && _a !== void 0 ? _a : 0;\n      if (staleness <= maxStalenessSeconds) {\n        result.push(server);\n      }\n      return result;\n    }, []);\n  }\n  return servers;\n}\n/**\n * Determines whether a server's tags match a given set of tags\n *\n * @param tagSet - The requested tag set to match\n * @param serverTags - The server's tags\n */\nfunction tagSetMatch(tagSet, serverTags) {\n  var keys = Object.keys(tagSet);\n  var serverTagKeys = Object.keys(serverTags);\n  for (var i = 0; i < keys.length; ++i) {\n    var key = keys[i];\n    if (serverTagKeys.indexOf(key) === -1 || serverTags[key] !== tagSet[key]) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Reduces a set of server descriptions based on tags requested by the read preference\n *\n * @param readPreference - The read preference providing the requested tags\n * @param servers - The list of server descriptions to reduce\n * @returns The list of servers matching the requested tags\n */\nfunction tagSetReducer(readPreference, servers) {\n  if (readPreference.tags == null || Array.isArray(readPreference.tags) && readPreference.tags.length === 0) {\n    return servers;\n  }\n  var _loop = function _loop(i) {\n    var tagSet = readPreference.tags[i];\n    var serversMatchingTagset = servers.reduce(function (matched, server) {\n      if (tagSetMatch(tagSet, server.tags)) matched.push(server);\n      return matched;\n    }, []);\n    if (serversMatchingTagset.length) {\n      return {\n        v: serversMatchingTagset\n      };\n    }\n  };\n  for (var i = 0; i < readPreference.tags.length; ++i) {\n    var _ret = _loop(i);\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n  return [];\n}\n/**\n * Reduces a list of servers to ensure they fall within an acceptable latency window. This is\n * further specified in the \"Server Selection\" specification, found here:\n * https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst\n *\n * @param topologyDescription - The topology description\n * @param servers - The list of servers to reduce\n * @returns The servers which fall within an acceptable latency window\n */\nfunction latencyWindowReducer(topologyDescription, servers) {\n  var low = servers.reduce(function (min, server) {\n    return min === -1 ? server.roundTripTime : Math.min(server.roundTripTime, min);\n  }, -1);\n  var high = low + topologyDescription.localThresholdMS;\n  return servers.reduce(function (result, server) {\n    if (server.roundTripTime <= high && server.roundTripTime >= low) result.push(server);\n    return result;\n  }, []);\n}\n// filters\nfunction primaryFilter(server) {\n  return server.type === common_1.ServerType.RSPrimary;\n}\nfunction secondaryFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary;\n}\nfunction nearestFilter(server) {\n  return server.type === common_1.ServerType.RSSecondary || server.type === common_1.ServerType.RSPrimary;\n}\nfunction knownFilter(server) {\n  return server.type !== common_1.ServerType.Unknown;\n}\nfunction loadBalancerFilter(server) {\n  return server.type === common_1.ServerType.LoadBalancer;\n}\n/**\n * Returns a function which selects servers based on a provided read preference\n *\n * @param readPreference - The read preference to select with\n */\nfunction readPreferenceServerSelector(readPreference) {\n  if (!readPreference.isValid()) {\n    throw new error_1.MongoInvalidArgumentError('Invalid read preference specified');\n  }\n  return function (topologyDescription, servers) {\n    var commonWireVersion = topologyDescription.commonWireVersion;\n    if (commonWireVersion && readPreference.minWireVersion && readPreference.minWireVersion > commonWireVersion) {\n      throw new error_1.MongoCompatibilityError(\"Minimum wire version '\".concat(readPreference.minWireVersion, \"' required, but found '\").concat(commonWireVersion, \"'\"));\n    }\n    if (topologyDescription.type === common_1.TopologyType.LoadBalanced) {\n      return servers.filter(loadBalancerFilter);\n    }\n    if (topologyDescription.type === common_1.TopologyType.Unknown) {\n      return [];\n    }\n    if (topologyDescription.type === common_1.TopologyType.Single || topologyDescription.type === common_1.TopologyType.Sharded) {\n      return latencyWindowReducer(topologyDescription, servers.filter(knownFilter));\n    }\n    var mode = readPreference.mode;\n    if (mode === read_preference_1.ReadPreference.PRIMARY) {\n      return servers.filter(primaryFilter);\n    }\n    if (mode === read_preference_1.ReadPreference.PRIMARY_PREFERRED) {\n      var result = servers.filter(primaryFilter);\n      if (result.length) {\n        return result;\n      }\n    }\n    var filter = mode === read_preference_1.ReadPreference.NEAREST ? nearestFilter : secondaryFilter;\n    var selectedServers = latencyWindowReducer(topologyDescription, tagSetReducer(readPreference, maxStalenessReducer(readPreference, topologyDescription, servers.filter(filter))));\n    if (mode === read_preference_1.ReadPreference.SECONDARY_PREFERRED && selectedServers.length === 0) {\n      return servers.filter(primaryFilter);\n    }\n    return selectedServers;\n  };\n}\nexports.readPreferenceServerSelector = readPreferenceServerSelector;","map":null,"metadata":{},"sourceType":"script"}