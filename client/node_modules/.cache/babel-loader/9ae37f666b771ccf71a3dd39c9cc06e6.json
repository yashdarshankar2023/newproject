{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.executeOperation = void 0;\nvar error_1 = require(\"../error\");\nvar read_preference_1 = require(\"../read_preference\");\nvar server_selection_1 = require(\"../sdam/server_selection\");\nvar utils_1 = require(\"../utils\");\nvar operation_1 = require(\"./operation\");\nvar MMAPv1_RETRY_WRITES_ERROR_CODE = error_1.MONGODB_ERROR_CODES.IllegalOperation;\nvar MMAPv1_RETRY_WRITES_ERROR_MESSAGE = 'This MongoDB deployment does not support retryable writes. Please add retryWrites=false to your connection string.';\nfunction executeOperation(client, operation, callback) {\n  if (!(operation instanceof operation_1.AbstractOperation)) {\n    // TODO(NODE-3483): Extend MongoRuntimeError\n    throw new error_1.MongoRuntimeError('This method requires a valid operation instance');\n  }\n  return (0, utils_1.maybePromise)(callback, function (callback) {\n    var topology = client.topology;\n    if (topology == null) {\n      if (client.s.hasBeenClosed) {\n        return callback(new error_1.MongoNotConnectedError('Client must be connected before running operations'));\n      }\n      client.s.options[Symbol.for('@@mdb.skipPingOnConnect')] = true;\n      return client.connect(function (error) {\n        delete client.s.options[Symbol.for('@@mdb.skipPingOnConnect')];\n        if (error) {\n          return callback(error);\n        }\n        return executeOperation(client, operation, callback);\n      });\n    }\n    if (topology.shouldCheckForSessionSupport()) {\n      return topology.selectServer(read_preference_1.ReadPreference.primaryPreferred, {}, function (err) {\n        if (err) return callback(err);\n        executeOperation(client, operation, callback);\n      });\n    }\n    // The driver sessions spec mandates that we implicitly create sessions for operations\n    // that are not explicitly provided with a session.\n    var session = operation.session;\n    var owner;\n    if (topology.hasSessionSupport()) {\n      if (session == null) {\n        owner = Symbol();\n        session = client.startSession({\n          owner: owner,\n          explicit: false\n        });\n      } else if (session.hasEnded) {\n        return callback(new error_1.MongoExpiredSessionError('Use of expired sessions is not permitted'));\n      } else if (session.snapshotEnabled && !topology.capabilities.supportsSnapshotReads) {\n        return callback(new error_1.MongoCompatibilityError('Snapshot reads require MongoDB 5.0 or later'));\n      }\n    } else {\n      // no session support\n      if (session && session.explicit) {\n        // If the user passed an explicit session and we are still, after server selection,\n        // trying to run against a topology that doesn't support sessions we error out.\n        return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n      } else if (session && !session.explicit) {\n        // We do not have to worry about ending the session because the server session has not been acquired yet\n        delete operation.options.session;\n        operation.clearSession();\n        session = undefined;\n      }\n    }\n    try {\n      executeWithServerSelection(topology, session, operation, function (error, result) {\n        if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n          return session.endSession(function (endSessionError) {\n            return callback(endSessionError !== null && endSessionError !== void 0 ? endSessionError : error, result);\n          });\n        }\n        callback(error, result);\n      });\n    } catch (error) {\n      if ((session === null || session === void 0 ? void 0 : session.owner) != null && session.owner === owner) {\n        session.endSession().catch(function () {\n          return null;\n        });\n      }\n      throw error;\n    }\n  });\n}\nexports.executeOperation = executeOperation;\nfunction executeWithServerSelection(topology, session, operation, callback) {\n  var _a, _b;\n  var readPreference = (_a = operation.readPreference) !== null && _a !== void 0 ? _a : read_preference_1.ReadPreference.primary;\n  var inTransaction = !!(session === null || session === void 0 ? void 0 : session.inTransaction());\n  if (inTransaction && !readPreference.equals(read_preference_1.ReadPreference.primary)) {\n    return callback(new error_1.MongoTransactionError(\"Read preference in a transaction must be primary, not: \".concat(readPreference.mode)));\n  }\n  if ((session === null || session === void 0 ? void 0 : session.isPinned) && session.transaction.isCommitted && !operation.bypassPinningCheck) {\n    session.unpin();\n  }\n  var selector;\n  if (operation.hasAspect(operation_1.Aspect.MUST_SELECT_SAME_SERVER)) {\n    // GetMore and KillCursor operations must always select the same server, but run through\n    // server selection to potentially force monitor checks if the server is\n    // in an unknown state.\n    selector = (0, server_selection_1.sameServerSelector)((_b = operation.server) === null || _b === void 0 ? void 0 : _b.description);\n  } else if (operation.trySecondaryWrite) {\n    // If operation should try to write to secondary use the custom server selector\n    // otherwise provide the read preference.\n    selector = (0, server_selection_1.secondaryWritableServerSelector)(topology.commonWireVersion, readPreference);\n  } else {\n    selector = readPreference;\n  }\n  var serverSelectionOptions = {\n    session: session\n  };\n  function retryOperation(originalError) {\n    var isWriteOperation = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n    var isReadOperation = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n    if (isWriteOperation && originalError.code === MMAPv1_RETRY_WRITES_ERROR_CODE) {\n      return callback(new error_1.MongoServerError({\n        message: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        errmsg: MMAPv1_RETRY_WRITES_ERROR_MESSAGE,\n        originalError: originalError\n      }));\n    }\n    if (isWriteOperation && !(0, error_1.isRetryableWriteError)(originalError)) {\n      return callback(originalError);\n    }\n    if (isReadOperation && !(0, error_1.isRetryableReadError)(originalError)) {\n      return callback(originalError);\n    }\n    if (originalError instanceof error_1.MongoNetworkError && (session === null || session === void 0 ? void 0 : session.isPinned) && !session.inTransaction() && operation.hasAspect(operation_1.Aspect.CURSOR_CREATING)) {\n      // If we have a cursor and the initial command fails with a network error,\n      // we can retry it on another connection. So we need to check it back in, clear the\n      // pool for the service id, and retry again.\n      session.unpin({\n        force: true,\n        forceClear: true\n      });\n    }\n    // select a new server, and attempt to retry the operation\n    topology.selectServer(selector, serverSelectionOptions, function (error, server) {\n      if (!error && isWriteOperation && !(0, utils_1.supportsRetryableWrites)(server)) {\n        return callback(new error_1.MongoUnexpectedServerResponseError('Selected server does not support retryable writes'));\n      }\n      if (error || !server) {\n        return callback(error !== null && error !== void 0 ? error : new error_1.MongoUnexpectedServerResponseError('Server selection failed without error'));\n      }\n      operation.execute(server, session, callback);\n    });\n  }\n  if (readPreference && !readPreference.equals(read_preference_1.ReadPreference.primary) && (session === null || session === void 0 ? void 0 : session.inTransaction())) {\n    callback(new error_1.MongoTransactionError(\"Read preference in a transaction must be primary, not: \".concat(readPreference.mode)));\n    return;\n  }\n  // select a server, and execute the operation against it\n  topology.selectServer(selector, serverSelectionOptions, function (error, server) {\n    if (error || !server) {\n      return callback(error);\n    }\n    if (session && operation.hasAspect(operation_1.Aspect.RETRYABLE)) {\n      var willRetryRead = topology.s.options.retryReads && !inTransaction && operation.canRetryRead;\n      var willRetryWrite = topology.s.options.retryWrites && !inTransaction && (0, utils_1.supportsRetryableWrites)(server) && operation.canRetryWrite;\n      var hasReadAspect = operation.hasAspect(operation_1.Aspect.READ_OPERATION);\n      var hasWriteAspect = operation.hasAspect(operation_1.Aspect.WRITE_OPERATION);\n      if (hasReadAspect && willRetryRead || hasWriteAspect && willRetryWrite) {\n        if (hasWriteAspect && willRetryWrite) {\n          operation.options.willRetryWrite = true;\n          session.incrementTransactionNumber();\n        }\n        return operation.execute(server, session, function (error, result) {\n          if (error instanceof error_1.MongoError) {\n            return retryOperation(error);\n          } else if (error) {\n            return callback(error);\n          }\n          callback(undefined, result);\n        });\n      }\n    }\n    return operation.execute(server, session, callback);\n  });\n}","map":null,"metadata":{},"sourceType":"script"}