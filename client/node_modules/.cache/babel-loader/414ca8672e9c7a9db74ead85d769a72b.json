{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/get\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MapReduceOperation = void 0;\nvar bson_1 = require(\"../bson\");\nvar error_1 = require(\"../error\");\nvar read_preference_1 = require(\"../read_preference\");\nvar utils_1 = require(\"../utils\");\nvar command_1 = require(\"./command\");\nvar operation_1 = require(\"./operation\");\nvar exclusionList = ['explain', 'readPreference', 'readConcern', 'session', 'bypassDocumentValidation', 'writeConcern', 'raw', 'fieldsAsRaw', 'promoteLongs', 'promoteValues', 'promoteBuffers', 'bsonRegExp', 'serializeFunctions', 'ignoreUndefined', 'enableUtf8Validation', 'scope' // this option is reformatted thus exclude the original\n];\n/**\n * Run Map Reduce across a collection. Be aware that the inline option for out will return an array of results not a collection.\n * @internal\n */\nvar MapReduceOperation = /*#__PURE__*/function (_command_1$CommandOpe) {\n  _inherits(MapReduceOperation, _command_1$CommandOpe);\n  /**\n   * Constructs a MapReduce operation.\n   *\n   * @param collection - Collection instance.\n   * @param map - The mapping function.\n   * @param reduce - The reduce function.\n   * @param options - Optional settings. See Collection.prototype.mapReduce for a list of options.\n   */\n  function MapReduceOperation(collection, map, reduce, options) {\n    var _this;\n    _classCallCheck(this, MapReduceOperation);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MapReduceOperation).call(this, collection, options));\n    _this.options = options !== null && options !== void 0 ? options : {};\n    _this.collection = collection;\n    _this.map = map;\n    _this.reduce = reduce;\n    return _this;\n  }\n  _createClass(MapReduceOperation, [{\n    key: \"execute\",\n    value: function execute(server, session, callback) {\n      var _this2 = this;\n      var coll = this.collection;\n      var map = this.map;\n      var reduce = this.reduce;\n      var options = this.options;\n      var mapCommandHash = {\n        mapReduce: coll.collectionName,\n        map: map,\n        reduce: reduce\n      };\n      if (options.scope) {\n        mapCommandHash.scope = processScope(options.scope);\n      }\n      // Add any other options passed in\n      for (var n in options) {\n        // Only include if not in exclusion list\n        if (exclusionList.indexOf(n) === -1) {\n          mapCommandHash[n] = options[n];\n        }\n      }\n      options = Object.assign({}, options);\n      // If we have a read preference and inline is not set as output fail hard\n      if (this.readPreference.mode === read_preference_1.ReadPreferenceMode.primary && options.out && options.out.inline !== 1 && options.out !== 'inline') {\n        // Force readPreference to primary\n        options.readPreference = read_preference_1.ReadPreference.primary;\n        // Decorate command with writeConcern if supported\n        (0, utils_1.applyWriteConcern)(mapCommandHash, {\n          db: coll.s.db,\n          collection: coll\n        }, options);\n      } else {\n        (0, utils_1.decorateWithReadConcern)(mapCommandHash, coll, options);\n      }\n      // Is bypassDocumentValidation specified\n      if (options.bypassDocumentValidation === true) {\n        mapCommandHash.bypassDocumentValidation = options.bypassDocumentValidation;\n      }\n      // Have we specified collation\n      try {\n        (0, utils_1.decorateWithCollation)(mapCommandHash, coll, options);\n      } catch (err) {\n        return callback(err);\n      }\n      if (this.explain && (0, utils_1.maxWireVersion)(server) < 9) {\n        callback(new error_1.MongoCompatibilityError(\"Server \".concat(server.name, \" does not support explain on mapReduce\")));\n        return;\n      }\n      // Execute command\n      _get(_getPrototypeOf(MapReduceOperation.prototype), \"executeCommand\", this).call(this, server, session, mapCommandHash, function (err, result) {\n        if (err) return callback(err);\n        // Check if we have an error\n        if (1 !== result.ok || result.err || result.errmsg) {\n          return callback(new error_1.MongoServerError(result));\n        }\n        // If an explain option was executed, don't process the server results\n        if (_this2.explain) return callback(undefined, result);\n        // Create statistics value\n        var stats = {};\n        if (result.timeMillis) stats['processtime'] = result.timeMillis;\n        if (result.counts) stats['counts'] = result.counts;\n        if (result.timing) stats['timing'] = result.timing;\n        // invoked with inline?\n        if (result.results) {\n          // If we wish for no verbosity\n          if (options['verbose'] == null || !options['verbose']) {\n            return callback(undefined, result.results);\n          }\n          return callback(undefined, {\n            results: result.results,\n            stats: stats\n          });\n        }\n        // The returned collection\n        var collection = null;\n        // If we have an object it's a different db\n        if (result.result != null && typeof result.result === 'object') {\n          var doc = result.result;\n          // Return a collection from another db\n          collection = coll.s.db.s.client.db(doc.db, coll.s.db.s.options).collection(doc.collection);\n        } else {\n          // Create a collection object that wraps the result collection\n          collection = coll.s.db.collection(result.result);\n        }\n        // If we wish for no verbosity\n        if (options['verbose'] == null || !options['verbose']) {\n          return callback(err, collection);\n        }\n        // Return stats as third set of values\n        callback(err, {\n          collection: collection,\n          stats: stats\n        });\n      });\n    }\n  }]);\n  return MapReduceOperation;\n}(command_1.CommandOperation);\nexports.MapReduceOperation = MapReduceOperation;\n/** Functions that are passed as scope args must be converted to Code instances. */\nfunction processScope(scope) {\n  if (!(0, utils_1.isObject)(scope) || scope._bsontype === 'ObjectID') {\n    return scope;\n  }\n  var newScope = {};\n  for (var _i = 0, _Object$keys = Object.keys(scope); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    if ('function' === typeof scope[key]) {\n      newScope[key] = new bson_1.Code(String(scope[key]));\n    } else if (scope[key]._bsontype === 'Code') {\n      newScope[key] = scope[key];\n    } else {\n      newScope[key] = processScope(scope[key]);\n    }\n  }\n  return newScope;\n}\n(0, operation_1.defineAspects)(MapReduceOperation, [operation_1.Aspect.EXPLAINABLE]);","map":null,"metadata":{},"sourceType":"script"}