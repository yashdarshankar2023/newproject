{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/possibleConstructorReturn\");\nvar _getPrototypeOf = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"F:\\\\programnodejs\\\\project\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/inherits\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageStream = void 0;\nvar stream_1 = require(\"stream\");\nvar error_1 = require(\"../error\");\nvar utils_1 = require(\"../utils\");\nvar commands_1 = require(\"./commands\");\nvar compression_1 = require(\"./wire_protocol/compression\");\nvar constants_1 = require(\"./wire_protocol/constants\");\nvar MESSAGE_HEADER_SIZE = 16;\nvar COMPRESSION_DETAILS_SIZE = 9; // originalOpcode + uncompressedSize, compressorID\nvar kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/** @internal */\nvar kBuffer = Symbol('buffer');\n/**\n * A duplex stream that is capable of reading and writing raw wire protocol messages, with\n * support for optional compression\n * @internal\n */\nvar MessageStream = /*#__PURE__*/function (_stream_1$Duplex) {\n  _inherits(MessageStream, _stream_1$Duplex);\n  function MessageStream() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, MessageStream);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MessageStream).call(this, options));\n    /** @internal */\n    _this.isMonitoringConnection = false;\n    _this.maxBsonMessageSize = options.maxBsonMessageSize || kDefaultMaxBsonMessageSize;\n    _this[kBuffer] = new utils_1.BufferPool();\n    return _this;\n  }\n  _createClass(MessageStream, [{\n    key: \"_write\",\n    value: function _write(chunk, _, callback) {\n      this[kBuffer].append(chunk);\n      processIncomingData(this, callback);\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      // NOTE: This implementation is empty because we explicitly push data to be read\n      //       when `writeMessage` is called.\n      return;\n    }\n  }, {\n    key: \"writeCommand\",\n    value: function writeCommand(command, operationDescription) {\n      var _this2 = this;\n      // TODO: agreed compressor should live in `StreamDescription`\n      var compressorName = operationDescription && operationDescription.agreedCompressor ? operationDescription.agreedCompressor : 'none';\n      if (compressorName === 'none' || !canCompress(command)) {\n        var data = command.toBin();\n        this.push(Array.isArray(data) ? Buffer.concat(data) : data);\n        return;\n      }\n      // otherwise, compress the message\n      var concatenatedOriginalCommandBuffer = Buffer.concat(command.toBin());\n      var messageToBeCompressed = concatenatedOriginalCommandBuffer.slice(MESSAGE_HEADER_SIZE);\n      // Extract information needed for OP_COMPRESSED from the uncompressed message\n      var originalCommandOpCode = concatenatedOriginalCommandBuffer.readInt32LE(12);\n      // Compress the message body\n      (0, compression_1.compress)({\n        options: operationDescription\n      }, messageToBeCompressed, function (err, compressedMessage) {\n        if (err || !compressedMessage) {\n          operationDescription.cb(err);\n          return;\n        }\n        // Create the msgHeader of OP_COMPRESSED\n        var msgHeader = Buffer.alloc(MESSAGE_HEADER_SIZE);\n        msgHeader.writeInt32LE(MESSAGE_HEADER_SIZE + COMPRESSION_DETAILS_SIZE + compressedMessage.length, 0); // messageLength\n        msgHeader.writeInt32LE(command.requestId, 4); // requestID\n        msgHeader.writeInt32LE(0, 8); // responseTo (zero)\n        msgHeader.writeInt32LE(constants_1.OP_COMPRESSED, 12); // opCode\n        // Create the compression details of OP_COMPRESSED\n        var compressionDetails = Buffer.alloc(COMPRESSION_DETAILS_SIZE);\n        compressionDetails.writeInt32LE(originalCommandOpCode, 0); // originalOpcode\n        compressionDetails.writeInt32LE(messageToBeCompressed.length, 4); // Size of the uncompressed compressedMessage, excluding the MsgHeader\n        compressionDetails.writeUInt8(compression_1.Compressor[compressorName], 8); // compressorID\n        _this2.push(Buffer.concat([msgHeader, compressionDetails, compressedMessage]));\n      });\n    }\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this[kBuffer];\n    }\n  }]);\n  return MessageStream;\n}(stream_1.Duplex);\nexports.MessageStream = MessageStream;\n// Return whether a command contains an uncompressible command term\n// Will return true if command contains no uncompressible command terms\nfunction canCompress(command) {\n  var commandDoc = command instanceof commands_1.Msg ? command.command : command.query;\n  var commandName = Object.keys(commandDoc)[0];\n  return !compression_1.uncompressibleCommands.has(commandName);\n}\nfunction processIncomingData(stream, callback) {\n  var buffer = stream[kBuffer];\n  if (buffer.length < 4) {\n    callback();\n    return;\n  }\n  var sizeOfMessage = buffer.peek(4).readInt32LE();\n  if (sizeOfMessage < 0) {\n    callback(new error_1.MongoParseError(\"Invalid message size: \".concat(sizeOfMessage)));\n    return;\n  }\n  if (sizeOfMessage > stream.maxBsonMessageSize) {\n    callback(new error_1.MongoParseError(\"Invalid message size: \".concat(sizeOfMessage, \", max allowed: \").concat(stream.maxBsonMessageSize)));\n    return;\n  }\n  if (sizeOfMessage > buffer.length) {\n    callback();\n    return;\n  }\n  var message = buffer.read(sizeOfMessage);\n  var messageHeader = {\n    length: message.readInt32LE(0),\n    requestId: message.readInt32LE(4),\n    responseTo: message.readInt32LE(8),\n    opCode: message.readInt32LE(12)\n  };\n  var monitorHasAnotherHello = function monitorHasAnotherHello() {\n    if (stream.isMonitoringConnection) {\n      // Can we read the next message size?\n      if (buffer.length >= 4) {\n        var _sizeOfMessage = buffer.peek(4).readInt32LE();\n        if (_sizeOfMessage <= buffer.length) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n  var ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  if (messageHeader.opCode !== constants_1.OP_COMPRESSED) {\n    var messageBody = message.slice(MESSAGE_HEADER_SIZE);\n    // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n    if (monitorHasAnotherHello()) {\n      processIncomingData(stream, callback);\n    } else {\n      stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n      if (buffer.length >= 4) {\n        processIncomingData(stream, callback);\n      } else {\n        callback();\n      }\n    }\n    return;\n  }\n  messageHeader.fromCompressed = true;\n  messageHeader.opCode = message.readInt32LE(MESSAGE_HEADER_SIZE);\n  messageHeader.length = message.readInt32LE(MESSAGE_HEADER_SIZE + 4);\n  var compressorID = message[MESSAGE_HEADER_SIZE + 8];\n  var compressedBuffer = message.slice(MESSAGE_HEADER_SIZE + 9);\n  // recalculate based on wrapped opcode\n  ResponseType = messageHeader.opCode === constants_1.OP_MSG ? commands_1.BinMsg : commands_1.Response;\n  (0, compression_1.decompress)(compressorID, compressedBuffer, function (err, messageBody) {\n    if (err || !messageBody) {\n      callback(err);\n      return;\n    }\n    if (messageBody.length !== messageHeader.length) {\n      callback(new error_1.MongoDecompressionError('Message body and message header must be the same length'));\n      return;\n    }\n    // If we are a monitoring connection message stream and\n    // there is more in the buffer that can be read, skip processing since we\n    // want the last hello command response that is in the buffer.\n    if (monitorHasAnotherHello()) {\n      processIncomingData(stream, callback);\n    } else {\n      stream.emit('message', new ResponseType(message, messageHeader, messageBody));\n      if (buffer.length >= 4) {\n        processIncomingData(stream, callback);\n      } else {\n        callback();\n      }\n    }\n  });\n}","map":null,"metadata":{},"sourceType":"script"}